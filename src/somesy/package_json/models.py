"""package.json validation models."""
import re
from typing import List, Optional, Union

from pydantic import BaseModel, EmailStr, Field, field_validator
from typing_extensions import Annotated

from somesy.core.types import HttpUrlStr


class PackageAuthor(BaseModel):
    """Package author model."""

    name: Annotated[Optional[str], Field(description="Author name")]
    email: Annotated[Optional[EmailStr], Field(description="Author email")]
    url: Annotated[
        Optional[HttpUrlStr], Field(description="Author website or orcid page")
    ]


class PackageRepository(BaseModel):
    """Package repository model."""

    type: Annotated[Optional[str], Field(description="Repository type")]
    url: Annotated[str, Field(description="Repository url")]


class PackageLicense(BaseModel):
    """Package license model."""

    type: Annotated[Optional[str], Field(description="License type")]
    url: Annotated[str, Field(description="License url")]


NPM_PKG_AUTHOR = r"^(.*?)\s*(?:<([^>]+)>)?\s*(?:\(([^)]+)\))?$"
NPM_PKG_NAME = r"^(@[a-z0-9-~][a-z0-9-._~]*\/)?[a-z0-9-~][a-z0-9-._~]*$"
NPM_PKG_VERSION = r"^(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)(?:-(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$"


class PackageJsonConfig(BaseModel):
    """Package.json config model."""

    model_config = dict(populate_by_name=True)

    name: Annotated[str, Field(description="Package name")]
    version: Annotated[str, Field(description="Package version")]
    description: Annotated[Optional[str], Field(description="Package description")]
    author: Annotated[
        Optional[Union[str, PackageAuthor]], Field(description="Package author")
    ]
    maintainers: Annotated[
        Optional[List[Union[str, PackageAuthor]]],
        Field(description="Package maintainers"),
    ] = None
    contributors: Annotated[
        Optional[List[Union[str, PackageAuthor]]],
        Field(description="Package contributors"),
    ] = None
    license: Annotated[
        Optional[Union[str, PackageLicense]], Field(description="Package license")
    ]
    repository: Annotated[
        Optional[Union[PackageRepository, str]], Field(description="Package repository")
    ]
    homepage: Annotated[
        Optional[HttpUrlStr], Field(description="Package homepage")
    ] = None
    keywords: Annotated[
        Optional[List[str]], Field(description="Keywords that describe the package")
    ] = None

    # convert package author to dict if it is a string
    @classmethod
    def convert_author(cls, author: str) -> PackageAuthor:
        """Convert author string to PackageAuthor model."""
        # parse author string to "name <email> (url)" format with regex
        author_match = re.match(NPM_PKG_AUTHOR, author)
        if not author_match:
            raise ValueError(f"Invalid author format: {author}")
        author_name = author_match[1]
        author_email = author_match[2]
        author_url = author_match[3]

        return PackageAuthor(name=author_name, email=author_email, url=author_url)

    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        """Validate package name."""
        if re.match(NPM_PKG_NAME, v) is None:
            raise ValueError("Invalid name")

        return v

    @field_validator("version")
    @classmethod
    def validate_version(cls, v):
        """Validate package version."""
        if re.match(NPM_PKG_VERSION, v) is None:
            raise ValueError("Invalid version")
        return v

    @field_validator("author")
    @classmethod
    def validate_author(cls, v):
        """Validate package author."""
        return cls.convert_author(v) if isinstance(v, str) else v

    @field_validator("maintainers", "contributors")
    @classmethod
    def validate_people(cls, v):
        """Validate package maintainers and contributors."""
        people = []
        for p in v:
            if isinstance(p, str):
                people.append(cls.convert_author(p))
            else:
                people.append(p)
        return people
