{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"somesy","text":"<p>Somesy (software metadata sync) is a CLI tool to avoid messy software project metadata by keeping it in sync.</p>"},{"location":"#description","title":"Description","text":"<p>Many development tools either declare or need information about the software project they are used in, such as: the project name, description, version, repository url, license or project authors. Most such tools come with configuration files and conventions that are specific to the programming language or chosen technology. Emerging best practices for FAIR software metadata require to add even more files where such metadata must be stated.</p> <p>If good project metadata was a fire-and-forget issue, this would be acceptable, but software is never standing still - maintainers change, contributors come and go, the version number is regularly increased, the project might be moved to a different location. Properly maintaining this kind of information in various files scattered around the project is usually tedious, error-prone and time consuming manual labor.</p> <p>Somesy automates the synchronization of software project metadata and frees your time to focus on your actual work.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get started, please check out the quickstart guide.</p>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>If you want to cite this project in your scientific work, please use the citation file in the repository.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We kindly thank all authors and contributors.</p> <p></p> <p>This project was developed at the Institute for Materials Data Science and Informatics (IAS-9) of the J\u00fclich Research Center and funded by the Helmholtz Metadata Collaboration (HMC), an incubator-platform of the Helmholtz Association within the framework of the Information and Data Science strategic initiative.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here we provide notes that summarize the most important changes in each released version.</p> <p>Please consult the changelog to inform yourself about breaking changes and security issues.</p>"},{"location":"changelog/#0.1.0","title":"v0.1.0 (2023-05-12)","text":"<ul> <li>First release</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project maintainers by e-mail. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"How To Contribute","text":"<p>All kinds of contributions are very welcome! You can contribute in various ways, e.g. by</p> <ul> <li>providing feedback</li> <li>asking questions</li> <li>suggesting ideas</li> <li>implementing features</li> <li>fixing problems</li> <li>improving documentation</li> </ul> <p>To make contributing to open source projects a good experience to everyone involved, please make sure that you follow our code of conduct when communicating with others.</p>"},{"location":"contributing/#ideas-questions-and-problems","title":"Ideas, Questions and Problems","text":"<p>If you have questions or difficulties using this software, please use the issue tracker.</p> <p>If your topic is not already covered by an existing issue, please create a new issue using one of the provided issue templates.</p> <p>If your issue is caused by incomplete, unclear or outdated documentation, we are also happy to get suggestions on how to improve it. Outdated or incorrect documentation is a bug, while missing documentation is a feature request.</p> <p>NOTE: If you want to report a critical security problem, do not open an issue! Instead, please create a private security advisory, or contact the current package maintainers directly by e-mail.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>This project uses Poetry for dependency management.</p> <p>You can run the following lines to check out the project and prepare it for development:</p> <pre><code>git clone git@github.com:Materials-Data-Science-and-Informatics/somesy.git\ncd somesy\npoetry install --with docs\npoetry run poe init-dev\n</code></pre> <p>Common tasks are accessible via poe:</p> <ul> <li> <p>Use <code>poetry run poe lint</code> to run linters manually, add <code>--all-files</code> to check everything.</p> </li> <li> <p>Use <code>poetry run poe test</code> to run tests, add <code>--cov</code> to also show test coverage.</p> </li> <li> <p>Use <code>poetry run poe docs</code> to generate local documentation</p> </li> </ul> <p>In order to contribute code, please open a pull request to the <code>dev</code> branch.</p> <p>Before opening the PR, please make sure that your changes</p> <ul> <li>are sufficiently covered by meaningful tests,</li> <li>are reflected in suitable documentation (API docs, guides, etc.), and</li> <li>successfully pass all pre-commit hooks.</li> </ul>"},{"location":"coverage/","title":"Coverage Report","text":""},{"location":"credits/","title":"Authors and Contributors","text":"<p>Main authors are persons whose contributions significantly shaped the state of the software at some point in time.</p> <p>Additional contributors are persons who are not main authors, but contributed non-trivially to this project, e.g. by providing smaller fixes and enhancements to the code and/or documentation.</p> <p>Of course, this is just a rough overview and categorization. For a more complete overview of all contributors and contributions, please inspect the git history of this repository.</p>"},{"location":"credits/#main-authors","title":"Main Authors","text":"<ul> <li> <p>Mustafa Soylu (   E-Mail,   ORCID   ): original author</p> </li> <li> <p>Anton Pirogov (   E-Mail,   ORCID   ): documentation, review, and ideas</p> </li> </ul>"},{"location":"credits/#additional-contributors","title":"Additional Contributors","text":"<ul> <li>Jens Br\u00f6der (   E-Mail,   ORCID   ): ideas</li> </ul> <p>... maybe you?</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>This guide is targeting mainly developers, maintainers and other technical contributors and provides more information on how to work with this repository.</p>"},{"location":"dev_guide/#overview","title":"Overview","text":""},{"location":"dev_guide/#repository-structure","title":"Repository Structure","text":"<p>Here is a non-exhaustive list of the most important files and directories in the repository.</p> <p>General:</p> <ul> <li><code>AUTHORS.md</code>: acknowledges and lists all contributors</li> <li><code>CHANGELOG.md</code>: summarizes the changes for each version of the software for users</li> <li><code>CODE_OF_CONDUCT.md</code>: defines the social standards that must be followed by contributors</li> <li><code>CONTRIBUTING.md</code>: explains  how others can contribute to the project</li> <li><code>README.md</code>: provides an overview and points to other resources</li> </ul> <p>Metadata:</p> <ul> <li><code>CITATION.cff</code>: metadata stating how to cite the project</li> <li><code>codemeta.json</code>: metadata for harvesting by other tools and services</li> <li><code>LICENSE</code>: the (main) license of the project</li> <li><code>LICENSES</code>: copies of all licenses that apply to files in the project</li> <li><code>.reuse/dep5</code>: granular license and copyright information for all files and directories</li> </ul> <p>Development:</p> <ul> <li><code>pyproject.toml</code>: project metadata, dependencies, development tool configurations</li> <li><code>poetry.lock</code>: needed for reproducible installation of the project</li> <li><code>src</code>: actual code provided by the project</li> <li><code>tests</code>: all tests for the code in the project</li> <li><code>mkdocs.yml</code>: configuration of the project website</li> <li><code>docs</code>: most contents used for the project website</li> </ul> <p>Automation and Quality Control:</p> <ul> <li><code>.pre-commit-config.yaml</code>: quality assurance tools used in the project</li> <li><code>.github/workflows</code>: CI scripts for GitHub (QA, documentation and package deployment)</li> <li><code>.github/ISSUE_TEMPLATE</code>: templates for the GitHub issue tracker</li> <li><code>.gitlab-ci.yml</code>: mostly equivalent CI scripts, but for GitLab</li> <li><code>.gitlab/issue_templates</code>: The same issues templates, but for GitLab</li> </ul>"},{"location":"dev_guide/#used-tools","title":"Used Tools","text":"<p>Here is a non-exhaustive list of the most important tools used in the project.</p> <p>Best practices for modern Python development are implemented by using:</p> <ul> <li><code>poetry</code> for dependency management and packaging</li> <li><code>pytest</code> for unit testing</li> <li><code>hypothesis</code> for property-based testing</li> <li><code>pre-commit</code> for orchestrating linters, formatters and other utilities</li> <li><code>black</code> for source-code formatting</li> <li><code>autoflake</code> for automatically removing unused imports</li> <li><code>flake8</code> for general linting (using various linter plugins)</li> <li><code>pydocstyle</code> for checking docstring conventions</li> <li><code>interrogate</code> for computing docstring coverage</li> <li><code>mypy</code> for editor-independent type-checking</li> <li><code>mkdocs</code> for generating the project documentation website</li> <li><code>bandit</code> for checking security issues in the code</li> <li><code>safety</code> for checking security issues in the current dependencies</li> </ul> <p>Metadata best practices for FAIR software are implemented using:</p> <ul> <li><code>cffconvert</code> to check the <code>CITATION.cff</code> (citation metadata)</li> <li><code>codemetapy</code> to generate a <code>codemeta.json</code> (general software metadata)</li> <li><code>reuse</code> to check REUSE-compliance (granular copyright and license metadata)</li> <li><code>licensecheck</code> to scan for possible license incompatibilities in the dependencies</li> </ul>"},{"location":"dev_guide/#basics","title":"Basics","text":"<p>The project</p> <ul> <li>heavily uses <code>pyproject.toml</code>, which is a recommended standard</li> <li>adopts the <code>src</code> layout, to avoid common problems</li> <li>keeps the actual code (<code>src</code>) and test code (<code>tests</code>) separated</li> </ul> <p>The <code>pyproject.toml</code> is the main configuration file for the project. It contains both general information about the software as well as configuration for various tools.</p> <p>In older software, most of this information is often scattered over many little tool-specific configuration files and a <code>setup.py</code>, <code>setup.cfg</code> and/or <code>requirements.txt</code> file.</p> <p>In this project, <code>pyproject.toml</code> is the first place that should be checked when looking for the configuration of some development tool.</p>"},{"location":"dev_guide/#configuration","title":"Configuration","text":"<p>The main tool needed to manage and configure the project is Poetry.</p> <p>Please follow its setup documentation to install it correctly. Poetry should not be installed with <code>pip</code> like other Python tools.</p> <p>Poetry performs many important tasks:</p> <ul> <li>it manages the virtual environment(s) used for the project</li> <li>it manages all the dependencies needed for the code to work</li> <li>it takes care of packaging the code into a <code>pip</code>-installable package</li> </ul> <p>You can find a cheatsheet with the most important commands here and consult its official documentation for detailed information.</p> <p>Note that <code>poetry</code> is only needed for development of the repository. The end-users who just want to install and use this project do not need to set up or know anything about poetry.</p> <p>Note that if you use <code>poetry shell</code> and the project is installed with <code>poetry install</code>, in the following you do not have to prepend <code>poetry run</code> to commands you will see below.</p>"},{"location":"dev_guide/#task-runner","title":"Task Runner","text":"<p>It is a good practice to have a common way for launching different project-related tasks. It removes the need of remembering flags for various tools, and avoids duplication of the same commands in the CI pipelines. If something in a workflow needs to change, it can be changed in just one place, thus reducing the risk of making a mistake.</p> <p>Often projects use a shell script or <code>Makefile</code> for this purpose. This project uses poethepoet, as it integrates nicely with <code>poetry</code>. The tasks are defined in <code>pyproject.toml</code> and can be launched using:</p> <pre><code>poetry run poe TASK_NAME\n</code></pre>"},{"location":"dev_guide/#ci-workflows","title":"CI Workflows","text":"<p>The project contains CI workflows for both GitHub and GitLab.</p> <p>The main CI pipeline runs on each new pushed commit and will</p> <ol> <li>Run all configured code analysis tools,</li> <li>Run code tests with multiple versions of Python,</li> <li>build and deploy the online project documentation website, and</li> <li>if a new version tag was pushed, launch the release workflow</li> </ol>"},{"location":"dev_guide/#quality-control","title":"Quality Control","text":""},{"location":"dev_guide/#static-analysis","title":"Static Analysis","text":"<p>Except for code testing, most tools for quality control are added to the project as <code>pre-commit</code> hooks. The <code>pre-commit</code> tool takes care of installing, updating and running the tools according to the configuration in the <code>.pre-commit-config.yaml</code> file.</p> <p>For every new copy of the repository (e.g. after <code>git clone</code>), <code>pre-commit</code> first must be activated. This is usually done using <code>pre-commit install</code>, which also requires that <code>pre-commit</code> is already available. For more convenience, we simplified the procedure.</p> <p>In this project, you can run:</p> <pre><code>poetry run poe init-dev\n</code></pre> <p>This will make sure that <code>pre-commit</code> is enabled in your repository copy.</p> <p>Once enabled, every time you try to <code>git commit</code> some changed files various tools will run on those (and only those) files.</p> <p>This means that (with some exceptions) <code>pre-commit</code> by default will run only on the changed files that were added to the next commit (i.e., files in the git staging area). These files are usually colored in green when running <code>git status</code>.</p> <ul> <li>Some tools only report the problems they detected</li> <li>Some tools actively modify files (e.g., fix formatting)</li> </ul> <p>In any case, the <code>git commit</code> will fail if a file was modified by a tool, or some problems were reported. In order to complete the commit, you need to</p> <ul> <li>resolve all problems (by fixing them or marking them as false alarm), and</li> <li><code>git add</code> all changed files again (to update the files in the staging area).</li> </ul> <p>After doing that, you can retry to <code>git commit</code> your changes.</p> <p>To avoid having to deal with many issues at once, it is a good habit to run <code>pre-commit</code> by hand from time to time. In this project, this can be done with:</p> <pre><code>poetry run poe lint --all-files\n</code></pre>"},{"location":"dev_guide/#testing","title":"Testing","text":"<p>pytest is used as the main framework for testing.</p> <p>The project uses the <code>pytest-cov</code> plugin to integrate <code>pytest</code> with <code>coverage</code>, which collects and reports test coverage information.</p> <p>In addition to writing regular unit tests with <code>pytest</code>, consider using hypothesis, which integrates nicely with <code>pytest</code> and implements property-based testing - which involves automatic generation of randomized inputs for test cases. This can help to find bugs often found for various edge cases that are easy to overlook in ad-hoc manual tests. Such randomized tests can be a good addition to hand-crafted tests and inputs.</p> <p>To run all tests, either invoke <code>pytest</code> directly, or use the provided task:</p> <pre><code>poetry run poe test\n</code></pre>"},{"location":"dev_guide/#documentation","title":"Documentation","text":"<p>The project uses <code>mkdocs</code> with the popular and excellent <code>mkdocs-material</code> theme to generate the project documentation website, which provides both user and developer documentation.</p> <p><code>mkdocs</code> is configured in the <code>mkdocs.yml</code> file, which we prepared in a way that there is</p> <ul> <li>no need to duplicate sections from files in other places (such as <code>README.md</code>)</li> <li>fully automatic API documentation pages based on Python docstrings in the code</li> <li>a detailed test coverage report is included in the website</li> </ul> <p>The first point is important, because avoiding duplication means avoiding errors whenever text or examples are updated. The second point is convenient, as modules and functions do not need to be added by hand, which is easy to forget. The third point removes the need to use an external service such as CodeCov to store and present code coverage information.</p> <p>As software changes over time and users cannot always keep up with the latest developments, each new version of the software should provide version-specific documentation. To make this both possible as well as convenient, this project uses <code>mike</code> to generate and manage the <code>mkdocs</code> documentation for different versions of the software.</p>"},{"location":"dev_guide/#online-documentation","title":"Online Documentation","text":"<p>To avoid dependence on additional services such as readthedocs, the project website is deployed using GitHub Pages.</p> <p>The provided CI pipeline automatically generates the documentation for the latest development version (i.e., current state of the <code>main</code> branch) as well as every released version (i.e., marked by a version tag <code>vX.Y.Z</code>).</p>"},{"location":"dev_guide/#offline-documentation","title":"Offline Documentation","text":"<p>You can manually generate a local and fully offline copy of the documentation, which can be useful for e.g. previewing the results during active work on the documentation:</p> <pre><code>poetry install --with docs\npoetry run poe docs\n</code></pre> <p>Once the documentation site is built, run <code>mkdocs serve</code> and open <code>https://localhost:8000</code> in your browser to see the local copy of the website.</p>"},{"location":"dev_guide/#releases","title":"Releases","text":"<p>From time to time the project is ready for a new release for users.</p>"},{"location":"dev_guide/#creating-a-new-release","title":"Creating a New Release","text":"<p>Before releasing a new version, push the commit the new release should be based on to the upstream repository, and make sure that:</p> <ul> <li>the CI pipeline completes successfully</li> <li>the version number in <code>pyproject.toml</code> is updated, in particular:</li> <li>it must be larger than the previous released version</li> <li>it should adequately reflect the severity of changes</li> <li>the provided user and developer documentation is up-to-date, including:</li> <li>a new section in the <code>CHANGELOG.md</code> file summarizing changes in the new version</li> <li>possibly revised information about contributors and/or maintainers</li> </ul> <p>If this is the case, proceed with the release by:</p> <ul> <li>creating a new tag that matches the version in the <code>pyproject.toml</code>: <code>git tag vX.Y.Z</code></li> <li>pushing the new tag to the upstream repository: <code>git push origin vX.Y.Z</code></li> </ul> <p>The pushed version tag will trigger a pipeline that will:</p> <ul> <li>build and deploy the documentation website for the specific version</li> <li>publish the package to enabled targets (see below)</li> </ul>"},{"location":"dev_guide/#release-targets","title":"Release Targets","text":"<p>Targets for releases can be enabled or disabled in <code>.github/workflows/ci.yml</code> and configured by adapting the corresponding actions in <code>.github/workflows/releases.yml</code>.</p>"},{"location":"dev_guide/#github-release","title":"Github Release","text":"<p>By default, the release workflow will create a basic Github Release that provides a snapshot of the repository as a download. This requires no additional configuration.</p> <p>See here for information on how the Github release can be customized.</p> <p>Note that this release target is mostly for demonstration purposes. For most Python projects, using PyPI is the recommended primary distribution method.</p>"},{"location":"dev_guide/#pypi-and-compatible-package-indices","title":"PyPI (and compatible package indices)","text":"<p>For releases to PyPI and Test PyPI the project uses the new Trusted Publishers workflow that is both more secure and convenient to use than other authorization methods.</p> <p>Before the project can be released to PyPI or Test PyPI the first time, first a pending publisher must be added in the PyPI account of the main project maintainer, using <code>release.yml</code> as the requested workflow name.</p> <p>Once this is done, set the corresponding option (<code>to_pypi</code> / <code>to_test_pypi</code>) to <code>true</code> in the <code>publish</code> job in <code>ci.yml</code> to enable the corresponding publication target.</p> <p>If the old and less secure token-based authentication method is needed or the package should be published to a different PyPI-compatible package index, please adapt <code>release.yml</code> accordingly).</p>"},{"location":"license/","title":"License","text":"<p>Unless stated otherwise, all code provided by this project (excluding external dependencies) is distributed under the following license:</p> <pre><code>MIT License\n\nCopyright (c) 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre> <p>This project is REUSE compliant. The following detailed license and copyright information in DEP5 format can also be found in the <code>.reuse/dep5</code> file in the project source directory:</p> <pre><code>Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\nUpstream-Name: somesy\nUpstream-Contact: Mustafa Soylu &lt;m.soylu@fz-juelich.de&gt;\nSource: https://github.com/Materials-Data-Science-and-Informatics/somesy\n\nFiles: .gitignore pyproject.toml poetry.lock .pre-commit-config.yaml .pre-commit-hooks.yaml .sourcery.yaml .somesy.toml codemeta.json CITATION.cff README.md RELEASE_NOTES.md CHANGELOG.md CODE_OF_CONDUCT.md AUTHORS.md CONTRIBUTING.md .gitlab-ci.yml .gitlab/* .github/* mkdocs.yml docs/*\nCopyright: 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\nLicense: CC0-1.0\n\nFiles: src/somesy/* tests/*\nCopyright: 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\nLicense: MIT\n</code></pre>"},{"location":"manual/","title":"User Manual","text":"<p>This is the reference manual for <code>somesy</code> providing details about its configuration and behavior.</p> <p>Before you proceed, make sure you have read the introduction and the quick-start guide.</p>"},{"location":"manual/#somesy-metadata-schemas","title":"Somesy Metadata Schemas","text":"<p>Because the same information is represented in different ways and more or less detail in different files, somesy requires to put all project information in a somesy-specific input section is located in a supported input file. Somesy will use this as the single source of truth for the supported project metadata fields and can synchronize this information into different target files.</p> <p>Info</p> <p>The somesy schemas are designed to allow expressing metadata in the most useful and rich form, i.e. the best form that some of the target formats supports.</p> <p>Somesy project metadata consists of two main schemas - one schema for describing people (authors, maintainers, contributors), and a schema describing the project.</p> <p>The somesy metadata fields (especially for people) are mostly based on Citation File Format 1.2, with some custom extensions. Somesy will try staying aligned with future revisions of <code>CITATION.cff</code>, unless for technical or practical reasons a deviation or extension is justified.</p> <p>One useful distinction somesy does in contrast to many target formats is to allow stating all people in one place. If a person is both an author and a maintainer, that person does not need to be listed with all information twice.</p> <p>This is done by adding the <code>author</code> and <code>maintainer</code> flags that can be set for every listed person. Somesy will take care of duplicating the entries where this is needed.</p> <p>Furthermore <code>somesy</code> allows to provide more fine-grained information about the contribution of a person and acknowledge contributors that are neither full authors or maintainers.</p> <p>Note</p> <p>Currently, provided information about contributors that are neither authors nor maintainers, and all the detailed information on the contributions is not used.</p> <p>Nevertheless, we encourage tracking granular contributor and contribution information in order to motivate and acknowledge also minor or invisible contributions to a projects.</p> <p>Once CITATION.cff introduces corresponding mechanisms, <code>somesy</code> will be aligned with the corresponding capabilities. Furthermore, <code>somesy</code> might support the allcontributors tool as a target in the future.</p>"},{"location":"manual/#schemas-overview","title":"Schemas Overview","text":"<p>Here is an overview of the schemas used in somesy.</p> SomesyInputProjectMetadataPersonSomesyConfig <p>The complete somesy input file (<code>somesy.toml</code>) or section (<code>pyproject.toml</code>).   </p> Field Type Required? Default Description project ProjectMetadata yes Project metadata to be used and synchronized. config SomesyConfig no somesy tool configuration (matches CLI flags). <p>Pydantic model for Project Metadata Input.  </p> Field Type Required? Default Description name str yes Project name. description str yes Project description. version str no Project version. license LicenseEnum yes SPDX License string. repository URL no URL of the project source code repository. homepage URL no URL of the project homepage. keywords list[str] no Keywords that describe the project. people list[Person] yes Project authors, maintainers and contributors. <p>Metadata abount a person in the context of a software project.</p> <p>This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Field Type Required? Default Description orcid URL no The person's ORCID url (not required, but highly suggested). email str yes The person's email address. family_names str yes The person's family names. given_names str yes The person's given names. name_particle str no The person's name particle, e.g., a nobiliary particle or a preposition meaning 'of' or 'from' (for example 'von' in 'Alexander von Humboldt'). name_suffix str no The person's name-suffix, e.g. 'Jr.' for Sammy Davis Jr. or 'III' for Frank Edwin Wright III. alias str no The person's alias. affiliation str no The person's affiliation. address str no The person's address. city str no The person's city. country Country no The person's country. fax str no The person's fax number. post_code str no The person's post-code. region str no The person's region. tel str no The person's phone number. author bool no false Indicates whether the person is an author of the project (i.e. for citations). maintainer bool no false Indicates whether the person is a maintainer of the project (i.e. for contact). contribution str no Summary of how the person contributed to the project. contribution_types list[ContributionTypeEnum] no Relevant types of contributions (see https://allcontributors.org/docs/de/emoji-key). contribution_begin date no Beginning date of the contribution. contribution_end date no Ending date of the contribution. <p>Pydantic model for somesy tool configuration.</p> <p>Note that all fields match CLI options, and CLI options will override the values declared in a somesy input file (such as <code>somesy.toml</code>).</p> Field Type Required? Default Description show_info bool no false Show basic information messages on run (-v flag). verbose bool no false Show verbose messages on run (-vv flag). debug bool no false Show debug messages on run (-vvv flag). input_file Path no \"somesy.toml\" Project metadata input file path. no_sync_cff bool no false Do not sync with CFF. cff_file Path no \"CITATION.cff\" CFF file path. no_sync_pyproject bool no false Do not sync with pyproject.toml. pyproject_file Path no \"pyproject.toml\" pyproject.toml file path. sync_package_json bool no false Sync with package.json. package_json_file Path no \"package.json\" package.json file path. no_sync_codemeta bool no false Do not sync with codemeta.json. codemeta_file Path no \"codemeta.json\" codemeta.json file path."},{"location":"manual/#metadata-mapping","title":"Metadata Mapping","text":"<p>From its own schema <code>somesy</code> must convert the information into the target formats. The following tables sketch how fields are mapped to corresponding other fields in some of the currently supported formats.</p> Person MetadataProject Metadata Field Name Poetry Config SetupTools Config CITATION.cff Requirement given-names name+email name given-names required family-names name+email name family-names required email name+email email email required orcid - - orcid optional (many others) - - (same) optional Field Name Poetry Config SetupTools Config CITATION.cff Requirement name name name title required description description description abstract required license license license license required version version version version optional author=true authors authors authors required maintainer=true maintainers maintainers contact optional keywords keywords keywords keywords optional repository repository urls.repository repository_code optional homepage homepage urls.homepage url optional <p>Note that the mapping is often not 1-to-1. For example, CITATION.cff allows rich specification of author contact information and complex names. In contrast, poetry only supports a simple string with a name and email (like in git commits) to list authors and maintainers. Therefore somesy sometimes must do much more than just move or rename fields. This means that giving a clean and complete mapping overview is not feasible. In case of doubt or confusion, please open an issue or consult the <code>somesy</code> code.</p>"},{"location":"manual/#the-somesy-cli-tool","title":"The somesy CLI tool","text":"<p>You can see all supported somesy CLI command options using <code>somesy --help</code>:</p> <pre><code>somesy sync --help\n</code></pre> <pre><code>                                                                                Usage: somesy sync [OPTIONS] COMMAND [ARGS]...                                 \n\n Sync project metadata input with metadata files.                               \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --input-file         -i      FILE  Somesy input file path (default:          \u2502\n\u2502                                    .somesy.toml)                             \u2502\n\u2502                                    [default: None]                           \u2502\n\u2502 --no-sync-cff        -C        Do not sync CITATION.cff file (default:   \u2502\n\u2502                                    False)                                    \u2502\n\u2502 --cff-file           -c      FILE  CITATION.cff file path (default:          \u2502\n\u2502                                    CITATION.cff)                             \u2502\n\u2502                                    [default: None]                           \u2502\n\u2502 --no-sync-pyproject  -P        Do not sync pyproject.toml file (default: \u2502\n\u2502                                    False)                                    \u2502\n\u2502 --pyproject-file     -p      FILE  Existing pyproject.toml file path         \u2502\n\u2502                                    (default: pyproject.toml)                 \u2502\n\u2502                                    [default: None]                           \u2502\n\u2502 --sync-package-json  -J        Do not sync package.json file (default:   \u2502\n\u2502                                    False)                                    \u2502\n\u2502 --package-json-file  -j      FILE  Existing package.json file path (default: \u2502\n\u2502                                    package.json)                             \u2502\n\u2502                                    [default: None]                           \u2502\n\u2502 --no-sync-codemeta   -M        Do not sync codemeta.json file            \u2502\n\u2502 --codemeta-file      -m      FILE  Custom codemeta.json file path            \u2502\n\u2502                                    [default: None]                           \u2502\n\u2502 --help                         Show this message and exit.               \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Everything that can be configured as a CLI flag can also be set in a <code>somesy.toml</code> file in the <code>[config]</code> section. CLI arguments set in an input file override the defaults, while options passed as CLI arguments override the configuration.</p> <p>Without an input file specifically provided, somesy will check if it can find a valid</p> <ul> <li><code>.somesy.toml</code></li> <li><code>somesy.toml</code></li> <li><code>pyproject.toml</code> (in <code>tool.somesy</code> section)</li> </ul> <p>which is located in the current working directory. If you want to provide the somesy input file from a different location, you can pass it with the <code>-i</code> option.</p>"},{"location":"manual/#synchronization","title":"Synchronization","text":"<p>Unless configured otherwise, <code>somesy</code> will create <code>CITATION.cff</code> and <code>codemeta.json</code> files if they do not exist. Other supported files (such as <code>pyproject.toml</code>) are updated if they already exist in your repository.</p> <p>If you do not want that somesy creates/synchronizes these files, you can disable them by CLI options or in your somesy configuration.</p>"},{"location":"manual/#somesy-input-file","title":"Somesy input file","text":"<p>In the quickstart you can find an example somesy input file.</p> <p>All possible metadata fields and configuration options are explained further above.</p>"},{"location":"manual/#metadata-update-logic","title":"Metadata Update Logic","text":"<p>In this section we explain a few details about how <code>somesy</code> updates metadata.</p>"},{"location":"manual/#somesy-inputs-override-target-values","title":"Somesy Inputs Override Target Values","text":"<p>In general, <code>somesy</code> updates fields in target files and formats based on the information stated in the <code>somesy.toml</code>.</p> <p>It will convert the metadata into the form needed for a target, while trying to preserve as much information as possible. Then it carefully updates the file, while keeping all other fields in the target file unchanged.</p> <p>In most cases, <code>somesy</code> will try not to interfere with other values, metadata and configuration you might have in a target file.</p> <p>Info</p> <p>For typically manually-edited files, it will even make sure that the comments stay in place! (currently works for TOML)</p> <p>Tip</p> <p>Only edit target files manually to add or update fields that <code>somesy</code> does not understand or care about!</p> <p>Warning</p> <p>All changes in target files you do to fields <code>somesy</code> does understand will be overwritten the next time you run somesy.</p> <p>Tip</p> <ul> <li>update all project metadata supported by <code>somesy</code> in the <code>somesy.toml</code></li> <li>update other metadata directly in the target files</li> </ul>"},{"location":"manual/#checking-somesy-results","title":"Checking Somesy Results","text":"<p>Note that <code>somesy</code> in general will try doing a good job and hopefully will in most cases, but in certain tricky situations it might not be able to figure out the and needed changes correctly.</p> <p>Danger</p> <p>Always check the files that somesy synchronized look right before committing/pushing the changes!</p> <p>Doing what <code>somesy</code> does both convenient and right is (maybe surprisingly to you) quite difficult, so while somesy should save you quite some tedious work, you should not use it blindly. You have been warned!</p>"},{"location":"manual/#person-identification-heuristics","title":"Person Identification Heuristics","text":"<p>One frequent source of high-level project metadata changes is fluctuation of authors, maintainers and contributors and eventual changes of the respective contact and identification information.</p> <p>Somesy will try its best to keep track of persons involved in your software project, but to avoid possible problems and unexpected behavior, it might be helpful to understand how somesy determines whether two metadata records describe the same real person.</p> <p>When somesy compares two metadata records about a person, it will proceed as follows:</p> <ol> <li>If both records contain an ORCID, then the person is the same if the attached ORCIDs are equal, and different if it is not.</li> <li>Otherwise, if both records have an attached email address, and it is the same email, then they are the same person.</li> <li>Otherwise, the records are considered to be about the same person if they agree on the full name (i.e. given, middle and family name sequence).</li> </ol> <p>Tip</p> <p>State ORCIDs for persons whenever possible (i.e. the person has an ORCID)!</p> <p>Tip</p> <p>If a person does not have an ORCID, suggest that they should create one!</p> <p>Somesy will usually correctly understand cases such as:</p> <ol> <li>An ORCID being added to a person (i.e. if it was not present before)</li> <li>A changed email address (if the name stays the same)</li> <li>A changed name (if the email address stays the same)</li> <li>Any other relevant metadata attached to the person</li> </ol> <p>Nevertheless, you should check the changes somesy does before committing them to your repository, especially after you significantly modified your project metadata.</p> <p>Warning</p> <p>Note that changing the ORCID will not be recognized, because ORCIDs are assumed to be unique per person.</p> <p>If you initially have stated an incorrect ORCID for a person and then change it, somesy will think that this is a new person. Therefore, in such a case you will need to fix the ORCID in all configured somesy targets either before running somesy (so somesy will not create new person entries), or after running somesy (to remove the duplicate entries with the incorrect ORCID).</p>"},{"location":"manual/#codemeta","title":"Codemeta","text":"<p>While <code>somesy</code> is modifying existing files for most supported formats, CodeMeta is implemented differently.</p> <p>In order to avoid redundant work, <code>somesy</code> relies on existing tools to generate <code>codemeta.json</code> files. So when you synchronize the metadata and the codemeta target is enabled, <code>somesy</code> will generate your <code>codemeta.json</code> by:</p> <ul> <li>synchronizing metadata to a <code>pyproject.toml</code> or <code>package.json</code> (if enabled)</li> <li>synchronizing metadata to a <code>CITATION.cff</code> (if enabled)</li> <li>running <code>cffconvert</code> and <code>codemetapy</code> to combine both sources into a final <code>codemeta.json</code></li> </ul> <p>Warning</p> <p>The <code>codemeta.json</code> is overwritten and regenerated from scratch every time you <code>sync</code>, so do not edit it if you have the codemeta target enabled in <code>somesy</code>!</p> <p>As <code>codemeta.json</code> is considered a technical \"backend-format\" derived from other inputs, in most cases you probably do not need or should edit it by hand anyway.</p>"},{"location":"manual/#faq","title":"FAQ","text":""},{"location":"manual/#somesy-introduces-its-own-metadata-format-isnt-this-counter-productive","title":"Somesy introduces it's own metadata format... isn't this counter-productive?","text":"<p>We don't propose to use <code>somesy</code> as a new \"standard\". On the contrary, the whole point of <code>somesy</code> is to help maintaining standard-compliant metadata alongside other representations. To do its job, <code>somesy</code> needs to introduce a canonical format to express the metadata it tries to manage for you, because otherwise building such a tool is practically impossible. Should you after some time decide you do not want to use it anymore, nothing is lost - you keep all your <code>CITATION.cff</code> and <code>codemeta.json</code> and <code>pyproject.toml</code> files and can continue to maintain them however you see fit.</p> <p>The <code>somesy</code>-specific format is just the nice and convenient interface to make everybody's life easier. Furthermore, nobody needs to care whether, under the hood, you use <code>somesy</code> (or anything like it) or not - they can use the corresponding files they already know to get the information they need. So there is no \"risk\" involved in adopting <code>somesy</code>, because it does not try to abolish any other formats or standards or becoming such.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#getting-started","title":"Getting Started","text":""},{"location":"quickstart/#installing-somesy","title":"Installing somesy","text":"<p>Somesy requires Python <code>&gt;=3.8</code>. To get a first impression, you can install the latest stable version of somesy from PyPI using <code>pip</code>:</p> <pre><code>pip install somesy\n</code></pre>"},{"location":"quickstart/#configuring-somesy","title":"Configuring somesy","text":"<p>Yes, somesy is another tool with its own configuration. However, for your project metadata it is hopefully the last file you need, and the only one you have to think about, <code>somesy</code> will take care of the others for you!</p> <p>To get started, create a file named <code>somesy.toml</code> (or <code>.somesy.toml</code>):</p> <pre><code>[project]\nname = \"my-amazing-project\"\nversion = \"0.1.0\"\ndescription = \"Brief description of my amazing software.\"\n\nkeywords = [\"some\", \"descriptive\", \"keywords\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/username/my-amazing-project\"\n\n# This is you, the proud author of your project\n[[project.people]]\ngiven-names = \"Jane\"\nfamily-names = \"Doe\"\nemail = \"j.doe@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0001\"\nauthor = true      # is a full author of the project (i.e. appears in citations)\nmaintainer = true  # currently maintains the project (i.e. is a contact person)\n\n# this person is a acknowledged contributor, but not author or maintainer:\n[[project.people]]\ngiven-names = \"Another\"\nfamily-names = \"Contributor\"\nemail = \"a.contributor@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0002\"\n\n[config]\nverbose = true     # show detailed information about what somesy is doing\n</code></pre> <p>If you happen to work on a Python project and use a <code>pyproject.toml</code>, you can also put this information there and avoid having another separate file.  In that case, simply prepend <code>tool.somesy</code> to the names of all sections (i.e.  <code>[project]</code> becomes <code>[tool.somesy.project]</code>).</p>"},{"location":"quickstart/#using-somesy","title":"Using somesy","text":"<p>Once somesy is installed and configured, somesy can take over and manage your project metadata. Now you can run <code>somesy</code> simply by using</p> <pre><code>somesy sync\n</code></pre> <p>The information in your <code>somesy.toml</code> is used as the primary and authoritative source for project metadata, which is used to update all supported (and enabled) target files. You can find an overview of supported formats further below.</p> <p>By default, <code>somesy</code> will create (if they did not exist) or update <code>CITATION.cff</code> and <code>codemeta.json</code> files in your repository. If you happen to use <code>pyproject.toml</code> (in Python projects) or <code>package.json</code> (in JavaScript projects), somesy would also update the respective information there.</p> <p>You can see call available options with <code>somesy --help</code>, all of these can also be conveniently set in your <code>somesy.toml</code> file.</p>"},{"location":"quickstart/#setting-up-somesy-as-a-pre-commit-hook","title":"Setting up somesy as a pre-commit hook","text":"<p>We highly recommend to use <code>somesy</code> as a pre-commit hook. A pre-commit hook runs on every commit to automatically point out issues or fix them on the spot, so if you do not use pre-commit in your project yet, you should start today! When used this way, <code>somesy</code> can fix most typical issues with your project metadata even before your changes can leave your computer.</p> <p>To add <code>somesy</code> as a pre-commit hook, add it to your <code>.pre-commit-config.yaml</code> file in the root folder of your repository:</p> <pre><code>repos:\n# ... (your other hooks) ...\n- repo: https://github.com/Materials-Data-Science-and-Informatics/somesy\nrev: \"0.1.0\"\nhooks:\n- id: somesy\n</code></pre> <p>Note that <code>pre-commit</code> gives <code>somesy</code> the staged version of files, so when using <code>somesy</code> with pre-commit, keep in mind that</p> <ul> <li>if <code>somesy</code> changed some files, you need to <code>git add</code> them again (and rerun pre-commit)</li> <li>if you explicitly run <code>pre-commit</code>, make sure to <code>git add</code> all changed files (just like before a commit)</li> </ul>"},{"location":"quickstart/#supported-file-formats","title":"Supported File Formats","text":"<p>Here is an overview of all the currently supported files and formats.</p> Input Formats Status Target Formats Status (.)somesy.toml \u2713 pyproject.toml (poetry) \u2713 pyproject.toml \u2713(1.) pyproject.toml (setuptools) \u2713(2.) package.json TBD package.json TBD mkdocs.yml TBD CITATION.cff \u2713 codemeta.json \u2713(3.) <p>Notes:</p> <ol> <li>information must be placed inside a <code>tool.somesy</code> section (as explained above)</li> <li>note that <code>somesy</code> does not support setuptools dynamic fields</li> <li>unlike other targets, <code>somesy</code> will re-create the <code>codemeta.json</code> (i.e. you should not edit it by hand!)</li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>somesy<ul> <li>cff<ul> <li>writer</li> </ul> </li> <li>cli<ul> <li>init</li> <li>sync</li> <li>util</li> </ul> </li> <li>codemeta<ul> <li>exec</li> <li>utils</li> </ul> </li> <li>commands<ul> <li>init_config</li> <li>sync</li> </ul> </li> <li>core<ul> <li>core</li> <li>log</li> <li>models</li> <li>types</li> <li>writer</li> </ul> </li> <li>main</li> <li>package_json<ul> <li>models</li> <li>writer</li> </ul> </li> <li>pyproject<ul> <li>models</li> <li>writer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/somesy/","title":"somesy","text":"<p>somesy package.</p>"},{"location":"reference/somesy/main/","title":"main","text":"<p>Main entry point for the somesy CLI.</p>"},{"location":"reference/somesy/main/#somesy.main.version","title":"version","text":"<pre><code>version(value: bool)\n</code></pre> <p>Show somesy version and exit.</p> Source code in <code>src/somesy/main.py</code> <pre><code>@app.callback()\ndef version(value: bool):\n\"\"\"Show somesy version and exit.\"\"\"\n    if value:\n        typer.echo(f\"somesy version: {__version__}\")\n        raise typer.Exit()\n</code></pre>"},{"location":"reference/somesy/main/#somesy.main.common","title":"common","text":"<pre><code>common(\n    ctx: typer.Context,\n    version: bool = typer.Option(\n        None,\n        \"--version\",\n        help=version.__doc__,\n        callback=version,\n    ),\n    show_info: bool = typer.Option(\n        None, \"--info\", \"-v\", help=\"Enable basic logging.\"\n    ),\n    verbose: bool = typer.Option(\n        None,\n        \"--verbose\",\n        \"-vv\",\n        help=\"Enable verbose logging.\",\n    ),\n    debug: bool = typer.Option(\n        None,\n        \"--debug\",\n        \"-vvv\",\n        help=\"Enable debug logging.\",\n    ),\n)\n</code></pre> <p>General flags and arguments for somesy.</p> Source code in <code>src/somesy/main.py</code> <pre><code>@app.callback()\ndef common(\n    ctx: typer.Context,\n    version: bool = typer.Option(\n        None, \"--version\", help=version.__doc__, callback=version\n    ),\n    show_info: bool = typer.Option(\n        None,\n        \"--info\",\n        \"-v\",\n        help=\"Enable basic logging.\",\n    ),\n    verbose: bool = typer.Option(\n        None,\n        \"--verbose\",\n        \"-vv\",\n        help=\"Enable verbose logging.\",\n    ),\n    debug: bool = typer.Option(\n        None,\n        \"--debug\",\n        \"-vvv\",\n        help=\"Enable debug logging.\",\n    ),\n):\n\"\"\"General flags and arguments for somesy.\"\"\"\n    init_log()\n\n    if sum(map(int, map(bool, [show_info, verbose, debug]))) &gt; 1:\n        typer.echo(\n            \"Only one of --info, --verbose or --debug may be set!\", file=sys.stderr\n        )\n        raise typer.Exit(1)\n\n    if show_info or verbose or debug:\n        # NOTE: only explicitly setting log level if a flag is passed,\n        # in order to distinguish from using the \"default log level\"\n        # (needed to check if the user did override the log level as a CLI flag)\n        set_log_level(\n            SomesyLogLevel.from_flags(info=show_info, verbose=verbose, debug=debug)\n        )\n</code></pre>"},{"location":"reference/somesy/cff/","title":"cff","text":"<p>CFF module.</p>"},{"location":"reference/somesy/cff/#somesy.cff.CFF","title":"CFF","text":"<p>             Bases: <code>ProjectMetadataWriter</code></p> <p>Citation File Format (CFF) parser and saver.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>class CFF(ProjectMetadataWriter):\n\"\"\"Citation File Format (CFF) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = True,\n    ):\n\"\"\"Citation File Format (CFF) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings = {\n            \"name\": [\"title\"],\n            \"description\": [\"abstract\"],\n            \"homepage\": [\"url\"],\n            \"repository\": [\"repository-code\"],\n            \"maintainers\": [\"contact\"],\n        }\n        super().__init__(\n            path, create_if_not_exists=create_if_not_exists, direct_mappings=mappings\n        )\n\n    def _init_new_file(self):\n\"\"\"Initialize new CFF file.\"\"\"\n        self._data = {\n            \"cff-version\": \"1.2.0\",\n            \"message\": \"If you use this software, please cite it using these metadata.\",\n            \"type\": \"software\",\n        }\n        with open(self.path, \"w\") as f:\n            self._yaml.dump(self._data, f)\n\n    def _load(self):\n\"\"\"Load the CFF file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self):\n\"\"\"Validate the CFF file.\"\"\"\n        try:\n            citation = create_citation(self.path, None)\n            citation.validate()\n        except ValueError as e:\n            raise ValueError(f\"CITATION.cff file is not valid!\\n{e}\") from e\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the CFF object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to cff dict for person format.\"\"\"\n        json_str = person.json(\n            exclude={\n                \"contribution\",\n                \"contribution_types\",\n                \"contribution_begin\",\n                \"contribution_end\",\n                \"author\",\n                \"maintainer\",\n            },\n            by_alias=True,  # e.g. family_names -&gt; family-names, etc.\n        )\n        return json.loads(json_str)\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Person:\n\"\"\"Parse CFF Person to a somesy Person.\"\"\"\n        # construct (partial) Person while preserving key order from YAML\n        Person._aliases()\n        ret = Person.make_partial(person_obj)\n        ret.set_key_order(list(person_obj.keys()))\n        return ret\n</code></pre>"},{"location":"reference/somesy/cff/#somesy.cff.writer.CFF.__init__","title":"__init__","text":"<pre><code>__init__(path: Path, create_if_not_exists: bool = True)\n</code></pre> <p>Citation File Format (CFF) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = True,\n):\n\"\"\"Citation File Format (CFF) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings = {\n        \"name\": [\"title\"],\n        \"description\": [\"abstract\"],\n        \"homepage\": [\"url\"],\n        \"repository\": [\"repository-code\"],\n        \"maintainers\": [\"contact\"],\n    }\n    super().__init__(\n        path, create_if_not_exists=create_if_not_exists, direct_mappings=mappings\n    )\n</code></pre>"},{"location":"reference/somesy/cff/#somesy.cff.writer.CFF.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the CFF object to a file.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the CFF object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/cff/writer/","title":"writer","text":"<p>Citation File Format (CFF) parser and saver.</p>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF","title":"CFF","text":"<p>             Bases: <code>ProjectMetadataWriter</code></p> <p>Citation File Format (CFF) parser and saver.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>class CFF(ProjectMetadataWriter):\n\"\"\"Citation File Format (CFF) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = True,\n    ):\n\"\"\"Citation File Format (CFF) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings = {\n            \"name\": [\"title\"],\n            \"description\": [\"abstract\"],\n            \"homepage\": [\"url\"],\n            \"repository\": [\"repository-code\"],\n            \"maintainers\": [\"contact\"],\n        }\n        super().__init__(\n            path, create_if_not_exists=create_if_not_exists, direct_mappings=mappings\n        )\n\n    def _init_new_file(self):\n\"\"\"Initialize new CFF file.\"\"\"\n        self._data = {\n            \"cff-version\": \"1.2.0\",\n            \"message\": \"If you use this software, please cite it using these metadata.\",\n            \"type\": \"software\",\n        }\n        with open(self.path, \"w\") as f:\n            self._yaml.dump(self._data, f)\n\n    def _load(self):\n\"\"\"Load the CFF file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self):\n\"\"\"Validate the CFF file.\"\"\"\n        try:\n            citation = create_citation(self.path, None)\n            citation.validate()\n        except ValueError as e:\n            raise ValueError(f\"CITATION.cff file is not valid!\\n{e}\") from e\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the CFF object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to cff dict for person format.\"\"\"\n        json_str = person.json(\n            exclude={\n                \"contribution\",\n                \"contribution_types\",\n                \"contribution_begin\",\n                \"contribution_end\",\n                \"author\",\n                \"maintainer\",\n            },\n            by_alias=True,  # e.g. family_names -&gt; family-names, etc.\n        )\n        return json.loads(json_str)\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Person:\n\"\"\"Parse CFF Person to a somesy Person.\"\"\"\n        # construct (partial) Person while preserving key order from YAML\n        Person._aliases()\n        ret = Person.make_partial(person_obj)\n        ret.set_key_order(list(person_obj.keys()))\n        return ret\n</code></pre>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF.__init__","title":"__init__","text":"<pre><code>__init__(path: Path, create_if_not_exists: bool = True)\n</code></pre> <p>Citation File Format (CFF) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = True,\n):\n\"\"\"Citation File Format (CFF) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings = {\n        \"name\": [\"title\"],\n        \"description\": [\"abstract\"],\n        \"homepage\": [\"url\"],\n        \"repository\": [\"repository-code\"],\n        \"maintainers\": [\"contact\"],\n    }\n    super().__init__(\n        path, create_if_not_exists=create_if_not_exists, direct_mappings=mappings\n    )\n</code></pre>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the CFF object to a file.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the CFF object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/cli/","title":"cli","text":"<p>CLI commands for somesy.</p>"},{"location":"reference/somesy/cli/init/","title":"init","text":"<p>Set config files for somesy.</p>"},{"location":"reference/somesy/cli/init/#somesy.cli.init.config","title":"config","text":"<pre><code>config()\n</code></pre> <p>Set CLI configs for somesy.</p> Source code in <code>src/somesy/cli/init.py</code> <pre><code>@app.command()\n@wrap_exceptions\ndef config():\n\"\"\"Set CLI configs for somesy.\"\"\"\n    # check if input file exists, if not, try to find it from default list\n    input_file_default = discover_input()\n\n    # prompt for inputs\n    input_file = typer.prompt(\"Input file path\", default=input_file_default)\n    input_file = Path(input_file)\n    options = {\n        \"input_file\": input_file,\n        \"no_sync_cff\": not typer.confirm(\n            \"Do you want to sync to a CFF file?\", default=True\n        ),\n    }\n    cff_file = typer.prompt(\"CFF file path\", default=\"CITATION.cff\")\n    if cff_file is not None or cff_file != \"\":\n        options[\"cff_file\"] = cff_file\n\n    options[\"no_sync_pyproject\"] = not typer.confirm(\n        \"Do you want to sync to a pyproject.toml file?\", default=True\n    )\n\n    pyproject_file = typer.prompt(\"pyproject.toml file path\", default=\"pyproject.toml\")\n    if pyproject_file is not None or pyproject_file != \"\":\n        options[\"pyproject_file\"] = pyproject_file\n\n    options[\"sync_package_json\"] = typer.confirm(\n        \"Do you want to sync to a package.json file?\", default=False\n    )\n    package_json_file = typer.prompt(\"package.json file path\", default=\"package.json\")\n    if package_json_file is not None or package_json_file != \"\":\n        options[\"package_json_file\"] = package_json_file\n\n    options[\"no_sync_codemeta\"] = not typer.confirm(\n        \"Do you want to sync to a codemeta.json file?\", default=True\n    )\n    codemeta_file = typer.prompt(\"codemeta.json file path\", default=\"codemeta.json\")\n    if codemeta_file is not None or codemeta_file != \"\":\n        options[\"codemeta_file\"] = codemeta_file\n\n    options[\"show_info\"] = typer.confirm(\n        \"Do you want to show info about the sync process?\"\n    )\n    options[\"verbose\"] = typer.confirm(\"Do you want to show verbose logs?\")\n    options[\"debug\"] = typer.confirm(\"Do you want to show debug logs?\")\n\n    set_log_level(\n        SomesyLogLevel.from_flags(\n            debug=options[\"debug\"],\n            verbose=options[\"verbose\"],\n            info=options[\"show_info\"],\n        )\n    )\n\n    logger.debug(f\"CLI options entered: {options}\")\n\n    init_config(input_file, options)\n    logger.info(\n        f\"[bold green]Input file is updated/created at {input_file}[/bold green]\"\n    )\n</code></pre>"},{"location":"reference/somesy/cli/sync/","title":"sync","text":"<p>Sync command for somesy.</p>"},{"location":"reference/somesy/cli/sync/#somesy.cli.sync.sync","title":"sync","text":"<pre><code>sync(\n    input_file: Path = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Somesy input file path (default: .somesy.toml)\",\n    ),\n    no_sync_cff: bool = typer.Option(\n        None,\n        \"--no-sync-cff\",\n        \"-C\",\n        help=\"Do not sync CITATION.cff file (default: False)\",\n    ),\n    cff_file: Path = typer.Option(\n        None,\n        \"--cff-file\",\n        \"-c\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"CITATION.cff file path (default: CITATION.cff)\",\n    ),\n    no_sync_pyproject: bool = typer.Option(\n        None,\n        \"--no-sync-pyproject\",\n        \"-P\",\n        help=\"Do not sync pyproject.toml file (default: False)\",\n    ),\n    pyproject_file: Path = typer.Option(\n        None,\n        \"--pyproject-file\",\n        \"-p\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Existing pyproject.toml file path (default: pyproject.toml)\",\n    ),\n    sync_package_json: bool = typer.Option(\n        None,\n        \"--sync-package-json\",\n        \"-J\",\n        help=\"Do not sync package.json file (default: False)\",\n    ),\n    package_json_file: Path = typer.Option(\n        None,\n        \"--package-json-file\",\n        \"-j\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Existing package.json file path (default: package.json)\",\n    ),\n    no_sync_codemeta: bool = typer.Option(\n        None,\n        \"--no-sync-codemeta\",\n        \"-M\",\n        help=\"Do not sync codemeta.json file\",\n    ),\n    codemeta_file: Path = typer.Option(\n        None,\n        \"--codemeta-file\",\n        \"-m\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Custom codemeta.json file path\",\n    ),\n)\n</code></pre> <p>Sync project metadata input with metadata files.</p> Source code in <code>src/somesy/cli/sync.py</code> <pre><code>@app.callback(invoke_without_command=True)\n@wrap_exceptions\ndef sync(\n    input_file: Path = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Somesy input file path (default: .somesy.toml)\",\n    ),\n    no_sync_cff: bool = typer.Option(\n        None,\n        \"--no-sync-cff\",\n        \"-C\",\n        help=\"Do not sync CITATION.cff file (default: False)\",\n    ),\n    cff_file: Path = typer.Option(\n        None,\n        \"--cff-file\",\n        \"-c\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"CITATION.cff file path (default: CITATION.cff)\",\n    ),\n    no_sync_pyproject: bool = typer.Option(\n        None,\n        \"--no-sync-pyproject\",\n        \"-P\",\n        help=\"Do not sync pyproject.toml file (default: False)\",\n    ),\n    pyproject_file: Path = typer.Option(\n        None,\n        \"--pyproject-file\",\n        \"-p\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Existing pyproject.toml file path (default: pyproject.toml)\",\n    ),\n    sync_package_json: bool = typer.Option(\n        None,\n        \"--sync-package-json\",\n        \"-J\",\n        help=\"Do not sync package.json file (default: False)\",\n    ),\n    package_json_file: Path = typer.Option(\n        None,\n        \"--package-json-file\",\n        \"-j\",\n        exists=True,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Existing package.json file path (default: package.json)\",\n    ),\n    no_sync_codemeta: bool = typer.Option(\n        None,\n        \"--no-sync-codemeta\",\n        \"-M\",\n        help=\"Do not sync codemeta.json file\",\n    ),\n    codemeta_file: Path = typer.Option(\n        None,\n        \"--codemeta-file\",\n        \"-m\",\n        exists=False,\n        file_okay=True,\n        dir_okay=False,\n        writable=True,\n        readable=True,\n        resolve_path=True,\n        help=\"Custom codemeta.json file path\",\n    ),\n):\n\"\"\"Sync project metadata input with metadata files.\"\"\"\n    # ---------------\n    # config from CLI (merged with possibly set CLI flags for logging)\n    passed_cli_args = {\n        k: v\n        for k, v in dict(\n            input_file=discover_input(input_file),\n            no_sync_cff=no_sync_cff,\n            cff_file=cff_file,\n            no_sync_pyproject=no_sync_pyproject,\n            pyproject_file=pyproject_file,\n            sync_package_json=sync_package_json,\n            package_json_file=package_json_file,\n            no_sync_codemeta=no_sync_codemeta,\n            codemeta_file=codemeta_file,\n        ).items()\n        if v is not None\n    }\n    somesy_conf = SomesyConfig(**passed_cli_args)\n\n    # cli_log_level is None if the user did not pass a log level (-&gt; \"default\")\n    cli_log_level: Optional[SomesyLogLevel] = get_log_level()\n\n    if cli_log_level is not None:\n        # update log level flags if cli log level was set\n        somesy_conf.update_log_level(cli_log_level)\n\n    somesy_input: SomesyInput = somesy_conf.get_input()\n\n    if cli_log_level is None:\n        # no cli log level -&gt; set it according to the loaded configuration\n        set_log_level(somesy_input.config.log_level())\n\n    logger.debug(\n        f\"Combined config (Defaults + File + CLI):\\n{pretty_repr(somesy_input.config)}\"\n    )\n    # --------\n    run_sync(somesy_input)\n</code></pre>"},{"location":"reference/somesy/cli/sync/#somesy.cli.sync.run_sync","title":"run_sync","text":"<pre><code>run_sync(somesy_input: SomesyInput)\n</code></pre> <p>Write log messages and run synchronization based on passed config.</p> Source code in <code>src/somesy/cli/sync.py</code> <pre><code>def run_sync(somesy_input: SomesyInput):\n\"\"\"Write log messages and run synchronization based on passed config.\"\"\"\n    conf = somesy_input.config\n    logger.info(\"[bold green]Synchronizing project metadata...[/bold green]\")\n    logger.info(\"Files to sync:\")\n    if not conf.no_sync_pyproject:\n        logger.info(\n            f\"  - [italic]pyproject.toml[/italic]:\\t[grey]{conf.pyproject_file}[/grey]\"\n        )\n    if conf.sync_package_json:\n        logger.info(\n            f\"  - [italic]package.json[/italic]:\\t[grey]{conf.package_json_file}[/grey]\"\n        )\n    if not conf.no_sync_cff:\n        logger.info(f\"  - [italic]CITATION.cff[/italic]:\\t[grey]{conf.cff_file}[/grey]\")\n    if not conf.no_sync_codemeta:\n        logger.info(\n            f\"  - [italic]codemeta.json[/italic]:\\t[grey]{conf.codemeta_file}[/grey]\\n\"\n        )\n    # ----\n    sync_command(somesy_input)\n    # ----\n    logger.info(\"[bold green]Metadata synchronization completed.[/bold green]\")\n</code></pre>"},{"location":"reference/somesy/cli/util/","title":"util","text":"<p>Utility functions for CLI commands.</p>"},{"location":"reference/somesy/cli/util/#somesy.cli.util.wrap_exceptions","title":"wrap_exceptions","text":"<pre><code>wrap_exceptions(wrapped, instance, args, kwargs)\n</code></pre> <p>Format and log exceptions for cli commands.</p> Source code in <code>src/somesy/cli/util.py</code> <pre><code>@wrapt.decorator\ndef wrap_exceptions(wrapped, instance, args, kwargs):\n\"\"\"Format and log exceptions for cli commands.\"\"\"\n    try:\n        return wrapped(*args, **kwargs)\n\n    except Exception as e:\n        logger.error(f\"[bold red]Error: {e}[/bold red]\")\n        logger.debug(f\"[red]{traceback.format_exc()}[/red]\")\n        raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"reference/somesy/codemeta/","title":"codemeta","text":"<p>Integration with codemetapy (to re-generate codemeta as part of somesy sync).</p>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.collect_cm_sources","title":"collect_cm_sources","text":"<pre><code>collect_cm_sources(conf: SomesyConfig)\n</code></pre> <p>Assemble list of inputs for codemetapy based on somesy config.</p> <p>Returns files that are supported by both somesy and codemetapy and are enabled for somesy.</p> Source code in <code>src/somesy/codemeta/__init__.py</code> <pre><code>def collect_cm_sources(conf: SomesyConfig):\n\"\"\"Assemble list of inputs for codemetapy based on somesy config.\n\n    Returns files that are supported by both somesy and codemetapy and are enabled for somesy.\n    \"\"\"\n    cm_sources = []\n    if (\n        not conf.no_sync_pyproject\n        and conf.pyproject_file is not None\n        and conf.pyproject_file.is_file()\n    ):\n        cm_sources.append(conf.pyproject_file)\n    # NOTE: we don't add CFF directly, because it must be handled separately\n    # NOTE: add other suitable somesy targets / codemeta sources (except CFF and codemeta) here\n    if (\n        conf.sync_package_json\n        and conf.package_json_file is not None\n        and conf.package_json_file.is_file()\n    ):\n        cm_sources.append(conf.package_json_file)\n    return cm_sources\n</code></pre>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.update_codemeta","title":"update_codemeta","text":"<pre><code>update_codemeta(conf: SomesyConfig) -&gt; bool\n</code></pre> <p>Generate or update codemeta file based on sources that somesy supports.</p> <p>Returns True if file has been written, False if it was up to date.</p> Source code in <code>src/somesy/codemeta/__init__.py</code> <pre><code>def update_codemeta(conf: SomesyConfig) -&gt; bool:\n\"\"\"Generate or update codemeta file based on sources that somesy supports.\n\n    Returns True if file has been written, False if it was up to date.\n    \"\"\"\n    cm_sources = collect_cm_sources(conf)\n\n    # if cff file is given, convert it to codemeta tempfile and pass as extra input\n    temp_cff_cm = contextlib.nullcontext(None)\n    if not conf.no_sync_cff and conf.cff_file is not None:\n        temp_cff_cm = cff_codemeta_tempfile(conf.cff_file)\n        cm_sources.append(Path(temp_cff_cm.name))\n\n    # run codemetapy\n    with temp_cff_cm:\n        cm_harvest = gen_codemeta(cm_sources)\n\n    # check output and write file if needed\n    return update_codemeta_file(conf.codemeta_file, cm_harvest)\n</code></pre>"},{"location":"reference/somesy/codemeta/exec/","title":"exec","text":"<p>Wrappers around codemetapy and cffconvert Python APIs.</p>"},{"location":"reference/somesy/codemeta/exec/#somesy.codemeta.exec.cff_to_codemeta","title":"cff_to_codemeta","text":"<pre><code>cff_to_codemeta(cff_file: Path) -&gt; Dict\n</code></pre> <p>Get codemeta LD dict from CITATION.cff via cffconvert.</p> Source code in <code>src/somesy/codemeta/exec.py</code> <pre><code>def cff_to_codemeta(cff_file: Path) -&gt; Dict:\n\"\"\"Get codemeta LD dict from CITATION.cff via cffconvert.\"\"\"\n    return json.loads(create_citation(cff_file, None).as_codemeta())\n</code></pre>"},{"location":"reference/somesy/codemeta/exec/#somesy.codemeta.exec.gen_codemeta","title":"gen_codemeta","text":"<pre><code>gen_codemeta(\n    sources: List[str], *, with_entrypoints: bool = True\n) -&gt; Dict\n</code></pre> <p>Harvest codemeta LD dict via codemetapy.</p> Source code in <code>src/somesy/codemeta/exec.py</code> <pre><code>def gen_codemeta(sources: List[str], *, with_entrypoints: bool = True) -&gt; Dict:\n\"\"\"Harvest codemeta LD dict via codemetapy.\"\"\"\n    log.debug(f\"Running codemetapy with sources {sources}\")\n    with redirect_stderr(StringIO()) as cm_log:\n        g, res, args, _ = build(\n            inputsources=list(map(str, sources)),\n            output=\"json\",\n            with_entrypoints=with_entrypoints,\n        )\n    # add captured codemetapy log into our log\n    log.debug(f\"codemetapy log:\\n----\\n{cm_log.getvalue()}\\n----\")\n\n    return serialize_to_jsonld(g, res, args)\n</code></pre>"},{"location":"reference/somesy/codemeta/utils/","title":"utils","text":"<p>Helpers to work around issue with non-deterministic serialization.</p>"},{"location":"reference/somesy/codemeta/utils/#somesy.codemeta.utils.serialize_codemeta","title":"serialize_codemeta","text":"<pre><code>serialize_codemeta(cm: Dict) -&gt; str\n</code></pre> <p>Convert JSON Dict to str (using settings like codemetapy).</p> Source code in <code>src/somesy/codemeta/utils.py</code> <pre><code>def serialize_codemeta(cm: Dict) -&gt; str:\n\"\"\"Convert JSON Dict to str (using settings like codemetapy).\"\"\"\n    # using settings like in codemetapy\n    return json.dumps(cm, indent=4, ensure_ascii=False, sort_keys=True)\n</code></pre>"},{"location":"reference/somesy/codemeta/utils/#somesy.codemeta.utils.update_codemeta_file","title":"update_codemeta_file","text":"<pre><code>update_codemeta_file(cm_file: Path, cm_dict: Dict) -&gt; bool\n</code></pre> <p>Update codemeta file with graph in dict if it changed.</p> <p>Returns True if the file update happened.</p> Source code in <code>src/somesy/codemeta/utils.py</code> <pre><code>def update_codemeta_file(cm_file: Path, cm_dict: Dict) -&gt; bool:\n\"\"\"Update codemeta file with graph in dict if it changed.\n\n    Returns True if the file update happened.\n    \"\"\"\n    old = _graph_from_cm_file(cm_file) or rdflib.Graph()\n    new = _graph_from_cm_dict(cm_dict)\n\n    if not rdflib.compare.isomorphic(old, new):\n        with open(cm_file, \"w\") as f:\n            f.write(serialize_codemeta(cm_dict))\n        return True\n    return False\n</code></pre>"},{"location":"reference/somesy/codemeta/utils/#somesy.codemeta.utils.cff_codemeta_tempfile","title":"cff_codemeta_tempfile","text":"<pre><code>cff_codemeta_tempfile(cff_file: Path)\n</code></pre> <p>Returns named temporary file with codemeta export of citation file.</p> Source code in <code>src/somesy/codemeta/utils.py</code> <pre><code>def cff_codemeta_tempfile(cff_file: Path):\n\"\"\"Returns named temporary file with codemeta export of citation file.\"\"\"\n    cm_cff = cff_to_codemeta(cff_file)\n    temp_cff_cm = NamedTemporaryFile(prefix=\"cff_cm_\", suffix=\".json\")\n    temp_cff_cm.write(json.dumps(cm_cff).encode(\"utf-8\"))\n    temp_cff_cm.flush()  # needed, or it won't be readable yet\n    return temp_cff_cm\n</code></pre>"},{"location":"reference/somesy/commands/","title":"commands","text":"<p>Commands for somesy.</p>"},{"location":"reference/somesy/commands/init_config/","title":"init_config","text":"<p>CLI command to initialize somesy configuration file.</p>"},{"location":"reference/somesy/commands/init_config/#somesy.commands.init_config.init_config","title":"init_config","text":"<pre><code>init_config(input_path: Path, options: dict) -&gt; None\n</code></pre> <p>Initialize somesy configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Path</code> <p>Path to somesy file (will be created/overwritten).</p> required <code>options</code> <code>dict</code> <p>CLI options.</p> required Source code in <code>src/somesy/commands/init_config.py</code> <pre><code>def init_config(input_path: Path, options: dict) -&gt; None:\n\"\"\"Initialize somesy configuration file.\n\n    Args:\n        input_path (Path): Path to somesy file (will be created/overwritten).\n        options (dict): CLI options.\n    \"\"\"\n    logger.info(f\"Updating input file ({input_path}) with CLI configurations...\")\n\n    content = get_input_content(input_path, no_unwrap=True)\n\n    is_somesy = SomesyInput.is_somesy_file_path(input_path)\n    input_file_type = \"somesy\" if is_somesy else \"pyproject\"\n    msg = f\"Found input file with {input_file_type} format.\"\n    logger.verbose(msg)\n\n    logger.debug(f\"Input file content: {options}\")\n\n    if \"input_file\" in options:\n        del options[\"input_file\"]\n    if is_somesy:\n        content[\"config\"] = options\n    else:\n        if \"tool\" not in content:\n            content[\"tool\"] = {}\n        if \"somesy\" not in content[\"tool\"]:\n            content[\"tool\"][\"somesy\"] = {}\n        content[\"tool\"][\"somesy\"][\"config\"] = options\n\n    with open(input_path, \"w\") as f:\n        tomlkit.dump(content, f)\n\n    logger.info(f\"Input file ({input_path}) updated.\")\n    logger.debug(f\"Input file content: {content}\")\n</code></pre>"},{"location":"reference/somesy/commands/sync/","title":"sync","text":"<p>Sync selected metadata files with given input file.</p>"},{"location":"reference/somesy/commands/sync/#somesy.commands.sync.sync","title":"sync","text":"<pre><code>sync(somesy_input: SomesyInput)\n</code></pre> <p>Sync selected metadata files with given input file.</p> Source code in <code>src/somesy/commands/sync.py</code> <pre><code>def sync(somesy_input: SomesyInput):\n\"\"\"Sync selected metadata files with given input file.\"\"\"\n    conf, metadata = somesy_input.config, somesy_input.project\n\n    logger.debug(\n        f\"Project metadata: {pretty_repr(metadata.dict(exclude_defaults=True))}\"\n    )\n\n    if not conf.no_sync_pyproject:\n        _sync_python(metadata, conf.pyproject_file)\n\n    if conf.sync_package_json:\n        _sync_package_json(metadata, conf.package_json_file)\n\n    if not conf.no_sync_cff:\n        _sync_cff(metadata, conf.cff_file)\n\n    # NOTE: codemeta should always be last, it uses (some of) the other targets\n    if not conf.no_sync_codemeta:\n        _sync_codemeta(conf)\n</code></pre>"},{"location":"reference/somesy/core/","title":"core","text":"<p>Somesy core module.</p>"},{"location":"reference/somesy/core/core/","title":"core","text":"<p>Core somesy functions.</p>"},{"location":"reference/somesy/core/core/#somesy.core.core.INPUT_FILES_ORDERED","title":"INPUT_FILES_ORDERED  <code>module-attribute</code>","text":"<pre><code>INPUT_FILES_ORDERED = [\n    \".somesy.toml\",\n    \"somesy.toml\",\n    \"pyproject.toml\",\n    \"package.json\",\n]\n</code></pre> <p>Input files ordered by priority for discovery.</p>"},{"location":"reference/somesy/core/core/#somesy.core.core.discover_input","title":"discover_input","text":"<pre><code>discover_input(input_file: Optional[Path] = None) -&gt; Path\n</code></pre> <p>Check given input file path. If not given, find somesy configuration file path from default list.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>Optional[Path]</code> <p>somesy configuration file path. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised if no somesy input file found from cli input or the defaults.</p> <p>Returns:</p> Type Description <code>Path</code> <p>somesy configuration file path.</p> Source code in <code>src/somesy/core/core.py</code> <pre><code>def discover_input(input_file: Optional[Path] = None) -&gt; Path:\n\"\"\"Check given input file path. If not given, find somesy configuration file path from default list.\n\n    Args:\n        input_file: somesy configuration file path. Defaults to None.\n\n    Raises:\n        FileNotFoundError: Raised if no somesy input file found from cli input or the defaults.\n\n    Returns:\n        somesy configuration file path.\n    \"\"\"\n    if input_file:\n        if input_file.is_file():\n            logger.info(f\"Using provided file '{input_file}' as somesy input file.\")\n            return input_file\n        else:\n            msg = f\"Passed file '{input_file}' does not exist. Searching for usable somesy input file...\"\n            logger.verbose(msg)\n\n    for filename in INPUT_FILES_ORDERED:\n        input_file = Path(filename)\n        if input_file.is_file():\n            try:\n                get_input_content(input_file)\n            except RuntimeError:\n                continue\n\n            msg = f\"Using '{input_file}' as somesy input file.\"\n            logger.verbose(msg)\n            return input_file\n\n    raise FileNotFoundError(\"No somesy input file found.\")\n</code></pre>"},{"location":"reference/somesy/core/core/#somesy.core.core.get_input_content","title":"get_input_content","text":"<pre><code>get_input_content(\n    path: Path, *, no_unwrap: bool = False\n) -&gt; Dict[str, Any]\n</code></pre> <p>Read contents of a supported somesy input file.</p> <p>Given a path to a TOML file, this function reads the file and returns its content as a TOMLDocument object. The function checks if the file is a valid somesy input file by checking its name and content.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path to the input file</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>the content of the input file as a TOMLDocument object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the input file is not a valid somesy input file or if the file is not a TOML file.</p> <code>RuntimeError</code> <p>if the input file does not contain a somesy input section at expected key</p> Source code in <code>src/somesy/core/core.py</code> <pre><code>def get_input_content(path: Path, *, no_unwrap: bool = False) -&gt; Dict[str, Any]:\n\"\"\"Read contents of a supported somesy input file.\n\n    Given a path to a TOML file, this function reads the file and returns its content as a TOMLDocument object.\n    The function checks if the file is a valid somesy input file by checking its name and content.\n\n    Args:\n        path (Path): path to the input file\n\n    Returns:\n        the content of the input file as a TOMLDocument object\n\n    Raises:\n        ValueError: if the input file is not a valid somesy input file or if the file is not a TOML file.\n        RuntimeError: if the input file does not contain a somesy input section at expected key\n    \"\"\"\n    logger.debug(f\"Path {path}\")\n    # somesy.toml / .somesy.toml\n    if path.suffix == \".toml\" and \"somesy\" in path.name:\n        with open(path, \"r\") as f:\n            ret = tomlkit.load(f)\n            return ret if no_unwrap else ret.unwrap()\n\n    # pyproject.toml\n    if path.suffix == \".toml\" and \"pyproject\" in path.name:\n        with open(path, \"r\") as f:\n            input_content = tomlkit.load(f)\n            if \"tool\" in input_content and \"somesy\" in input_content[\"tool\"]:\n                return input_content[\"tool\"][\"somesy\"].unwrap()\n            else:\n                raise RuntimeError(\n                    \"No tool.somesy section found in pyproject.toml file!\"\n                )\n\n    if path.suffix == \".json\" and \"package\" in path.name:\n        with open(path, \"r\") as f:\n            input_content = json.load(f)\n            if \"somesy\" in input_content:\n                return input_content[\"somesy\"]\n            else:\n                raise RuntimeError(\"No somesy section found in package.json file!\")\n\n    # no match:\n    raise ValueError(\"Unsupported input file.\")\n</code></pre>"},{"location":"reference/somesy/core/log/","title":"log","text":"<p>Somesy log configuration.</p>"},{"location":"reference/somesy/core/log/#somesy.core.log.VERBOSE","title":"VERBOSE  <code>module-attribute</code>","text":"<pre><code>VERBOSE: int = 15\n</code></pre> <p>Custom logging level between INFO and DEBUG.</p>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel","title":"SomesyLogLevel","text":"<p>             Bases: <code>Enum</code></p> <p>Somesy-specific log levels.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>class SomesyLogLevel(Enum):\n\"\"\"Somesy-specific log levels.\"\"\"\n\n    SILENT = auto()\n    INFO = auto()\n    VERBOSE = auto()\n    DEBUG = auto()\n\n    @staticmethod\n    def from_flags(\n        *,\n        info: Optional[bool] = None,\n        verbose: Optional[bool] = None,\n        debug: Optional[bool] = None\n    ):\n\"\"\"Convert CLI/config flags into a log level.\"\"\"\n        if debug:\n            return SomesyLogLevel.DEBUG\n        elif verbose:\n            return SomesyLogLevel.VERBOSE\n        elif info:\n            return SomesyLogLevel.INFO\n        return SomesyLogLevel.SILENT\n\n    @staticmethod\n    def to_logging(lv):\n\"\"\"Convert a somesy log level into a logging log level.\"\"\"\n        if lv == SomesyLogLevel.SILENT:\n            return logging.WARNING\n        if lv == SomesyLogLevel.INFO:\n            return logging.INFO\n        if lv == SomesyLogLevel.VERBOSE:\n            return VERBOSE\n        if lv == SomesyLogLevel.DEBUG:\n            return logging.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel.from_flags","title":"from_flags  <code>staticmethod</code>","text":"<pre><code>from_flags(\n    *,\n    info: Optional[bool] = None,\n    verbose: Optional[bool] = None,\n    debug: Optional[bool] = None\n)\n</code></pre> <p>Convert CLI/config flags into a log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>@staticmethod\ndef from_flags(\n    *,\n    info: Optional[bool] = None,\n    verbose: Optional[bool] = None,\n    debug: Optional[bool] = None\n):\n\"\"\"Convert CLI/config flags into a log level.\"\"\"\n    if debug:\n        return SomesyLogLevel.DEBUG\n    elif verbose:\n        return SomesyLogLevel.VERBOSE\n    elif info:\n        return SomesyLogLevel.INFO\n    return SomesyLogLevel.SILENT\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel.to_logging","title":"to_logging  <code>staticmethod</code>","text":"<pre><code>to_logging(lv)\n</code></pre> <p>Convert a somesy log level into a logging log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>@staticmethod\ndef to_logging(lv):\n\"\"\"Convert a somesy log level into a logging log level.\"\"\"\n    if lv == SomesyLogLevel.SILENT:\n        return logging.WARNING\n    if lv == SomesyLogLevel.INFO:\n        return logging.INFO\n    if lv == SomesyLogLevel.VERBOSE:\n        return VERBOSE\n    if lv == SomesyLogLevel.DEBUG:\n        return logging.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.get_log_level","title":"get_log_level","text":"<pre><code>get_log_level() -&gt; Optional[SomesyLogLevel]\n</code></pre> <p>Return current user-defined log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def get_log_level() -&gt; Optional[SomesyLogLevel]:\n\"\"\"Return current user-defined log level.\"\"\"\n    return _log_level\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.set_log_level","title":"set_log_level","text":"<pre><code>set_log_level(log_level: SomesyLogLevel) -&gt; None\n</code></pre> <p>Set the current log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def set_log_level(log_level: SomesyLogLevel) -&gt; None:\n\"\"\"Set the current log level.\"\"\"\n    global _log_level\n    # update current somesy log level\n    _log_level = log_level\n    # (re-)init logging (rich formatter config depends on passed log level)\n    init_log()\n    # set the current logging log level\n    logger.setLevel(SomesyLogLevel.to_logging(log_level))\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.init_log","title":"init_log","text":"<pre><code>init_log()\n</code></pre> <p>Initialize logging (add VERBOSE log level and Rich formatter).</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def init_log():\n\"\"\"Initialize logging (add VERBOSE log level and Rich formatter).\"\"\"\n    _add_verbose_level()\n    _init_rich_handler(get_log_level())\n</code></pre>"},{"location":"reference/somesy/core/models/","title":"models","text":"<p>Core models for the somesy package.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel","title":"SomesyBaseModel","text":"<p>             Bases: <code>BaseModel</code></p> <p>Customized pydantic BaseModel for somesy.</p> <p>Apart from some general tweaks for better defaults, adds a private <code>_key_order</code> field, which is used to track the preferred order for serialization (usually coming from some existing input).</p> <p>It can be set on an instance using the set_key_order method, and is preserved by <code>copy()</code>.</p> <p>NOTE: The custom order is intended for leaf models (no further nested models), custom order will not work correctly across nesting layers.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyBaseModel(BaseModel):\n\"\"\"Customized pydantic BaseModel for somesy.\n\n    Apart from some general tweaks for better defaults,\n    adds a private `_key_order` field, which is used to track the\n    preferred order for serialization (usually coming from some existing input).\n\n    It can be set on an instance using the set_key_order method,\n    and is preserved by `copy()`.\n\n    NOTE: The custom order is intended for leaf models (no further nested models),\n    custom order will not work correctly across nesting layers.\n    \"\"\"\n\n    class Config:\n\"\"\"Pydantic config.\"\"\"\n\n        extra = Extra.forbid\n        allow_population_by_field_name = True\n        underscore_attrs_are_private = True\n        anystr_strip_whitespace = True\n        min_anystr_length = 1\n\n    # ----\n    # Key order magic\n\n    _key_order: List[str] = PrivateAttr([])\n\"\"\"List of field names (NOT aliases!) in the order they should be written in.\"\"\"\n\n    @classmethod\n    @functools.lru_cache()  # compute once per class\n    def _aliases(cls) -&gt; Dict[str, str]:\n\"\"\"Map back from alias field names to internal field names.\"\"\"\n        return {v.alias: k for k, v in cls.__fields__.items()}\n\n    @classmethod\n    def make_partial(cls, dct):\n\"\"\"Construct unvalidated partial model from dict.\n\n        Handles aliases correctly, unlike `construct`.\n        \"\"\"\n        un_alias = cls._aliases()\n        return cls.construct(**{un_alias.get(k) or k: v for k, v in dct.items()})\n\n    def set_key_order(self, keys: List[str]):\n\"\"\"Setter for custom key order used in serialization.\"\"\"\n        un_alias = self._aliases()\n        # make sure we use the _actual_ field names\n        self._key_order = list(map(lambda k: un_alias.get(k) or k, keys))\n\n    def copy(self, *args, **kwargs):\n\"\"\"Patched copy method (to preserve custom key order).\"\"\"\n        ret = super().copy(*args, **kwargs)\n        ret.set_key_order(list(self._key_order))\n        return ret\n\n    @staticmethod\n    def _patch_kwargs_defaults(kwargs):\n        for key in [\"exclude_defaults\", \"exclude_none\", \"exclude_unset\"]:\n            if not kwargs.get(key):\n                kwargs[key] = True\n\n    def _reorder_dict(self, dct):\n\"\"\"Return dict with patched key order (according to `self._key_order`).\n\n        Keys in `dct` not listed in `self._key_order` come after all others.\n\n        Used to patch up `dict()` and `json()`.\n        \"\"\"\n        key_order = self._key_order or []\n        existing = set(key_order).intersection(set(dct.keys()))\n        key_order = [k for k in key_order if k in existing]\n        key_order += list(set(dct.keys()) - set(key_order))\n        return {k: dct[k] for k in key_order}\n\n    def dict(self, *args, **kwargs):\n\"\"\"Patched dict method (to preserve custom key order).\"\"\"\n        self._patch_kwargs_defaults(kwargs)\n        by_alias = kwargs.pop(\"by_alias\", False)\n\n        dct = super().dict(*args, **kwargs, by_alias=False)\n        ret = self._reorder_dict(dct)\n\n        if by_alias:\n            ret = {self.__fields__[k].alias: v for k, v in ret.items()}\n        return ret\n\n    def json(self, *args, **kwargs):\n\"\"\"Patched json method (to preserve custom key order).\"\"\"\n        self._patch_kwargs_defaults(kwargs)\n        by_alias = kwargs.pop(\"by_alias\", False)\n\n        # loop back json through dict to apply custom key order\n        dct = json.loads(super().json(*args, **kwargs, by_alias=False))\n        ret = self._reorder_dict(dct)\n\n        if by_alias:\n            ret = {self.__fields__[k].alias: v for k, v in ret.items()}\n        return json.dumps(ret)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.Config","title":"Config","text":"<p>Pydantic config.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic config.\"\"\"\n\n    extra = Extra.forbid\n    allow_population_by_field_name = True\n    underscore_attrs_are_private = True\n    anystr_strip_whitespace = True\n    min_anystr_length = 1\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.make_partial","title":"make_partial  <code>classmethod</code>","text":"<pre><code>make_partial(dct)\n</code></pre> <p>Construct unvalidated partial model from dict.</p> <p>Handles aliases correctly, unlike <code>construct</code>.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef make_partial(cls, dct):\n\"\"\"Construct unvalidated partial model from dict.\n\n    Handles aliases correctly, unlike `construct`.\n    \"\"\"\n    un_alias = cls._aliases()\n    return cls.construct(**{un_alias.get(k) or k: v for k, v in dct.items()})\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.set_key_order","title":"set_key_order","text":"<pre><code>set_key_order(keys: List[str])\n</code></pre> <p>Setter for custom key order used in serialization.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def set_key_order(self, keys: List[str]):\n\"\"\"Setter for custom key order used in serialization.\"\"\"\n    un_alias = self._aliases()\n    # make sure we use the _actual_ field names\n    self._key_order = list(map(lambda k: un_alias.get(k) or k, keys))\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.copy","title":"copy","text":"<pre><code>copy(*args, **kwargs)\n</code></pre> <p>Patched copy method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def copy(self, *args, **kwargs):\n\"\"\"Patched copy method (to preserve custom key order).\"\"\"\n    ret = super().copy(*args, **kwargs)\n    ret.set_key_order(list(self._key_order))\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.dict","title":"dict","text":"<pre><code>dict(*args, **kwargs)\n</code></pre> <p>Patched dict method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def dict(self, *args, **kwargs):\n\"\"\"Patched dict method (to preserve custom key order).\"\"\"\n    self._patch_kwargs_defaults(kwargs)\n    by_alias = kwargs.pop(\"by_alias\", False)\n\n    dct = super().dict(*args, **kwargs, by_alias=False)\n    ret = self._reorder_dict(dct)\n\n    if by_alias:\n        ret = {self.__fields__[k].alias: v for k, v in ret.items()}\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.json","title":"json","text":"<pre><code>json(*args, **kwargs)\n</code></pre> <p>Patched json method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def json(self, *args, **kwargs):\n\"\"\"Patched json method (to preserve custom key order).\"\"\"\n    self._patch_kwargs_defaults(kwargs)\n    by_alias = kwargs.pop(\"by_alias\", False)\n\n    # loop back json through dict to apply custom key order\n    dct = json.loads(super().json(*args, **kwargs, by_alias=False))\n    ret = self._reorder_dict(dct)\n\n    if by_alias:\n        ret = {self.__fields__[k].alias: v for k, v in ret.items()}\n    return json.dumps(ret)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig","title":"SomesyConfig","text":"<p>             Bases: <code>SomesyBaseModel</code></p> <p>Pydantic model for somesy tool configuration.</p> <p>Note that all fields match CLI options, and CLI options will override the values declared in a somesy input file (such as <code>somesy.toml</code>).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyConfig(SomesyBaseModel):\n\"\"\"Pydantic model for somesy tool configuration.\n\n    Note that all fields match CLI options, and CLI options will override the\n    values declared in a somesy input file (such as `somesy.toml`).\n    \"\"\"\n\n    @root_validator\n    def at_least_one_target(cls, values):\n\"\"\"Check that at least one output file is enabled.\"\"\"\n        if all(map(lambda x: values.get(f\"no_sync_{x}\"), SOMESY_TARGETS)):\n            msg = \"No sync target enabled, nothing to do. Probably this is a mistake?\"\n            raise ValueError(msg)\n\n        return values\n\n    # cli flags\n    show_info: bool = Field(\n        False, description=\"Show basic information messages on run (-v flag).\"\n    )\n    verbose: bool = Field(False, description=\"Show verbose messages on run (-vv flag).\")\n    debug: bool = Field(False, description=\"Show debug messages on run (-vvv flag).\")\n\n    # input config\n    input_file: Path = Field(\n        Path(\"somesy.toml\"), description=\"Project metadata input file path.\"\n    )\n\n    # output config\n    no_sync_cff: bool = Field(False, description=\"Do not sync with CFF.\")\n    cff_file: Path = Field(Path(\"CITATION.cff\"), description=\"CFF file path.\")\n\n    no_sync_pyproject: bool = Field(\n        False, description=\"Do not sync with pyproject.toml.\"\n    )\n    pyproject_file: Path = Field(\n        Path(\"pyproject.toml\"), description=\"pyproject.toml file path.\"\n    )\n\n    sync_package_json: bool = Field(False, description=\"Sync with package.json.\")\n    package_json_file: Path = Field(\n        Path(\"package.json\"), description=\"package.json file path.\"\n    )\n\n    no_sync_codemeta: bool = Field(False, description=\"Do not sync with codemeta.json.\")\n    codemeta_file: Path = Field(\n        Path(\"codemeta.json\"), description=\"codemeta.json file path.\"\n    )\n\n    def log_level(self) -&gt; SomesyLogLevel:\n\"\"\"Return log level derived from this configuration.\"\"\"\n        return SomesyLogLevel.from_flags(\n            info=self.show_info, verbose=self.verbose, debug=self.debug\n        )\n\n    def update_log_level(self, log_level: SomesyLogLevel):\n\"\"\"Update config flags according to passed log level.\"\"\"\n        self.show_info = log_level == SomesyLogLevel.INFO\n        self.verbose = log_level == SomesyLogLevel.VERBOSE\n        self.debug = log_level == SomesyLogLevel.DEBUG\n\n    def get_input(self) -&gt; SomesyInput:\n\"\"\"Based on the somesy config, load the complete somesy input.\"\"\"\n        # get metadata+config from specified input file\n        somesy_input = SomesyInput.from_input_file(self.input_file)\n        # update input with merged config settings (cli overrides config file)\n        dct: Dict[str, Any] = {}\n        dct.update(somesy_input.config or {})\n        dct.update(self.dict())\n        somesy_input.config = SomesyConfig(**dct)\n        return somesy_input\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.at_least_one_target","title":"at_least_one_target","text":"<pre><code>at_least_one_target(values)\n</code></pre> <p>Check that at least one output file is enabled.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@root_validator\ndef at_least_one_target(cls, values):\n\"\"\"Check that at least one output file is enabled.\"\"\"\n    if all(map(lambda x: values.get(f\"no_sync_{x}\"), SOMESY_TARGETS)):\n        msg = \"No sync target enabled, nothing to do. Probably this is a mistake?\"\n        raise ValueError(msg)\n\n    return values\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.log_level","title":"log_level","text":"<pre><code>log_level() -&gt; SomesyLogLevel\n</code></pre> <p>Return log level derived from this configuration.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def log_level(self) -&gt; SomesyLogLevel:\n\"\"\"Return log level derived from this configuration.\"\"\"\n    return SomesyLogLevel.from_flags(\n        info=self.show_info, verbose=self.verbose, debug=self.debug\n    )\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.update_log_level","title":"update_log_level","text":"<pre><code>update_log_level(log_level: SomesyLogLevel)\n</code></pre> <p>Update config flags according to passed log level.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def update_log_level(self, log_level: SomesyLogLevel):\n\"\"\"Update config flags according to passed log level.\"\"\"\n    self.show_info = log_level == SomesyLogLevel.INFO\n    self.verbose = log_level == SomesyLogLevel.VERBOSE\n    self.debug = log_level == SomesyLogLevel.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.get_input","title":"get_input","text":"<pre><code>get_input() -&gt; SomesyInput\n</code></pre> <p>Based on the somesy config, load the complete somesy input.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def get_input(self) -&gt; SomesyInput:\n\"\"\"Based on the somesy config, load the complete somesy input.\"\"\"\n    # get metadata+config from specified input file\n    somesy_input = SomesyInput.from_input_file(self.input_file)\n    # update input with merged config settings (cli overrides config file)\n    dct: Dict[str, Any] = {}\n    dct.update(somesy_input.config or {})\n    dct.update(self.dict())\n    somesy_input.config = SomesyConfig(**dct)\n    return somesy_input\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person","title":"Person","text":"<p>             Bases: <code>SomesyBaseModel</code></p> <p>Metadata abount a person in the context of a software project.</p> <p>This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class Person(SomesyBaseModel):\n\"\"\"Metadata abount a person in the context of a software project.\n\n    This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.\n    \"\"\"\n\n    # NOTE: we rely on the defined aliases for direct CITATION.cff interoperability.\n\n    orcid: Annotated[\n        Optional[AnyUrl],\n        Field(\n            description=\"The person's ORCID url **(not required, but highly suggested)**.\"\n        ),\n    ]\n\n    email: Annotated[\n        str,\n        Field(\n            regex=r\"^[\\S]+@[\\S]+\\.[\\S]{2,}$\", description=\"The person's email address.\"\n        ),\n    ]\n\n    family_names: Annotated[\n        str, Field(alias=\"family-names\", description=\"The person's family names.\")\n    ]\n    given_names: Annotated[\n        str, Field(alias=\"given-names\", description=\"The person's given names.\")\n    ]\n\n    name_particle: Annotated[\n        Optional[str],\n        Field(\n            alias=\"name-particle\",\n            description=\"The person's name particle, e.g., a nobiliary particle or a preposition meaning 'of' or 'from' (for example 'von' in 'Alexander von Humboldt').\",\n            examples=[\"von\"],\n        ),\n    ]\n    name_suffix: Annotated[\n        Optional[str],\n        Field(\n            alias=\"name-suffix\",\n            description=\"The person's name-suffix, e.g. 'Jr.' for Sammy Davis Jr. or 'III' for Frank Edwin Wright III.\",\n            examples=[\"Jr.\", \"III\"],\n        ),\n    ]\n    alias: Annotated[Optional[str], Field(description=\"The person's alias.\")]\n\n    affiliation: Annotated[\n        Optional[str], Field(description=\"The person's affiliation.\")\n    ]\n\n    address: Annotated[Optional[str], Field(description=\"The person's address.\")]\n    city: Annotated[Optional[str], Field(description=\"The person's city.\")]\n    country: Annotated[Optional[Country], Field(description=\"The person's country.\")]\n    fax: Annotated[Optional[str], Field(description=\"The person's fax number.\")]\n    post_code: Annotated[\n        Optional[str], Field(alias=\"post-code\", description=\"The person's post-code.\")\n    ]\n    region: Annotated[Optional[str], Field(description=\"The person's region.\")]\n    tel: Annotated[Optional[str], Field(description=\"The person's phone number.\")]\n\n    # ----\n    # somesy-specific extensions\n    author: Annotated[\n        bool,\n        Field(\n            description=\"Indicates whether the person is an author of the project (i.e. for citations).\"\n        ),\n    ] = False\n    maintainer: Annotated[\n        bool,\n        Field(\n            description=\"Indicates whether the person is a maintainer of the project (i.e. for contact).\"\n        ),\n    ] = False\n\n    # NOTE: CFF 1.3 (once done) might provide ways for refined contributor description. That should be implemented here.\n    contribution: Annotated[\n        Optional[str],\n        Field(description=\"Summary of how the person contributed to the project.\"),\n    ]\n    contribution_types: Annotated[\n        Optional[List[ContributionTypeEnum]],\n        Field(\n            description=\"Relevant types of contributions (see https://allcontributors.org/docs/de/emoji-key).\",\n            min_items=1,\n        ),\n    ]\n    contribution_begin: Annotated[\n        Optional[date], Field(description=\"Beginning date of the contribution.\")\n    ]\n    contribution_end: Annotated[\n        Optional[date], Field(description=\"Ending date of the contribution.\")\n    ]\n\n    # helper methods\n\n    @property\n    def full_name(self) -&gt; str:\n\"\"\"Return the full name of the person.\"\"\"\n        names = []\n\n        if self.given_names:\n            names.append(self.given_names)\n\n        if self.name_particle:\n            names.append(self.name_particle)\n\n        if self.family_names:\n            names.append(self.family_names)\n\n        if self.name_suffix:\n            names.append(self.name_suffix)\n\n        return \" \".join(names) if names else \"\"\n\n    def same_person(self, other) -&gt; bool:\n\"\"\"Return whether two Person metadata records are about the same real person.\n\n        Uses heuristic match based on orcid, email and name (whichever are provided).\n        \"\"\"\n        if self.orcid is not None and other.orcid is not None:\n            # having orcids is the best case, a real identifier\n            return self.orcid == other.orcid\n\n        # otherwise, try to match according to mail/name\n        # sourcery skip: merge-nested-ifs\n        if self.email is not None and other.email is not None:\n            if self.email == other.email:\n                # an email address belongs to exactly one person\n                # =&gt; same email -&gt; same person\n                return True\n            # otherwise, need to check name\n            # (a person often has multiple email addresses)\n\n        # no orcids, no/distinct email address\n        # -&gt; decide based on full_name (which is always present)\n        return self.full_name == other.full_name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Return the full name of the person.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person.same_person","title":"same_person","text":"<pre><code>same_person(other) -&gt; bool\n</code></pre> <p>Return whether two Person metadata records are about the same real person.</p> <p>Uses heuristic match based on orcid, email and name (whichever are provided).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def same_person(self, other) -&gt; bool:\n\"\"\"Return whether two Person metadata records are about the same real person.\n\n    Uses heuristic match based on orcid, email and name (whichever are provided).\n    \"\"\"\n    if self.orcid is not None and other.orcid is not None:\n        # having orcids is the best case, a real identifier\n        return self.orcid == other.orcid\n\n    # otherwise, try to match according to mail/name\n    # sourcery skip: merge-nested-ifs\n    if self.email is not None and other.email is not None:\n        if self.email == other.email:\n            # an email address belongs to exactly one person\n            # =&gt; same email -&gt; same person\n            return True\n        # otherwise, need to check name\n        # (a person often has multiple email addresses)\n\n    # no orcids, no/distinct email address\n    # -&gt; decide based on full_name (which is always present)\n    return self.full_name == other.full_name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata","title":"ProjectMetadata","text":"<p>             Bases: <code>SomesyBaseModel</code></p> <p>Pydantic model for Project Metadata Input.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class ProjectMetadata(SomesyBaseModel):\n\"\"\"Pydantic model for Project Metadata Input.\"\"\"\n\n    class Config:\n\"\"\"Pydantic config.\"\"\"\n\n        extra = Extra.ignore\n\n    @validator(\"people\")\n    def ensure_distinct_people(cls, people):\n\"\"\"Make sure that no person is listed twice in the same person list.\"\"\"\n        for i in range(len(people)):\n            for j in range(i + 1, len(people)):\n                if people[i].same_person(people[j]):\n                    p1 = pretty_repr(json.loads(people[i].json()))\n                    p2 = pretty_repr(json.loads(people[j].json()))\n                    msg = f\"Same person is listed twice:\\n{p1}\\n{p2}\"\n                    raise ValueError(msg)\n        return people\n\n    @validator(\"people\")\n    def at_least_one_author(cls, people):\n\"\"\"Make sure there is at least one author.\"\"\"\n        if not any(map(lambda p: p.author, people)):\n            raise ValueError(\"At least one person must be an author of this project.\")\n        return people\n\n    name: str = Field(description=\"Project name.\")\n    description: str = Field(description=\"Project description.\")\n    version: Optional[str] = Field(description=\"Project version.\")\n    license: LicenseEnum = Field(description=\"SPDX License string.\")\n\n    repository: Optional[AnyUrl] = Field(\n        None, description=\"URL of the project source code repository.\"\n    )\n    homepage: Optional[AnyUrl] = Field(None, description=\"URL of the project homepage.\")\n\n    keywords: Optional[List[str]] = Field(\n        None, min_items=1, description=\"Keywords that describe the project.\"\n    )\n\n    people: List[Person] = Field(\n        min_items=1, description=\"Project authors, maintainers and contributors.\"\n    )\n\n    def authors(self):\n\"\"\"Return people marked as authors.\"\"\"\n        return [p for p in self.people if p.author]\n\n    def maintainers(self):\n\"\"\"Return people marked as maintainers.\"\"\"\n        return [p for p in self.people if p.maintainer]\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.Config","title":"Config","text":"<p>Pydantic config.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic config.\"\"\"\n\n    extra = Extra.ignore\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.ensure_distinct_people","title":"ensure_distinct_people","text":"<pre><code>ensure_distinct_people(people)\n</code></pre> <p>Make sure that no person is listed twice in the same person list.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@validator(\"people\")\ndef ensure_distinct_people(cls, people):\n\"\"\"Make sure that no person is listed twice in the same person list.\"\"\"\n    for i in range(len(people)):\n        for j in range(i + 1, len(people)):\n            if people[i].same_person(people[j]):\n                p1 = pretty_repr(json.loads(people[i].json()))\n                p2 = pretty_repr(json.loads(people[j].json()))\n                msg = f\"Same person is listed twice:\\n{p1}\\n{p2}\"\n                raise ValueError(msg)\n    return people\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.at_least_one_author","title":"at_least_one_author","text":"<pre><code>at_least_one_author(people)\n</code></pre> <p>Make sure there is at least one author.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@validator(\"people\")\ndef at_least_one_author(cls, people):\n\"\"\"Make sure there is at least one author.\"\"\"\n    if not any(map(lambda p: p.author, people)):\n        raise ValueError(\"At least one person must be an author of this project.\")\n    return people\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.authors","title":"authors","text":"<pre><code>authors()\n</code></pre> <p>Return people marked as authors.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def authors(self):\n\"\"\"Return people marked as authors.\"\"\"\n    return [p for p in self.people if p.author]\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.maintainers","title":"maintainers","text":"<pre><code>maintainers()\n</code></pre> <p>Return people marked as maintainers.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def maintainers(self):\n\"\"\"Return people marked as maintainers.\"\"\"\n    return [p for p in self.people if p.maintainer]\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput","title":"SomesyInput","text":"<p>             Bases: <code>SomesyBaseModel</code></p> <p>The complete somesy input file (<code>somesy.toml</code>) or section (<code>pyproject.toml</code>).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyInput(SomesyBaseModel):\n\"\"\"The complete somesy input file (`somesy.toml`) or section (`pyproject.toml`).\"\"\"\n\n    _origin: Optional[Path]\n\n    project: ProjectMetadata = Field(\n        description=\"Project metadata to be used and synchronized.\"\n    )\n    config: Optional[SomesyConfig] = Field(\n        description=\"somesy tool configuration (matches CLI flags).\"\n    )\n\n    def is_somesy_file(self) -&gt; bool:\n\"\"\"Return whether this somesy input is from a somesy config file.\n\n        That means, returns False if it is from pyproject.toml or package.json.\n        \"\"\"\n        return self.is_somesy_file_path(self._origin or Path(\".\"))\n\n    @classmethod\n    def is_somesy_file_path(cls, path: Path) -&gt; bool:\n\"\"\"Return whether the path looks like a somesy config file.\n\n        That means, returns False if it is e.g. pyproject.toml or package.json.\n        \"\"\"\n        return str(path).endswith(\"somesy.toml\")\n\n    @classmethod\n    def from_input_file(cls, path: Path) -&gt; SomesyInput:\n\"\"\"Load somesy input from given file.\"\"\"\n        content = get_input_content(path)\n        ret = SomesyInput(**content)\n        ret._origin = path\n        return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.is_somesy_file","title":"is_somesy_file","text":"<pre><code>is_somesy_file() -&gt; bool\n</code></pre> <p>Return whether this somesy input is from a somesy config file.</p> <p>That means, returns False if it is from pyproject.toml or package.json.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def is_somesy_file(self) -&gt; bool:\n\"\"\"Return whether this somesy input is from a somesy config file.\n\n    That means, returns False if it is from pyproject.toml or package.json.\n    \"\"\"\n    return self.is_somesy_file_path(self._origin or Path(\".\"))\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.is_somesy_file_path","title":"is_somesy_file_path  <code>classmethod</code>","text":"<pre><code>is_somesy_file_path(path: Path) -&gt; bool\n</code></pre> <p>Return whether the path looks like a somesy config file.</p> <p>That means, returns False if it is e.g. pyproject.toml or package.json.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef is_somesy_file_path(cls, path: Path) -&gt; bool:\n\"\"\"Return whether the path looks like a somesy config file.\n\n    That means, returns False if it is e.g. pyproject.toml or package.json.\n    \"\"\"\n    return str(path).endswith(\"somesy.toml\")\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.from_input_file","title":"from_input_file  <code>classmethod</code>","text":"<pre><code>from_input_file(path: Path) -&gt; SomesyInput\n</code></pre> <p>Load somesy input from given file.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef from_input_file(cls, path: Path) -&gt; SomesyInput:\n\"\"\"Load somesy input from given file.\"\"\"\n    content = get_input_content(path)\n    ret = SomesyInput(**content)\n    ret._origin = path\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/types/","title":"types","text":"<p>Types and enums used in the somesy models.</p>"},{"location":"reference/somesy/core/types/#somesy.core.types.LicenseEnum","title":"LicenseEnum","text":"<p>             Bases: <code>Enum</code></p> <p>SPDX license identifiers.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class LicenseEnum(Enum):\n\"\"\"SPDX license identifiers.\"\"\"\n\n    field_0BSD = \"0BSD\"\n    AAL = \"AAL\"\n    Abstyles = \"Abstyles\"\n    Adobe_2006 = \"Adobe-2006\"\n    Adobe_Glyph = \"Adobe-Glyph\"\n    ADSL = \"ADSL\"\n    AFL_1_1 = \"AFL-1.1\"\n    AFL_1_2 = \"AFL-1.2\"\n    AFL_2_0 = \"AFL-2.0\"\n    AFL_2_1 = \"AFL-2.1\"\n    AFL_3_0 = \"AFL-3.0\"\n    Afmparse = \"Afmparse\"\n    AGPL_1_0 = \"AGPL-1.0\"\n    AGPL_1_0_only = \"AGPL-1.0-only\"\n    AGPL_1_0_or_later = \"AGPL-1.0-or-later\"\n    AGPL_3_0 = \"AGPL-3.0\"\n    AGPL_3_0_only = \"AGPL-3.0-only\"\n    AGPL_3_0_or_later = \"AGPL-3.0-or-later\"\n    Aladdin = \"Aladdin\"\n    AMDPLPA = \"AMDPLPA\"\n    AML = \"AML\"\n    AMPAS = \"AMPAS\"\n    ANTLR_PD = \"ANTLR-PD\"\n    ANTLR_PD_fallback = \"ANTLR-PD-fallback\"\n    Apache_1_0 = \"Apache-1.0\"\n    Apache_1_1 = \"Apache-1.1\"\n    Apache_2_0 = \"Apache-2.0\"\n    APAFML = \"APAFML\"\n    APL_1_0 = \"APL-1.0\"\n    APSL_1_0 = \"APSL-1.0\"\n    APSL_1_1 = \"APSL-1.1\"\n    APSL_1_2 = \"APSL-1.2\"\n    APSL_2_0 = \"APSL-2.0\"\n    Artistic_1_0 = \"Artistic-1.0\"\n    Artistic_1_0_cl8 = \"Artistic-1.0-cl8\"\n    Artistic_1_0_Perl = \"Artistic-1.0-Perl\"\n    Artistic_2_0 = \"Artistic-2.0\"\n    Bahyph = \"Bahyph\"\n    Barr = \"Barr\"\n    Beerware = \"Beerware\"\n    BitTorrent_1_0 = \"BitTorrent-1.0\"\n    BitTorrent_1_1 = \"BitTorrent-1.1\"\n    blessing = \"blessing\"\n    BlueOak_1_0_0 = \"BlueOak-1.0.0\"\n    Borceux = \"Borceux\"\n    BSD_1_Clause = \"BSD-1-Clause\"\n    BSD_2_Clause = \"BSD-2-Clause\"\n    BSD_2_Clause_FreeBSD = \"BSD-2-Clause-FreeBSD\"\n    BSD_2_Clause_NetBSD = \"BSD-2-Clause-NetBSD\"\n    BSD_2_Clause_Patent = \"BSD-2-Clause-Patent\"\n    BSD_2_Clause_Views = \"BSD-2-Clause-Views\"\n    BSD_3_Clause = \"BSD-3-Clause\"\n    BSD_3_Clause_Attribution = \"BSD-3-Clause-Attribution\"\n    BSD_3_Clause_Clear = \"BSD-3-Clause-Clear\"\n    BSD_3_Clause_LBNL = \"BSD-3-Clause-LBNL\"\n    BSD_3_Clause_Modification = \"BSD-3-Clause-Modification\"\n    BSD_3_Clause_No_Nuclear_License = \"BSD-3-Clause-No-Nuclear-License\"\n    BSD_3_Clause_No_Nuclear_License_2014 = \"BSD-3-Clause-No-Nuclear-License-2014\"\n    BSD_3_Clause_No_Nuclear_Warranty = \"BSD-3-Clause-No-Nuclear-Warranty\"\n    BSD_3_Clause_Open_MPI = \"BSD-3-Clause-Open-MPI\"\n    BSD_4_Clause = \"BSD-4-Clause\"\n    BSD_4_Clause_Shortened = \"BSD-4-Clause-Shortened\"\n    BSD_4_Clause_UC = \"BSD-4-Clause-UC\"\n    BSD_Protection = \"BSD-Protection\"\n    BSD_Source_Code = \"BSD-Source-Code\"\n    BSL_1_0 = \"BSL-1.0\"\n    BUSL_1_1 = \"BUSL-1.1\"\n    bzip2_1_0_5 = \"bzip2-1.0.5\"\n    bzip2_1_0_6 = \"bzip2-1.0.6\"\n    C_UDA_1_0 = \"C-UDA-1.0\"\n    CAL_1_0 = \"CAL-1.0\"\n    CAL_1_0_Combined_Work_Exception = \"CAL-1.0-Combined-Work-Exception\"\n    Caldera = \"Caldera\"\n    CATOSL_1_1 = \"CATOSL-1.1\"\n    CC_BY_1_0 = \"CC-BY-1.0\"\n    CC_BY_2_0 = \"CC-BY-2.0\"\n    CC_BY_2_5 = \"CC-BY-2.5\"\n    CC_BY_3_0 = \"CC-BY-3.0\"\n    CC_BY_3_0_AT = \"CC-BY-3.0-AT\"\n    CC_BY_3_0_US = \"CC-BY-3.0-US\"\n    CC_BY_4_0 = \"CC-BY-4.0\"\n    CC_BY_NC_1_0 = \"CC-BY-NC-1.0\"\n    CC_BY_NC_2_0 = \"CC-BY-NC-2.0\"\n    CC_BY_NC_2_5 = \"CC-BY-NC-2.5\"\n    CC_BY_NC_3_0 = \"CC-BY-NC-3.0\"\n    CC_BY_NC_4_0 = \"CC-BY-NC-4.0\"\n    CC_BY_NC_ND_1_0 = \"CC-BY-NC-ND-1.0\"\n    CC_BY_NC_ND_2_0 = \"CC-BY-NC-ND-2.0\"\n    CC_BY_NC_ND_2_5 = \"CC-BY-NC-ND-2.5\"\n    CC_BY_NC_ND_3_0 = \"CC-BY-NC-ND-3.0\"\n    CC_BY_NC_ND_3_0_IGO = \"CC-BY-NC-ND-3.0-IGO\"\n    CC_BY_NC_ND_4_0 = \"CC-BY-NC-ND-4.0\"\n    CC_BY_NC_SA_1_0 = \"CC-BY-NC-SA-1.0\"\n    CC_BY_NC_SA_2_0 = \"CC-BY-NC-SA-2.0\"\n    CC_BY_NC_SA_2_5 = \"CC-BY-NC-SA-2.5\"\n    CC_BY_NC_SA_3_0 = \"CC-BY-NC-SA-3.0\"\n    CC_BY_NC_SA_4_0 = \"CC-BY-NC-SA-4.0\"\n    CC_BY_ND_1_0 = \"CC-BY-ND-1.0\"\n    CC_BY_ND_2_0 = \"CC-BY-ND-2.0\"\n    CC_BY_ND_2_5 = \"CC-BY-ND-2.5\"\n    CC_BY_ND_3_0 = \"CC-BY-ND-3.0\"\n    CC_BY_ND_4_0 = \"CC-BY-ND-4.0\"\n    CC_BY_SA_1_0 = \"CC-BY-SA-1.0\"\n    CC_BY_SA_2_0 = \"CC-BY-SA-2.0\"\n    CC_BY_SA_2_0_UK = \"CC-BY-SA-2.0-UK\"\n    CC_BY_SA_2_1_JP = \"CC-BY-SA-2.1-JP\"\n    CC_BY_SA_2_5 = \"CC-BY-SA-2.5\"\n    CC_BY_SA_3_0 = \"CC-BY-SA-3.0\"\n    CC_BY_SA_3_0_AT = \"CC-BY-SA-3.0-AT\"\n    CC_BY_SA_4_0 = \"CC-BY-SA-4.0\"\n    CC_PDDC = \"CC-PDDC\"\n    CC0_1_0 = \"CC0-1.0\"\n    CDDL_1_0 = \"CDDL-1.0\"\n    CDDL_1_1 = \"CDDL-1.1\"\n    CDL_1_0 = \"CDL-1.0\"\n    CDLA_Permissive_1_0 = \"CDLA-Permissive-1.0\"\n    CDLA_Sharing_1_0 = \"CDLA-Sharing-1.0\"\n    CECILL_1_0 = \"CECILL-1.0\"\n    CECILL_1_1 = \"CECILL-1.1\"\n    CECILL_2_0 = \"CECILL-2.0\"\n    CECILL_2_1 = \"CECILL-2.1\"\n    CECILL_B = \"CECILL-B\"\n    CECILL_C = \"CECILL-C\"\n    CERN_OHL_1_1 = \"CERN-OHL-1.1\"\n    CERN_OHL_1_2 = \"CERN-OHL-1.2\"\n    CERN_OHL_P_2_0 = \"CERN-OHL-P-2.0\"\n    CERN_OHL_S_2_0 = \"CERN-OHL-S-2.0\"\n    CERN_OHL_W_2_0 = \"CERN-OHL-W-2.0\"\n    ClArtistic = \"ClArtistic\"\n    CNRI_Jython = \"CNRI-Jython\"\n    CNRI_Python = \"CNRI-Python\"\n    CNRI_Python_GPL_Compatible = \"CNRI-Python-GPL-Compatible\"\n    Condor_1_1 = \"Condor-1.1\"\n    copyleft_next_0_3_0 = \"copyleft-next-0.3.0\"\n    copyleft_next_0_3_1 = \"copyleft-next-0.3.1\"\n    CPAL_1_0 = \"CPAL-1.0\"\n    CPL_1_0 = \"CPL-1.0\"\n    CPOL_1_02 = \"CPOL-1.02\"\n    Crossword = \"Crossword\"\n    CrystalStacker = \"CrystalStacker\"\n    CUA_OPL_1_0 = \"CUA-OPL-1.0\"\n    Cube = \"Cube\"\n    curl = \"curl\"\n    D_FSL_1_0 = \"D-FSL-1.0\"\n    diffmark = \"diffmark\"\n    DOC = \"DOC\"\n    Dotseqn = \"Dotseqn\"\n    DRL_1_0 = \"DRL-1.0\"\n    DSDP = \"DSDP\"\n    dvipdfm = \"dvipdfm\"\n    ECL_1_0 = \"ECL-1.0\"\n    ECL_2_0 = \"ECL-2.0\"\n    eCos_2_0 = \"eCos-2.0\"\n    EFL_1_0 = \"EFL-1.0\"\n    EFL_2_0 = \"EFL-2.0\"\n    eGenix = \"eGenix\"\n    Entessa = \"Entessa\"\n    EPICS = \"EPICS\"\n    EPL_1_0 = \"EPL-1.0\"\n    EPL_2_0 = \"EPL-2.0\"\n    ErlPL_1_1 = \"ErlPL-1.1\"\n    etalab_2_0 = \"etalab-2.0\"\n    EUDatagrid = \"EUDatagrid\"\n    EUPL_1_0 = \"EUPL-1.0\"\n    EUPL_1_1 = \"EUPL-1.1\"\n    EUPL_1_2 = \"EUPL-1.2\"\n    Eurosym = \"Eurosym\"\n    Fair = \"Fair\"\n    Frameworx_1_0 = \"Frameworx-1.0\"\n    FreeBSD_DOC = \"FreeBSD-DOC\"\n    FreeImage = \"FreeImage\"\n    FSFAP = \"FSFAP\"\n    FSFUL = \"FSFUL\"\n    FSFULLR = \"FSFULLR\"\n    FTL = \"FTL\"\n    GD = \"GD\"\n    GFDL_1_1 = \"GFDL-1.1\"\n    GFDL_1_1_invariants_only = \"GFDL-1.1-invariants-only\"\n    GFDL_1_1_invariants_or_later = \"GFDL-1.1-invariants-or-later\"\n    GFDL_1_1_no_invariants_only = \"GFDL-1.1-no-invariants-only\"\n    GFDL_1_1_no_invariants_or_later = \"GFDL-1.1-no-invariants-or-later\"\n    GFDL_1_1_only = \"GFDL-1.1-only\"\n    GFDL_1_1_or_later = \"GFDL-1.1-or-later\"\n    GFDL_1_2 = \"GFDL-1.2\"\n    GFDL_1_2_invariants_only = \"GFDL-1.2-invariants-only\"\n    GFDL_1_2_invariants_or_later = \"GFDL-1.2-invariants-or-later\"\n    GFDL_1_2_no_invariants_only = \"GFDL-1.2-no-invariants-only\"\n    GFDL_1_2_no_invariants_or_later = \"GFDL-1.2-no-invariants-or-later\"\n    GFDL_1_2_only = \"GFDL-1.2-only\"\n    GFDL_1_2_or_later = \"GFDL-1.2-or-later\"\n    GFDL_1_3 = \"GFDL-1.3\"\n    GFDL_1_3_invariants_only = \"GFDL-1.3-invariants-only\"\n    GFDL_1_3_invariants_or_later = \"GFDL-1.3-invariants-or-later\"\n    GFDL_1_3_no_invariants_only = \"GFDL-1.3-no-invariants-only\"\n    GFDL_1_3_no_invariants_or_later = \"GFDL-1.3-no-invariants-or-later\"\n    GFDL_1_3_only = \"GFDL-1.3-only\"\n    GFDL_1_3_or_later = \"GFDL-1.3-or-later\"\n    Giftware = \"Giftware\"\n    GL2PS = \"GL2PS\"\n    Glide = \"Glide\"\n    Glulxe = \"Glulxe\"\n    GLWTPL = \"GLWTPL\"\n    gnuplot = \"gnuplot\"\n    GPL_1_0 = \"GPL-1.0\"\n    GPL_1_0_only = \"GPL-1.0-only\"\n    GPL_1_0_or_later = \"GPL-1.0-or-later\"\n    GPL_1_0_ = \"GPL-1.0+\"\n    GPL_2_0 = \"GPL-2.0\"\n    GPL_2_0_only = \"GPL-2.0-only\"\n    GPL_2_0_or_later = \"GPL-2.0-or-later\"\n    GPL_2_0_with_autoconf_exception = \"GPL-2.0-with-autoconf-exception\"\n    GPL_2_0_with_bison_exception = \"GPL-2.0-with-bison-exception\"\n    GPL_2_0_with_classpath_exception = \"GPL-2.0-with-classpath-exception\"\n    GPL_2_0_with_font_exception = \"GPL-2.0-with-font-exception\"\n    GPL_2_0_with_GCC_exception = \"GPL-2.0-with-GCC-exception\"\n    GPL_2_0_ = \"GPL-2.0+\"\n    GPL_3_0 = \"GPL-3.0\"\n    GPL_3_0_only = \"GPL-3.0-only\"\n    GPL_3_0_or_later = \"GPL-3.0-or-later\"\n    GPL_3_0_with_autoconf_exception = \"GPL-3.0-with-autoconf-exception\"\n    GPL_3_0_with_GCC_exception = \"GPL-3.0-with-GCC-exception\"\n    GPL_3_0_ = \"GPL-3.0+\"\n    gSOAP_1_3b = \"gSOAP-1.3b\"\n    HaskellReport = \"HaskellReport\"\n    Hippocratic_2_1 = \"Hippocratic-2.1\"\n    HPND = \"HPND\"\n    HPND_sell_variant = \"HPND-sell-variant\"\n    HTMLTIDY = \"HTMLTIDY\"\n    IBM_pibs = \"IBM-pibs\"\n    ICU = \"ICU\"\n    IJG = \"IJG\"\n    ImageMagick = \"ImageMagick\"\n    iMatix = \"iMatix\"\n    Imlib2 = \"Imlib2\"\n    Info_ZIP = \"Info-ZIP\"\n    Intel = \"Intel\"\n    Intel_ACPI = \"Intel-ACPI\"\n    Interbase_1_0 = \"Interbase-1.0\"\n    IPA = \"IPA\"\n    IPL_1_0 = \"IPL-1.0\"\n    ISC = \"ISC\"\n    JasPer_2_0 = \"JasPer-2.0\"\n    JPNIC = \"JPNIC\"\n    JSON = \"JSON\"\n    LAL_1_2 = \"LAL-1.2\"\n    LAL_1_3 = \"LAL-1.3\"\n    Latex2e = \"Latex2e\"\n    Leptonica = \"Leptonica\"\n    LGPL_2_0 = \"LGPL-2.0\"\n    LGPL_2_0_only = \"LGPL-2.0-only\"\n    LGPL_2_0_or_later = \"LGPL-2.0-or-later\"\n    LGPL_2_0_ = \"LGPL-2.0+\"\n    LGPL_2_1 = \"LGPL-2.1\"\n    LGPL_2_1_only = \"LGPL-2.1-only\"\n    LGPL_2_1_or_later = \"LGPL-2.1-or-later\"\n    LGPL_2_1_ = \"LGPL-2.1+\"\n    LGPL_3_0 = \"LGPL-3.0\"\n    LGPL_3_0_only = \"LGPL-3.0-only\"\n    LGPL_3_0_or_later = \"LGPL-3.0-or-later\"\n    LGPL_3_0_ = \"LGPL-3.0+\"\n    LGPLLR = \"LGPLLR\"\n    Libpng = \"Libpng\"\n    libpng_2_0 = \"libpng-2.0\"\n    libselinux_1_0 = \"libselinux-1.0\"\n    libtiff = \"libtiff\"\n    LiLiQ_P_1_1 = \"LiLiQ-P-1.1\"\n    LiLiQ_R_1_1 = \"LiLiQ-R-1.1\"\n    LiLiQ_Rplus_1_1 = \"LiLiQ-Rplus-1.1\"\n    Linux_OpenIB = \"Linux-OpenIB\"\n    LPL_1_0 = \"LPL-1.0\"\n    LPL_1_02 = \"LPL-1.02\"\n    LPPL_1_0 = \"LPPL-1.0\"\n    LPPL_1_1 = \"LPPL-1.1\"\n    LPPL_1_2 = \"LPPL-1.2\"\n    LPPL_1_3a = \"LPPL-1.3a\"\n    LPPL_1_3c = \"LPPL-1.3c\"\n    MakeIndex = \"MakeIndex\"\n    MirOS = \"MirOS\"\n    MIT = \"MIT\"\n    MIT_0 = \"MIT-0\"\n    MIT_advertising = \"MIT-advertising\"\n    MIT_CMU = \"MIT-CMU\"\n    MIT_enna = \"MIT-enna\"\n    MIT_feh = \"MIT-feh\"\n    MIT_Modern_Variant = \"MIT-Modern-Variant\"\n    MIT_open_group = \"MIT-open-group\"\n    MITNFA = \"MITNFA\"\n    Motosoto = \"Motosoto\"\n    mpich2 = \"mpich2\"\n    MPL_1_0 = \"MPL-1.0\"\n    MPL_1_1 = \"MPL-1.1\"\n    MPL_2_0 = \"MPL-2.0\"\n    MPL_2_0_no_copyleft_exception = \"MPL-2.0-no-copyleft-exception\"\n    MS_PL = \"MS-PL\"\n    MS_RL = \"MS-RL\"\n    MTLL = \"MTLL\"\n    MulanPSL_1_0 = \"MulanPSL-1.0\"\n    MulanPSL_2_0 = \"MulanPSL-2.0\"\n    Multics = \"Multics\"\n    Mup = \"Mup\"\n    NAIST_2003 = \"NAIST-2003\"\n    NASA_1_3 = \"NASA-1.3\"\n    Naumen = \"Naumen\"\n    NBPL_1_0 = \"NBPL-1.0\"\n    NCGL_UK_2_0 = \"NCGL-UK-2.0\"\n    NCSA = \"NCSA\"\n    Net_SNMP = \"Net-SNMP\"\n    NetCDF = \"NetCDF\"\n    Newsletr = \"Newsletr\"\n    NGPL = \"NGPL\"\n    NIST_PD = \"NIST-PD\"\n    NIST_PD_fallback = \"NIST-PD-fallback\"\n    NLOD_1_0 = \"NLOD-1.0\"\n    NLPL = \"NLPL\"\n    Nokia = \"Nokia\"\n    NOSL = \"NOSL\"\n    Noweb = \"Noweb\"\n    NPL_1_0 = \"NPL-1.0\"\n    NPL_1_1 = \"NPL-1.1\"\n    NPOSL_3_0 = \"NPOSL-3.0\"\n    NRL = \"NRL\"\n    NTP = \"NTP\"\n    NTP_0 = \"NTP-0\"\n    Nunit = \"Nunit\"\n    O_UDA_1_0 = \"O-UDA-1.0\"\n    OCCT_PL = \"OCCT-PL\"\n    OCLC_2_0 = \"OCLC-2.0\"\n    ODbL_1_0 = \"ODbL-1.0\"\n    ODC_By_1_0 = \"ODC-By-1.0\"\n    OFL_1_0 = \"OFL-1.0\"\n    OFL_1_0_no_RFN = \"OFL-1.0-no-RFN\"\n    OFL_1_0_RFN = \"OFL-1.0-RFN\"\n    OFL_1_1 = \"OFL-1.1\"\n    OFL_1_1_no_RFN = \"OFL-1.1-no-RFN\"\n    OFL_1_1_RFN = \"OFL-1.1-RFN\"\n    OGC_1_0 = \"OGC-1.0\"\n    OGDL_Taiwan_1_0 = \"OGDL-Taiwan-1.0\"\n    OGL_Canada_2_0 = \"OGL-Canada-2.0\"\n    OGL_UK_1_0 = \"OGL-UK-1.0\"\n    OGL_UK_2_0 = \"OGL-UK-2.0\"\n    OGL_UK_3_0 = \"OGL-UK-3.0\"\n    OGTSL = \"OGTSL\"\n    OLDAP_1_1 = \"OLDAP-1.1\"\n    OLDAP_1_2 = \"OLDAP-1.2\"\n    OLDAP_1_3 = \"OLDAP-1.3\"\n    OLDAP_1_4 = \"OLDAP-1.4\"\n    OLDAP_2_0 = \"OLDAP-2.0\"\n    OLDAP_2_0_1 = \"OLDAP-2.0.1\"\n    OLDAP_2_1 = \"OLDAP-2.1\"\n    OLDAP_2_2 = \"OLDAP-2.2\"\n    OLDAP_2_2_1 = \"OLDAP-2.2.1\"\n    OLDAP_2_2_2 = \"OLDAP-2.2.2\"\n    OLDAP_2_3 = \"OLDAP-2.3\"\n    OLDAP_2_4 = \"OLDAP-2.4\"\n    OLDAP_2_5 = \"OLDAP-2.5\"\n    OLDAP_2_6 = \"OLDAP-2.6\"\n    OLDAP_2_7 = \"OLDAP-2.7\"\n    OLDAP_2_8 = \"OLDAP-2.8\"\n    OML = \"OML\"\n    OpenSSL = \"OpenSSL\"\n    OPL_1_0 = \"OPL-1.0\"\n    OSET_PL_2_1 = \"OSET-PL-2.1\"\n    OSL_1_0 = \"OSL-1.0\"\n    OSL_1_1 = \"OSL-1.1\"\n    OSL_2_0 = \"OSL-2.0\"\n    OSL_2_1 = \"OSL-2.1\"\n    OSL_3_0 = \"OSL-3.0\"\n    Parity_6_0_0 = \"Parity-6.0.0\"\n    Parity_7_0_0 = \"Parity-7.0.0\"\n    PDDL_1_0 = \"PDDL-1.0\"\n    PHP_3_0 = \"PHP-3.0\"\n    PHP_3_01 = \"PHP-3.01\"\n    Plexus = \"Plexus\"\n    PolyForm_Noncommercial_1_0_0 = \"PolyForm-Noncommercial-1.0.0\"\n    PolyForm_Small_Business_1_0_0 = \"PolyForm-Small-Business-1.0.0\"\n    PostgreSQL = \"PostgreSQL\"\n    PSF_2_0 = \"PSF-2.0\"\n    psfrag = \"psfrag\"\n    psutils = \"psutils\"\n    Python_2_0 = \"Python-2.0\"\n    Qhull = \"Qhull\"\n    QPL_1_0 = \"QPL-1.0\"\n    Rdisc = \"Rdisc\"\n    RHeCos_1_1 = \"RHeCos-1.1\"\n    RPL_1_1 = \"RPL-1.1\"\n    RPL_1_5 = \"RPL-1.5\"\n    RPSL_1_0 = \"RPSL-1.0\"\n    RSA_MD = \"RSA-MD\"\n    RSCPL = \"RSCPL\"\n    Ruby = \"Ruby\"\n    SAX_PD = \"SAX-PD\"\n    Saxpath = \"Saxpath\"\n    SCEA = \"SCEA\"\n    Sendmail = \"Sendmail\"\n    Sendmail_8_23 = \"Sendmail-8.23\"\n    SGI_B_1_0 = \"SGI-B-1.0\"\n    SGI_B_1_1 = \"SGI-B-1.1\"\n    SGI_B_2_0 = \"SGI-B-2.0\"\n    SHL_0_5 = \"SHL-0.5\"\n    SHL_0_51 = \"SHL-0.51\"\n    SimPL_2_0 = \"SimPL-2.0\"\n    SISSL = \"SISSL\"\n    SISSL_1_2 = \"SISSL-1.2\"\n    Sleepycat = \"Sleepycat\"\n    SMLNJ = \"SMLNJ\"\n    SMPPL = \"SMPPL\"\n    SNIA = \"SNIA\"\n    Spencer_86 = \"Spencer-86\"\n    Spencer_94 = \"Spencer-94\"\n    Spencer_99 = \"Spencer-99\"\n    SPL_1_0 = \"SPL-1.0\"\n    SSH_OpenSSH = \"SSH-OpenSSH\"\n    SSH_short = \"SSH-short\"\n    SSPL_1_0 = \"SSPL-1.0\"\n    StandardML_NJ = \"StandardML-NJ\"\n    SugarCRM_1_1_3 = \"SugarCRM-1.1.3\"\n    SWL = \"SWL\"\n    TAPR_OHL_1_0 = \"TAPR-OHL-1.0\"\n    TCL = \"TCL\"\n    TCP_wrappers = \"TCP-wrappers\"\n    TMate = \"TMate\"\n    TORQUE_1_1 = \"TORQUE-1.1\"\n    TOSL = \"TOSL\"\n    TU_Berlin_1_0 = \"TU-Berlin-1.0\"\n    TU_Berlin_2_0 = \"TU-Berlin-2.0\"\n    UCL_1_0 = \"UCL-1.0\"\n    Unicode_DFS_2015 = \"Unicode-DFS-2015\"\n    Unicode_DFS_2016 = \"Unicode-DFS-2016\"\n    Unicode_TOU = \"Unicode-TOU\"\n    Unlicense = \"Unlicense\"\n    UPL_1_0 = \"UPL-1.0\"\n    Vim = \"Vim\"\n    VOSTROM = \"VOSTROM\"\n    VSL_1_0 = \"VSL-1.0\"\n    W3C = \"W3C\"\n    W3C_19980720 = \"W3C-19980720\"\n    W3C_20150513 = \"W3C-20150513\"\n    Watcom_1_0 = \"Watcom-1.0\"\n    Wsuipa = \"Wsuipa\"\n    WTFPL = \"WTFPL\"\n    wxWindows = \"wxWindows\"\n    X11 = \"X11\"\n    Xerox = \"Xerox\"\n    XFree86_1_1 = \"XFree86-1.1\"\n    xinetd = \"xinetd\"\n    Xnet = \"Xnet\"\n    xpp = \"xpp\"\n    XSkat = \"XSkat\"\n    YPL_1_0 = \"YPL-1.0\"\n    YPL_1_1 = \"YPL-1.1\"\n    Zed = \"Zed\"\n    Zend_2_0 = \"Zend-2.0\"\n    Zimbra_1_3 = \"Zimbra-1.3\"\n    Zimbra_1_4 = \"Zimbra-1.4\"\n    Zlib = \"Zlib\"\n    zlib_acknowledgement = \"zlib-acknowledgement\"\n    ZPL_1_1 = \"ZPL-1.1\"\n    ZPL_2_0 = \"ZPL-2.0\"\n    ZPL_2_1 = \"ZPL-2.1\"\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.ContributionTypeEnum","title":"ContributionTypeEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Contribution type using emojis from https://allcontributors.org/docs/en/emoji-key .</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class ContributionTypeEnum(Enum):\n\"\"\"Contribution type using emojis from https://allcontributors.org/docs/en/emoji-key .\"\"\"\n\n    audio = \"audio\"\n    ally = \"ally\"\n    bug = \"bug\"\n    blog = \"blog\"\n    business = \"business\"\n    code = \"code\"\n    content = \"content\"\n    data = \"data\"\n    doc = \"doc\"\n    design = \"design\"\n    example = \"example\"\n    eventOrganizing = \"eventOrganizing\"\n    financial = \"financial\"\n    fundingFinding = \"fundingFinding\"\n    ideas = \"ideas\"\n    infra = \"infra\"\n    maintenance = \"maintenance\"\n    mentoring = \"mentoring\"\n    platform = \"platform\"\n    plugin = \"plugin\"\n    projectManagement = \"projectManagement\"\n    promotion = \"promotion\"\n    question = \"question\"\n    research = \"research\"\n    review = \"review\"\n    security = \"security\"\n    tool = \"tool\"\n    translation = \"translation\"\n    test = \"test\"\n    tutorial = \"tutorial\"\n    talk = \"talk\"\n    userTesting = \"userTesting\"\n    video = \"video\"\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.Country","title":"Country","text":"<p>             Bases: <code>Enum</code></p> <p>Country codes from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2 . It is used for the country of a person in project metadata.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class Country(Enum):\n\"\"\"Country codes from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2 . It is used for the country of a person in project metadata.\"\"\"\n\n    AD = \"AD\"\n    AE = \"AE\"\n    AF = \"AF\"\n    AG = \"AG\"\n    AI = \"AI\"\n    AL = \"AL\"\n    AM = \"AM\"\n    AO = \"AO\"\n    AQ = \"AQ\"\n    AR = \"AR\"\n    AS = \"AS\"\n    AT = \"AT\"\n    AU = \"AU\"\n    AW = \"AW\"\n    AX = \"AX\"\n    AZ = \"AZ\"\n    BA = \"BA\"\n    BB = \"BB\"\n    BD = \"BD\"\n    BE = \"BE\"\n    BF = \"BF\"\n    BG = \"BG\"\n    BH = \"BH\"\n    BI = \"BI\"\n    BJ = \"BJ\"\n    BL = \"BL\"\n    BM = \"BM\"\n    BN = \"BN\"\n    BO = \"BO\"\n    BQ = \"BQ\"\n    BR = \"BR\"\n    BS = \"BS\"\n    BT = \"BT\"\n    BV = \"BV\"\n    BW = \"BW\"\n    BY = \"BY\"\n    BZ = \"BZ\"\n    CA = \"CA\"\n    CC = \"CC\"\n    CD = \"CD\"\n    CF = \"CF\"\n    CG = \"CG\"\n    CH = \"CH\"\n    CI = \"CI\"\n    CK = \"CK\"\n    CL = \"CL\"\n    CM = \"CM\"\n    CN = \"CN\"\n    CO = \"CO\"\n    CR = \"CR\"\n    CU = \"CU\"\n    CV = \"CV\"\n    CW = \"CW\"\n    CX = \"CX\"\n    CY = \"CY\"\n    CZ = \"CZ\"\n    DE = \"DE\"\n    DJ = \"DJ\"\n    DK = \"DK\"\n    DM = \"DM\"\n    DO = \"DO\"\n    DZ = \"DZ\"\n    EC = \"EC\"\n    EE = \"EE\"\n    EG = \"EG\"\n    EH = \"EH\"\n    ER = \"ER\"\n    ES = \"ES\"\n    ET = \"ET\"\n    FI = \"FI\"\n    FJ = \"FJ\"\n    FK = \"FK\"\n    FM = \"FM\"\n    FO = \"FO\"\n    FR = \"FR\"\n    GA = \"GA\"\n    GB = \"GB\"\n    GD = \"GD\"\n    GE = \"GE\"\n    GF = \"GF\"\n    GG = \"GG\"\n    GH = \"GH\"\n    GI = \"GI\"\n    GL = \"GL\"\n    GM = \"GM\"\n    GN = \"GN\"\n    GP = \"GP\"\n    GQ = \"GQ\"\n    GR = \"GR\"\n    GS = \"GS\"\n    GT = \"GT\"\n    GU = \"GU\"\n    GW = \"GW\"\n    GY = \"GY\"\n    HK = \"HK\"\n    HM = \"HM\"\n    HN = \"HN\"\n    HR = \"HR\"\n    HT = \"HT\"\n    HU = \"HU\"\n    ID = \"ID\"\n    IE = \"IE\"\n    IL = \"IL\"\n    IM = \"IM\"\n    IN = \"IN\"\n    IO = \"IO\"\n    IQ = \"IQ\"\n    IR = \"IR\"\n    IS = \"IS\"\n    IT = \"IT\"\n    JE = \"JE\"\n    JM = \"JM\"\n    JO = \"JO\"\n    JP = \"JP\"\n    KE = \"KE\"\n    KG = \"KG\"\n    KH = \"KH\"\n    KI = \"KI\"\n    KM = \"KM\"\n    KN = \"KN\"\n    KP = \"KP\"\n    KR = \"KR\"\n    KW = \"KW\"\n    KY = \"KY\"\n    KZ = \"KZ\"\n    LA = \"LA\"\n    LB = \"LB\"\n    LC = \"LC\"\n    LI = \"LI\"\n    LK = \"LK\"\n    LR = \"LR\"\n    LS = \"LS\"\n    LT = \"LT\"\n    LU = \"LU\"\n    LV = \"LV\"\n    LY = \"LY\"\n    MA = \"MA\"\n    MC = \"MC\"\n    MD = \"MD\"\n    ME = \"ME\"\n    MF = \"MF\"\n    MG = \"MG\"\n    MH = \"MH\"\n    MK = \"MK\"\n    ML = \"ML\"\n    MM = \"MM\"\n    MN = \"MN\"\n    MO = \"MO\"\n    MP = \"MP\"\n    MQ = \"MQ\"\n    MR = \"MR\"\n    MS = \"MS\"\n    MT = \"MT\"\n    MU = \"MU\"\n    MV = \"MV\"\n    MW = \"MW\"\n    MX = \"MX\"\n    MY = \"MY\"\n    MZ = \"MZ\"\n    NA = \"NA\"\n    NC = \"NC\"\n    NE = \"NE\"\n    NF = \"NF\"\n    NG = \"NG\"\n    NI = \"NI\"\n    NL = \"NL\"\n    NO = \"NO\"\n    NP = \"NP\"\n    NR = \"NR\"\n    NU = \"NU\"\n    NZ = \"NZ\"\n    OM = \"OM\"\n    PA = \"PA\"\n    PE = \"PE\"\n    PF = \"PF\"\n    PG = \"PG\"\n    PH = \"PH\"\n    PK = \"PK\"\n    PL = \"PL\"\n    PM = \"PM\"\n    PN = \"PN\"\n    PR = \"PR\"\n    PS = \"PS\"\n    PT = \"PT\"\n    PW = \"PW\"\n    PY = \"PY\"\n    QA = \"QA\"\n    RE = \"RE\"\n    RO = \"RO\"\n    RS = \"RS\"\n    RU = \"RU\"\n    RW = \"RW\"\n    SA = \"SA\"\n    SB = \"SB\"\n    SC = \"SC\"\n    SD = \"SD\"\n    SE = \"SE\"\n    SG = \"SG\"\n    SH = \"SH\"\n    SI = \"SI\"\n    SJ = \"SJ\"\n    SK = \"SK\"\n    SL = \"SL\"\n    SM = \"SM\"\n    SN = \"SN\"\n    SO = \"SO\"\n    SR = \"SR\"\n    SS = \"SS\"\n    ST = \"ST\"\n    SV = \"SV\"\n    SX = \"SX\"\n    SY = \"SY\"\n    SZ = \"SZ\"\n    TC = \"TC\"\n    TD = \"TD\"\n    TF = \"TF\"\n    TG = \"TG\"\n    TH = \"TH\"\n    TJ = \"TJ\"\n    TK = \"TK\"\n    TL = \"TL\"\n    TM = \"TM\"\n    TN = \"TN\"\n    TO = \"TO\"\n    TR = \"TR\"\n    TT = \"TT\"\n    TV = \"TV\"\n    TW = \"TW\"\n    TZ = \"TZ\"\n    UA = \"UA\"\n    UG = \"UG\"\n    UM = \"UM\"\n    US = \"US\"\n    UY = \"UY\"\n    UZ = \"UZ\"\n    VA = \"VA\"\n    VC = \"VC\"\n    VE = \"VE\"\n    VG = \"VG\"\n    VI = \"VI\"\n    VN = \"VN\"\n    VU = \"VU\"\n    WF = \"WF\"\n    WS = \"WS\"\n    YE = \"YE\"\n    YT = \"YT\"\n    ZA = \"ZA\"\n    ZM = \"ZM\"\n    ZW = \"ZW\"\n</code></pre>"},{"location":"reference/somesy/core/writer/","title":"writer","text":"<p>Project metadata writer base-class.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter","title":"ProjectMetadataWriter","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for Project Metadata Output Wrapper.</p> <p>All supported output formats are implemented as subclasses.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>class ProjectMetadataWriter(ABC):\n\"\"\"Base class for Project Metadata Output Wrapper.\n\n    All supported output formats are implemented as subclasses.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        *,\n        create_if_not_exists: Optional[bool] = False,\n        direct_mappings: Dict[str, List[str]] = None,\n    ) -&gt; None:\n\"\"\"Initialize the Project Metadata Output Wrapper.\n\n        Use the `direct_mappings` dict to define\n        format-specific location for certain fields,\n        if no additional processing is needed that\n        requires a customized setter.\n\n        Args:\n            path: Path to target output file.\n            create_if_not_exists: Create an empty CFF file if not exists. Defaults to True.\n            direct_mappings: Dict with direct mappings of keys between somesy and target\n        \"\"\"\n        self._data: Dict = {}\n        self.path = path\n        self.create_if_not_exists = create_if_not_exists\n        self.direct_mappings = direct_mappings or {}\n\n        if self.path.is_file():\n            self._load()\n            self._validate()\n        else:\n            if self.create_if_not_exists:\n                self._init_new_file()\n            else:\n                raise FileNotFoundError(f\"The file {self.path} does not exist.\")\n\n    def _init_new_file(self) -&gt; None:\n\"\"\"Create an new suitable target file.\n\n        Override to initialize file with minimal contents, if needed.\n        Make sure to set `self._data` to match the contents.\n        \"\"\"\n        self.path.touch()\n\n    @abstractmethod\n    def _load(self):\n\"\"\"Load the output file and validate it.\n\n        Implement this method so that it loads the file `self.path`\n        into the `self._data` dict.\n\n        The file is guaranteed to exist.\n        \"\"\"\n\n    @abstractmethod\n    def _validate(self):\n\"\"\"Validate the target file data.\n\n        Implement this method so that it checks\n        the validity of the metadata (relevant to somesy)\n        in that file and raises exceptions on failure.\n        \"\"\"\n\n    @abstractmethod\n    def save(self, path: Optional[Path]) -&gt; None:\n\"\"\"Save the output file to the given path.\n\n        Implement this in a way that will carefully\n        update the target file with new metadata\n        without destroying its other contents or structure.\n        \"\"\"\n\n    def _get_property(self, key: Union[str, List[str]]) -&gt; Optional[Any]:\n\"\"\"Get a property from the data.\n\n        Override this to e.g. rewrite the retrieved key\n        (e.g. if everything relevant is in some subobject).\n        \"\"\"\n        key_path = [key] if isinstance(key, str) else key\n\n        curr = self._data\n        for k in key_path:\n            curr = curr.get(k)\n            if curr is None:\n                return None\n\n        return curr\n\n    def _set_property(self, key: Union[str, List[str]], value: Any) -&gt; None:\n\"\"\"Set a property in the data.\n\n        Override this to e.g. rewrite the retrieved key\n        (e.g. if everything relevant is in some subobject).\n        \"\"\"\n        if not value:\n            return\n        key_path = [key] if isinstance(key, str) else key\n        # create path on the fly if needed\n        curr = self._data\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr[key] = {}\n            curr = curr[key]\n        curr[key_path[-1]] = value\n\n    # ----\n    # special handling for person metadata\n\n    def _merge_person_metadata(\n        self, old: List[Person], new: List[Person]\n    ) -&gt; List[Person]:\n\"\"\"Update metadata of a list of persons.\n\n        Will identify people based on orcid, email or full name.\n\n        If old list has same person listed multiple times,\n        the resulting list will too (we cannot correctly merge for external formats.)\n        \"\"\"\n        new_people = []  # list for new people (e.g. added authors)\n        # flag, meaning \"person was not removed\"\n        still_exists = [False for i in range(len(old))]\n        # copies of old person data, to be modified\n        modified_people = [p.copy() for p in old]\n\n        for person_meta in new:\n            person_update = person_meta.dict()\n            person_existed = False\n            for i in range(len(modified_people)):\n                person = modified_people[i]\n                if not person.same_person(person_meta):\n                    continue\n\n                # not new person (-&gt; will not append new record)\n                person_existed = True\n                # still exists (-&gt; will not be removed from list)\n                still_exists[i] = True\n\n                # if there were changes -&gt; update person\n                overlapping_fields = person.dict(include=set(person_update.keys()))\n                if person_update != overlapping_fields:\n                    modified_people[i] = person.copy(update=person_update)\n\n                    # show effective update in debug log\n                    old_fmt = self._from_person(person)\n                    new_fmt = self._from_person(modified_people[i])\n                    if old_fmt != new_fmt:\n                        log.debug(f\"Updating person\\n{old_fmt}\\nto\\n{new_fmt}\")\n\n            if not person_existed:\n                new_people.append(person_meta)\n\n        # show added and removed people in debug log\n        removed_people = [old[i] for i in range(len(old)) if not still_exists[i]]\n        for person in removed_people:\n            pers_fmt = self._from_person(person)\n            log.debug(f\"Removing person\\n{pers_fmt}\")\n        for person in new_people:\n            pers_fmt = self._from_person(person)\n            log.debug(f\"Adding person\\n{pers_fmt}\")\n\n        # return updated list of (still existing) people,\n        # and all new people coming after them.\n        existing_modified = [\n            modified_people[i] for i in range(len(old)) if still_exists[i]\n        ]\n        return existing_modified + new_people\n\n    def _sync_person_list(self, old: List[Any], new: List[Person]) -&gt; List[Any]:\n        old_people: List[Person] = self._parse_people(old)\n        return self._merge_person_metadata(old_people, new)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync output file with other metadata files.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n\n        if metadata.version:\n            self.version = metadata.version\n\n        if metadata.keywords:\n            self.keywords = metadata.keywords\n\n        self.authors = self._sync_person_list(self.authors, metadata.authors())\n        self.maintainers = self._sync_person_list(\n            self.maintainers, metadata.maintainers()\n        )\n\n        self.license = metadata.license.value\n        if metadata.homepage:\n            self.homepage = str(metadata.homepage)\n        if metadata.repository:\n            self.repository = str(metadata.repository)\n\n    @staticmethod\n    @abstractmethod\n    def _from_person(person: Person) -&gt; Any:\n\"\"\"Convert a `Person` object into suitable target format.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def _to_person(person_obj: Any) -&gt; Person:\n\"\"\"Convert an object representing a person into a `Person` object.\"\"\"\n\n    @classmethod\n    def _parse_people(cls, people: Optional[List[Any]]) -&gt; List[Person]:\n\"\"\"Return a list of Persons parsed from list format-specific people representations.\"\"\"\n        return list(map(cls._to_person, people or []))\n\n    # ----\n    # individual magic getters and setters\n\n    def _get_key(self, key):\n        return self.direct_mappings.get(key) or key\n\n    @property\n    def name(self):\n\"\"\"Return the name of the project.\"\"\"\n        return self._get_property(self._get_key(\"name\"))\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n\"\"\"Set the name of the project.\"\"\"\n        self._set_property(self._get_key(\"name\"), name)\n\n    @property\n    def version(self) -&gt; Optional[str]:\n\"\"\"Return the version of the project.\"\"\"\n        return self._get_property(self._get_key(\"version\"))\n\n    @version.setter\n    def version(self, version: str) -&gt; None:\n\"\"\"Set the version of the project.\"\"\"\n        self._set_property(self._get_key(\"version\"), version)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n\"\"\"Return the description of the project.\"\"\"\n        return self._get_property(self._get_key(\"description\"))\n\n    @description.setter\n    def description(self, description: str) -&gt; None:\n\"\"\"Set the description of the project.\"\"\"\n        self._set_property(self._get_key(\"description\"), description)\n\n    @property\n    def authors(self):\n\"\"\"Return the authors of the project.\"\"\"\n        return self._get_property(self._get_key(\"authors\"))\n\n    @authors.setter\n    def authors(self, authors: List[Person]) -&gt; None:\n\"\"\"Set the authors of the project.\"\"\"\n        authors = [self._from_person(c) for c in authors]\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @property\n    def maintainers(self):\n\"\"\"Return the maintainers of the project.\"\"\"\n        return self._get_property(self._get_key(\"maintainers\"))\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Person]) -&gt; None:\n\"\"\"Set the maintainers of the project.\"\"\"\n        maintainers = [self._from_person(c) for c in maintainers]\n        self._set_property(self._get_key(\"maintainers\"), maintainers)\n\n    @property\n    def keywords(self) -&gt; Optional[List[str]]:\n\"\"\"Return the keywords of the project.\"\"\"\n        return self._get_property(self._get_key(\"keywords\"))\n\n    @keywords.setter\n    def keywords(self, keywords: List[str]) -&gt; None:\n\"\"\"Set the keywords of the project.\"\"\"\n        self._set_property(self._get_key(\"keywords\"), keywords)\n\n    @property\n    def license(self) -&gt; Optional[str]:\n\"\"\"Return the license of the project.\"\"\"\n        return self._get_property(self._get_key(\"license\"))\n\n    @license.setter\n    def license(self, license: Optional[str]) -&gt; None:\n\"\"\"Set the license of the project.\"\"\"\n        self._set_property(self._get_key(\"license\"), license)\n\n    @property\n    def homepage(self) -&gt; Optional[str]:\n\"\"\"Return the homepage url of the project.\"\"\"\n        return self._get_property(self._get_key(\"homepage\"))\n\n    @homepage.setter\n    def homepage(self, homepage: Optional[str]) -&gt; None:\n\"\"\"Set the homepage url of the project.\"\"\"\n        self._set_property(self._get_key(\"homepage\"), homepage)\n\n    @property\n    def repository(self) -&gt; Optional[Union[str, dict]]:\n\"\"\"Return the repository url of the project.\"\"\"\n        return self._get_property(self._get_key(\"repository\"))\n\n    @repository.setter\n    def repository(self, repository: Optional[Union[str, dict]]) -&gt; None:\n\"\"\"Set the repository url of the project.\"\"\"\n        self._set_property(self._get_key(\"repository\"), repository)\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre> <p>Return the name of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.version","title":"version  <code>property</code> <code>writable</code>","text":"<pre><code>version: Optional[str]\n</code></pre> <p>Return the version of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.description","title":"description  <code>property</code> <code>writable</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Return the description of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the authors of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the maintainers of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.keywords","title":"keywords  <code>property</code> <code>writable</code>","text":"<pre><code>keywords: Optional[List[str]]\n</code></pre> <p>Return the keywords of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.license","title":"license  <code>property</code> <code>writable</code>","text":"<pre><code>license: Optional[str]\n</code></pre> <p>Return the license of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.homepage","title":"homepage  <code>property</code> <code>writable</code>","text":"<pre><code>homepage: Optional[str]\n</code></pre> <p>Return the homepage url of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.repository","title":"repository  <code>property</code> <code>writable</code>","text":"<pre><code>repository: Optional[Union[str, dict]]\n</code></pre> <p>Return the repository url of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    *,\n    create_if_not_exists: Optional[bool] = False,\n    direct_mappings: Dict[str, List[str]] = None\n) -&gt; None\n</code></pre> <p>Initialize the Project Metadata Output Wrapper.</p> <p>Use the <code>direct_mappings</code> dict to define format-specific location for certain fields, if no additional processing is needed that requires a customized setter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to target output file.</p> required <code>create_if_not_exists</code> <code>Optional[bool]</code> <p>Create an empty CFF file if not exists. Defaults to True.</p> <code>False</code> <code>direct_mappings</code> <code>Dict[str, List[str]]</code> <p>Dict with direct mappings of keys between somesy and target</p> <code>None</code> Source code in <code>src/somesy/core/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    *,\n    create_if_not_exists: Optional[bool] = False,\n    direct_mappings: Dict[str, List[str]] = None,\n) -&gt; None:\n\"\"\"Initialize the Project Metadata Output Wrapper.\n\n    Use the `direct_mappings` dict to define\n    format-specific location for certain fields,\n    if no additional processing is needed that\n    requires a customized setter.\n\n    Args:\n        path: Path to target output file.\n        create_if_not_exists: Create an empty CFF file if not exists. Defaults to True.\n        direct_mappings: Dict with direct mappings of keys between somesy and target\n    \"\"\"\n    self._data: Dict = {}\n    self.path = path\n    self.create_if_not_exists = create_if_not_exists\n    self.direct_mappings = direct_mappings or {}\n\n    if self.path.is_file():\n        self._load()\n        self._validate()\n    else:\n        if self.create_if_not_exists:\n            self._init_new_file()\n        else:\n            raise FileNotFoundError(f\"The file {self.path} does not exist.\")\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(path: Optional[Path]) -&gt; None\n</code></pre> <p>Save the output file to the given path.</p> <p>Implement this in a way that will carefully update the target file with new metadata without destroying its other contents or structure.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>@abstractmethod\ndef save(self, path: Optional[Path]) -&gt; None:\n\"\"\"Save the output file to the given path.\n\n    Implement this in a way that will carefully\n    update the target file with new metadata\n    without destroying its other contents or structure.\n    \"\"\"\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync output file with other metadata files.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n\n    if metadata.version:\n        self.version = metadata.version\n\n    if metadata.keywords:\n        self.keywords = metadata.keywords\n\n    self.authors = self._sync_person_list(self.authors, metadata.authors())\n    self.maintainers = self._sync_person_list(\n        self.maintainers, metadata.maintainers()\n    )\n\n    self.license = metadata.license.value\n    if metadata.homepage:\n        self.homepage = str(metadata.homepage)\n    if metadata.repository:\n        self.repository = str(metadata.repository)\n</code></pre>"},{"location":"reference/somesy/package_json/","title":"package_json","text":"<p>PackageJSON module.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON","title":"PackageJSON","text":"<p>             Bases: <code>ProjectMetadataWriter</code></p> <p>package.json parser and saver.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>class PackageJSON(ProjectMetadataWriter):\n\"\"\"package.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n    ):\n\"\"\"package.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings = {\n            \"authors\": [\"author\"],\n        }\n        super().__init__(path, create_if_not_exists=False, direct_mappings=mappings)\n\n    @property\n    def authors(self):\n\"\"\"Return the only author of the package.json file as list.\"\"\"\n        return [self._get_property(self._get_key(\"authors\"))]\n\n    @authors.setter\n    def authors(self, authors: List[Person]) -&gt; None:\n\"\"\"Set the authors of the project.\"\"\"\n        authors = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @property\n    def contributors(self):\n\"\"\"Return the contributors of the package.json file.\"\"\"\n        return self._get_property(self._get_key(\"contributors\"))\n\n    @contributors.setter\n    def contributors(self, contributors: List[Person]) -&gt; None:\n\"\"\"Set the contributors of the project.\"\"\"\n        contributors = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors)\n\n    def _load(self) -&gt; None:\n\"\"\"Load package.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n\"\"\"Validate package.json content using pydantic class.\"\"\"\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {PackageJsonConfig.__name__}: {pretty_repr(config)}\"\n        )\n        PackageJsonConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the package.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving package.json to {path}\")\n\n        with path.open(\"w\") as f:\n            # package.json indentation is 2 spaces\n            json.dump(self._data, f, indent=2)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to package.json dict for person format.\"\"\"\n        person_dict = {\"name\": person.full_name}\n        if person.email:\n            person_dict[\"email\"] = person.email\n        if person.orcid:\n            person_dict[\"url\"] = person.orcid\n        return person_dict\n\n    @staticmethod\n    def _to_person(person) -&gt; Person:\n\"\"\"Convert package.json dict or str for person format to project metadata person object.\"\"\"\n        if isinstance(person, str):\n            # parse from package.json format\n            person = PackageJsonConfig.convert_author(person).dict(exclude_none=True)\n\n        names = list(map(lambda s: s.strip(), person[\"name\"].split()))\n        person_obj = {\n            \"given-names\": \" \".join(names[:-1]),\n            \"family-names\": names[-1],\n        }\n        if \"email\" in person:\n            person_obj[\"email\"] = person[\"email\"].strip()\n        if \"url\" in person:\n            person_obj[\"orcid\"] = person[\"url\"].strip()\n        return Person(**person_obj)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync package.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = self._sync_person_list(self.contributors, metadata.people)\n        self.repository = {\"type\": \"git\", \"url\": metadata.repository}\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.writer.PackageJSON.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the package.json file as list.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.writer.PackageJSON.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the package.json file.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.writer.PackageJSON.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>package.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n):\n\"\"\"package.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings = {\n        \"authors\": [\"author\"],\n    }\n    super().__init__(path, create_if_not_exists=False, direct_mappings=mappings)\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.writer.PackageJSON.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the package.json file.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the package.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving package.json to {path}\")\n\n    with path.open(\"w\") as f:\n        # package.json indentation is 2 spaces\n        json.dump(self._data, f, indent=2)\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.writer.PackageJSON.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync package.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync package.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = self._sync_person_list(self.contributors, metadata.people)\n    self.repository = {\"type\": \"git\", \"url\": metadata.repository}\n</code></pre>"},{"location":"reference/somesy/package_json/models/","title":"models","text":"<p>package.json validation models.</p>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageAuthor","title":"PackageAuthor","text":"<p>             Bases: <code>BaseModel</code></p> <p>Package author model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageAuthor(BaseModel):\n\"\"\"Package author model.\"\"\"\n\n    name: Optional[str]\n    email: Optional[EmailStr]\n    url: Optional[AnyUrl]\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageRepository","title":"PackageRepository","text":"<p>             Bases: <code>BaseModel</code></p> <p>Package repository model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageRepository(BaseModel):\n\"\"\"Package repository model.\"\"\"\n\n    type: str\n    url: Optional[str]\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageLicense","title":"PackageLicense","text":"<p>             Bases: <code>BaseModel</code></p> <p>Package license model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageLicense(BaseModel):\n\"\"\"Package license model.\"\"\"\n\n    type: str\n    url: Optional[str]\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig","title":"PackageJsonConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Package.json config model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageJsonConfig(BaseModel):\n\"\"\"Package.json config model.\"\"\"\n\n    name: str\n    version: str\n    description: Optional[str]\n    author: Optional[Union[str, PackageAuthor]]\n    maintainers: Optional[List[Union[str, PackageAuthor]]]\n    contributors: Optional[List[Union[str, PackageAuthor]]]\n    license: Optional[Union[str, PackageLicense]]\n    repository: Optional[PackageRepository]\n    homepage: Optional[AnyUrl]\n    keywords: Optional[List[str]]\n\n    # convert package author to dict if it is a string\n    @classmethod\n    def convert_author(cls, author: str) -&gt; PackageAuthor:\n\"\"\"Convert author string to PackageAuthor model.\"\"\"\n        # parse author string to \"name &lt;email&gt; (url)\" format with regex\n        author_regex = r\"^(.*?)\\s*(?:&lt;([^&gt;]+)&gt;)?\\s*(?:\\(([^)]+)\\))?$\"\n        author_match = re.match(author_regex, author)\n        if not author_match:\n            raise ValidationError(f\"Invalid author format: {author}\")\n        author_name = author_match[1]\n        author_email = author_match[2]\n        author_url = author_match[3]\n\n        return PackageAuthor(name=author_name, email=author_email, url=author_url)\n\n    @validator(\"name\")\n    def validate_name(cls, v):\n\"\"\"Validate package name.\"\"\"\n        pattern = r\"^(@[a-z0-9-~][a-z0-9-._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$\"\n        if re.match(pattern, v) is None:\n            raise ValidationError(\"Invalid name\")\n\n        return v\n\n    @validator(\"version\")\n    def validate_version(cls, v):\n\"\"\"Validate package version.\"\"\"\n        # pattern for npm version\n        pattern = r\"^(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)(?:-(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\"\n        if re.match(pattern, v) is None:\n            raise ValidationError(\"Invalid version\")\n        return v\n\n    @validator(\"author\")\n    def validate_author(cls, v):\n\"\"\"Validate package author.\"\"\"\n        return cls.convert_author(v) if isinstance(v, str) else v\n\n    @validator(\"maintainers\", \"contributors\")\n    def validate_people(cls, v):\n\"\"\"Validate package maintainers and contributors.\"\"\"\n        people = []\n        for p in v:\n            if isinstance(p, str):\n                people.append(cls.convert_author(p))\n            else:\n                people.append(p)\n        return people\n\n    class Config:\n\"\"\"Pydantic config.\"\"\"\n\n        allow_population_by_field_name = True\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.Config","title":"Config","text":"<p>Pydantic config.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic config.\"\"\"\n\n    allow_population_by_field_name = True\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.convert_author","title":"convert_author  <code>classmethod</code>","text":"<pre><code>convert_author(author: str) -&gt; PackageAuthor\n</code></pre> <p>Convert author string to PackageAuthor model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@classmethod\ndef convert_author(cls, author: str) -&gt; PackageAuthor:\n\"\"\"Convert author string to PackageAuthor model.\"\"\"\n    # parse author string to \"name &lt;email&gt; (url)\" format with regex\n    author_regex = r\"^(.*?)\\s*(?:&lt;([^&gt;]+)&gt;)?\\s*(?:\\(([^)]+)\\))?$\"\n    author_match = re.match(author_regex, author)\n    if not author_match:\n        raise ValidationError(f\"Invalid author format: {author}\")\n    author_name = author_match[1]\n    author_email = author_match[2]\n    author_url = author_match[3]\n\n    return PackageAuthor(name=author_name, email=author_email, url=author_url)\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_name","title":"validate_name","text":"<pre><code>validate_name(v)\n</code></pre> <p>Validate package name.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@validator(\"name\")\ndef validate_name(cls, v):\n\"\"\"Validate package name.\"\"\"\n    pattern = r\"^(@[a-z0-9-~][a-z0-9-._~]*\\/)?[a-z0-9-~][a-z0-9-._~]*$\"\n    if re.match(pattern, v) is None:\n        raise ValidationError(\"Invalid name\")\n\n    return v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_version","title":"validate_version","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate package version.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@validator(\"version\")\ndef validate_version(cls, v):\n\"\"\"Validate package version.\"\"\"\n    # pattern for npm version\n    pattern = r\"^(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)(?:-(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\"\n    if re.match(pattern, v) is None:\n        raise ValidationError(\"Invalid version\")\n    return v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_author","title":"validate_author","text":"<pre><code>validate_author(v)\n</code></pre> <p>Validate package author.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@validator(\"author\")\ndef validate_author(cls, v):\n\"\"\"Validate package author.\"\"\"\n    return cls.convert_author(v) if isinstance(v, str) else v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_people","title":"validate_people","text":"<pre><code>validate_people(v)\n</code></pre> <p>Validate package maintainers and contributors.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@validator(\"maintainers\", \"contributors\")\ndef validate_people(cls, v):\n\"\"\"Validate package maintainers and contributors.\"\"\"\n    people = []\n    for p in v:\n        if isinstance(p, str):\n            people.append(cls.convert_author(p))\n        else:\n            people.append(p)\n    return people\n</code></pre>"},{"location":"reference/somesy/package_json/writer/","title":"writer","text":"<p>package.json parser and saver.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON","title":"PackageJSON","text":"<p>             Bases: <code>ProjectMetadataWriter</code></p> <p>package.json parser and saver.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>class PackageJSON(ProjectMetadataWriter):\n\"\"\"package.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n    ):\n\"\"\"package.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings = {\n            \"authors\": [\"author\"],\n        }\n        super().__init__(path, create_if_not_exists=False, direct_mappings=mappings)\n\n    @property\n    def authors(self):\n\"\"\"Return the only author of the package.json file as list.\"\"\"\n        return [self._get_property(self._get_key(\"authors\"))]\n\n    @authors.setter\n    def authors(self, authors: List[Person]) -&gt; None:\n\"\"\"Set the authors of the project.\"\"\"\n        authors = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @property\n    def contributors(self):\n\"\"\"Return the contributors of the package.json file.\"\"\"\n        return self._get_property(self._get_key(\"contributors\"))\n\n    @contributors.setter\n    def contributors(self, contributors: List[Person]) -&gt; None:\n\"\"\"Set the contributors of the project.\"\"\"\n        contributors = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors)\n\n    def _load(self) -&gt; None:\n\"\"\"Load package.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n\"\"\"Validate package.json content using pydantic class.\"\"\"\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {PackageJsonConfig.__name__}: {pretty_repr(config)}\"\n        )\n        PackageJsonConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the package.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving package.json to {path}\")\n\n        with path.open(\"w\") as f:\n            # package.json indentation is 2 spaces\n            json.dump(self._data, f, indent=2)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to package.json dict for person format.\"\"\"\n        person_dict = {\"name\": person.full_name}\n        if person.email:\n            person_dict[\"email\"] = person.email\n        if person.orcid:\n            person_dict[\"url\"] = person.orcid\n        return person_dict\n\n    @staticmethod\n    def _to_person(person) -&gt; Person:\n\"\"\"Convert package.json dict or str for person format to project metadata person object.\"\"\"\n        if isinstance(person, str):\n            # parse from package.json format\n            person = PackageJsonConfig.convert_author(person).dict(exclude_none=True)\n\n        names = list(map(lambda s: s.strip(), person[\"name\"].split()))\n        person_obj = {\n            \"given-names\": \" \".join(names[:-1]),\n            \"family-names\": names[-1],\n        }\n        if \"email\" in person:\n            person_obj[\"email\"] = person[\"email\"].strip()\n        if \"url\" in person:\n            person_obj[\"orcid\"] = person[\"url\"].strip()\n        return Person(**person_obj)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync package.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = self._sync_person_list(self.contributors, metadata.people)\n        self.repository = {\"type\": \"git\", \"url\": metadata.repository}\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the package.json file as list.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the package.json file.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>package.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n):\n\"\"\"package.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings = {\n        \"authors\": [\"author\"],\n    }\n    super().__init__(path, create_if_not_exists=False, direct_mappings=mappings)\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the package.json file.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the package.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving package.json to {path}\")\n\n    with path.open(\"w\") as f:\n        # package.json indentation is 2 spaces\n        json.dump(self._data, f, indent=2)\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync package.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n\"\"\"Sync package.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = self._sync_person_list(self.contributors, metadata.people)\n    self.repository = {\"type\": \"git\", \"url\": metadata.repository}\n</code></pre>"},{"location":"reference/somesy/pyproject/","title":"pyproject","text":"<p>Pyproject module.</p>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Poetry","title":"Poetry","text":"<p>             Bases: <code>PyprojectCommon</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Poetry(PyprojectCommon):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(self, path: Path):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(path, section=[\"tool\", \"poetry\"], model_cls=PoetryConfig)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return f\"{person.full_name} &lt;{person.email}&gt;\"\n\n    @staticmethod\n    def _to_person(person_obj: str) -&gt; Person:\n\"\"\"Parse poetry person string to a Person.\"\"\"\n        m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", person_obj)\n        names, mail = (\n            list(map(lambda s: s.strip(), m.group(1).split())),\n            m.group(2).strip(),\n        )\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n                \"email\": mail,\n            }\n        )\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.writer.Poetry.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(path, section=[\"tool\", \"poetry\"], model_cls=PoetryConfig)\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.SetupTools","title":"SetupTools","text":"<p>             Bases: <code>PyprojectCommon</code></p> <p>Setuptools config file handler parsed from setup.cfg.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class SetupTools(PyprojectCommon):\n\"\"\"Setuptools config file handler parsed from setup.cfg.\"\"\"\n\n    def __init__(self, path: Path):\n\"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        section = [\"project\"]\n        mappings = {\n            \"homepage\": [\"urls\", \"homepage\"],\n            \"repository\": [\"urls\", \"repository\"],\n        }\n        super().__init__(\n            path, section=section, direct_mappings=mappings, model_cls=SetuptoolsConfig\n        )\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to setuptools dict for person format.\"\"\"\n        return {\"name\": person.full_name, \"email\": person.email}\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Person:\n\"\"\"Parse setuptools person string to a Person.\"\"\"\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        names = list(map(lambda s: s.strip(), person_obj[\"name\"].split()))\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n                \"email\": person_obj[\"email\"].strip(),\n            }\n        )\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.writer.SetupTools.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Setuptools config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    section = [\"project\"]\n    mappings = {\n        \"homepage\": [\"urls\", \"homepage\"],\n        \"repository\": [\"urls\", \"repository\"],\n    }\n    super().__init__(\n        path, section=section, direct_mappings=mappings, model_cls=SetuptoolsConfig\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Pyproject","title":"Pyproject","text":"<p>             Bases: <code>wrapt.ObjectProxy</code></p> <p>Class for syncing pyproject file with other metadata files.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Pyproject(wrapt.ObjectProxy):\n\"\"\"Class for syncing pyproject file with other metadata files.\"\"\"\n\n    __wrapped__: Union[SetupTools, Poetry]\n\n    def __init__(self, path: Path):\n\"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n        Args:\n            path (Path): Path to pyproject.toml file.\n\n        Raises:\n            FileNotFoundError: Raised when pyproject.toml file is not found.\n            ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n        \"\"\"\n        data = None\n        if not path.is_file():\n            raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n        with open(path, \"r\") as f:\n            data = load(f)\n\n        # inspect file to pick suitable project metadata writer\n        if \"project\" in data:\n            logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n            self.__wrapped__ = SetupTools(path)\n        elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n            logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n            self.__wrapped__ = Poetry(path)\n        else:\n            msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n            raise ValueError(msg)\n\n        super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.writer.Pyproject.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Pyproject wrapper class. Wraps either setuptools or poetry.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to pyproject.toml file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised when pyproject.toml file is not found.</p> <code>ValueError</code> <p>Neither project nor tool.poetry object is found in pyproject.toml file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n    Args:\n        path (Path): Path to pyproject.toml file.\n\n    Raises:\n        FileNotFoundError: Raised when pyproject.toml file is not found.\n        ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n    \"\"\"\n    data = None\n    if not path.is_file():\n        raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n    with open(path, \"r\") as f:\n        data = load(f)\n\n    # inspect file to pick suitable project metadata writer\n    if \"project\" in data:\n        logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n        self.__wrapped__ = SetupTools(path)\n    elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n        logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n        self.__wrapped__ = Poetry(path)\n    else:\n        msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n        raise ValueError(msg)\n\n    super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/models/","title":"models","text":"<p>Pyproject models.</p>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig","title":"PoetryConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Poetry configuration model.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class PoetryConfig(BaseModel):\n\"\"\"Poetry configuration model.\"\"\"\n\n    name: Annotated[str, Field(regex=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\")]\n    version: Annotated[\n        str, Field(regex=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\")\n    ]\n    description: str\n    license: Optional[Union[LicenseEnum, List[LicenseEnum]]] = Field(\n        None, description=\"An SPDX license identifier.\"\n    )\n    authors: Set[str]\n    maintainers: Optional[Set[str]] = None\n    readme: Optional[Union[Path, List[Path]]] = None\n    homepage: Optional[HttpUrl] = None\n    repository: Optional[HttpUrl] = None\n    documentation: Optional[HttpUrl] = None\n    keywords: Optional[Set[str]] = None\n    classifiers: Optional[List[str]] = None\n    urls: Optional[Dict[str, HttpUrl]] = None\n\n    @validator(\"version\")\n    def validate_version(cls, v):\n\"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError:\n            raise ValidationError(\"Invalid version\")\n        return v\n\n    @validator(\"authors\", \"maintainers\")\n    def validate_email_format(cls, v):\n\"\"\"Validate email format.\"\"\"\n        for author in v:\n            if (\n                not isinstance(author, str)\n                or \" \" not in author\n                or not EmailStr.validate(author.split(\" \")[-1][1:-1])\n            ):\n                raise ValidationError(\"Invalid email format\")\n        return v\n\n    @validator(\"readme\")\n    def validate_readme(cls, v):\n\"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n        if type(v) is list:\n            if any(not e.is_file() for e in v):\n                raise ValidationError(\"Some file(s) do not exist\")\n        else:\n            if not v.is_file():\n                raise ValidationError(\"File does not exist\")\n\n    class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n        use_enum_values = True\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.Config","title":"Config","text":"<p>Pydantic configuration.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n    use_enum_values = True\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_version","title":"validate_version","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"version\")\ndef validate_version(cls, v):\n\"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError:\n        raise ValidationError(\"Invalid version\")\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_email_format","title":"validate_email_format","text":"<pre><code>validate_email_format(v)\n</code></pre> <p>Validate email format.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"authors\", \"maintainers\")\ndef validate_email_format(cls, v):\n\"\"\"Validate email format.\"\"\"\n    for author in v:\n        if (\n            not isinstance(author, str)\n            or \" \" not in author\n            or not EmailStr.validate(author.split(\" \")[-1][1:-1])\n        ):\n            raise ValidationError(\"Invalid email format\")\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_readme","title":"validate_readme","text":"<pre><code>validate_readme(v)\n</code></pre> <p>Validate readme file(s) by checking whether files exist.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"readme\")\ndef validate_readme(cls, v):\n\"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n    if type(v) is list:\n        if any(not e.is_file() for e in v):\n            raise ValidationError(\"Some file(s) do not exist\")\n    else:\n        if not v.is_file():\n            raise ValidationError(\"File does not exist\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.ContentTypeEnum","title":"ContentTypeEnum","text":"<p>             Bases: <code>Enum</code></p> <p>Content type enum for setuptools field file.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class ContentTypeEnum(Enum):\n\"\"\"Content type enum for setuptools field file.\"\"\"\n\n    plain = \"text/plain\"\n    rst = \"text/x-rst\"\n    markdown = \"text/markdown\"\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.File","title":"File","text":"<p>             Bases: <code>BaseModel</code></p> <p>File model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class File(BaseModel):\n\"\"\"File model for setuptools.\"\"\"\n\n    file: Path\n    content_type: Optional[ContentTypeEnum] = Field(alias=\"content-type\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.License","title":"License","text":"<p>             Bases: <code>BaseModel</code></p> <p>License model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class License(BaseModel):\n\"\"\"License model for setuptools.\"\"\"\n\n    file: Optional[Path]\n    text: Optional[LicenseEnum]\n\n    class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n        validate_assignment = True\n\n    @root_validator(pre=True)\n    def validate_xor(cls, values):\n\"\"\"Validate that only one of file or text is set.\"\"\"\n        if sum([bool(v) for v in values.values()]) != 1:\n            raise ValueError(\"Either file or text must be set.\")\n        return values\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.License.Config","title":"Config","text":"<p>Pydantic configuration.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n    validate_assignment = True\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.License.validate_xor","title":"validate_xor","text":"<pre><code>validate_xor(values)\n</code></pre> <p>Validate that only one of file or text is set.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@root_validator(pre=True)\ndef validate_xor(cls, values):\n\"\"\"Validate that only one of file or text is set.\"\"\"\n    if sum([bool(v) for v in values.values()]) != 1:\n        raise ValueError(\"Either file or text must be set.\")\n    return values\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.STPerson","title":"STPerson","text":"<p>             Bases: <code>BaseModel</code></p> <p>Person model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class STPerson(BaseModel):\n\"\"\"Person model for setuptools.\"\"\"\n\n    name: Annotated[str, Field(min_length=1)]\n    email: Annotated[str, Field(min_length=1)]\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.URLs","title":"URLs","text":"<p>             Bases: <code>BaseModel</code></p> <p>URLs model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class URLs(BaseModel):\n\"\"\"URLs model for setuptools.\"\"\"\n\n    homepage: Optional[HttpUrl] = None\n    repository: Optional[HttpUrl] = None\n    documentation: Optional[HttpUrl] = None\n    changelog: Optional[HttpUrl] = None\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig","title":"SetuptoolsConfig","text":"<p>             Bases: <code>BaseModel</code></p> <p>Setuptools input model. Required fields are name, version, description, and requires_python.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class SetuptoolsConfig(BaseModel):\n\"\"\"Setuptools input model. Required fields are name, version, description, and requires_python.\"\"\"\n\n    name: Annotated[str, Field(regex=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\")]\n    version: Annotated[\n        str, Field(regex=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\")\n    ]\n    description: str\n    readme: Optional[Union[Path, List[Path], File]] = None\n    license: Optional[Union[LicenseEnum, List[LicenseEnum]]] = Field(\n        None, description=\"An SPDX license identifier.\"\n    )\n    authors: Optional[List[STPerson]]\n    maintainers: Optional[List[STPerson]]\n    keywords: Optional[Set[str]]\n    classifiers: Optional[List[str]]\n    urls: Optional[URLs]\n\n    @validator(\"version\")\n    def validate_version(cls, v):\n\"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError:\n            raise ValidationError(\"Invalid version\")\n        return v\n\n    @validator(\"readme\")\n    def validate_readme(cls, v):\n\"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n        if type(v) is list:\n            if any(not e.is_file() for e in v):\n                raise ValidationError(\"Some file(s) do not exist\")\n        elif type(v) is File:\n            if not Path(v.file).is_file():\n                raise ValidationError(\"File does not exist\")\n        else:\n            if not v.is_file():\n                raise ValidationError(\"File does not exist\")\n\n    @validator(\"authors\", \"maintainers\")\n    def validate_email_format(cls, v):\n\"\"\"Validate email format.\"\"\"\n        for person in v:\n            if person.email:\n                if not EmailStr.validate(person.email):\n                    raise ValidationError(\"Invalid email format\")\n        return v\n\n    class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n        use_enum_values = True\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.Config","title":"Config","text":"<p>Pydantic configuration.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class Config:\n\"\"\"Pydantic configuration.\"\"\"\n\n    use_enum_values = True\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_version","title":"validate_version","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"version\")\ndef validate_version(cls, v):\n\"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError:\n        raise ValidationError(\"Invalid version\")\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_readme","title":"validate_readme","text":"<pre><code>validate_readme(v)\n</code></pre> <p>Validate readme file(s) by checking whether files exist.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"readme\")\ndef validate_readme(cls, v):\n\"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n    if type(v) is list:\n        if any(not e.is_file() for e in v):\n            raise ValidationError(\"Some file(s) do not exist\")\n    elif type(v) is File:\n        if not Path(v.file).is_file():\n            raise ValidationError(\"File does not exist\")\n    else:\n        if not v.is_file():\n            raise ValidationError(\"File does not exist\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_email_format","title":"validate_email_format","text":"<pre><code>validate_email_format(v)\n</code></pre> <p>Validate email format.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@validator(\"authors\", \"maintainers\")\ndef validate_email_format(cls, v):\n\"\"\"Validate email format.\"\"\"\n    for person in v:\n        if person.email:\n            if not EmailStr.validate(person.email):\n                raise ValidationError(\"Invalid email format\")\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/","title":"writer","text":"<p>Pyproject writers for setuptools and poetry.</p>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon","title":"PyprojectCommon","text":"<p>             Bases: <code>ProjectMetadataWriter</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class PyprojectCommon(ProjectMetadataWriter):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(\n        self, path: Path, *, section: List[str], model_cls, direct_mappings=None\n    ):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._model_cls = model_cls\n        self._section = section\n        super().__init__(\n            path, create_if_not_exists=False, direct_mappings=direct_mappings or {}\n        )\n\n    def _load(self) -&gt; None:\n\"\"\"Load pyproject.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n\"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {self._model_cls.__name__}: {pretty_repr(config)}\"\n        )\n        self._model_cls(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the pyproject file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    def _get_property(self, key: Union[str, List[str]]) -&gt; Optional[Any]:\n\"\"\"Get a property from the pyproject.toml file.\"\"\"\n        key_path = [key] if isinstance(key, str) else key\n        full_path = self._section + key_path\n        return super()._get_property(full_path)\n\n    def _set_property(self, key: Union[str, List[str]], value: Any) -&gt; None:\n\"\"\"Set a property in the pyproject.toml file.\"\"\"\n        key_path = [key] if isinstance(key, str) else key\n        # get the tomlkit object of the section\n        dat = self._get_property([])\n        # dig down, create missing nested objects on the fly\n        curr = dat\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr.add(key, tomlkit.table())\n            curr = curr[key]\n        curr[key_path[-1]] = value\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    *,\n    section: List[str],\n    model_cls: List[str],\n    direct_mappings: List[str] = None\n)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(\n    self, path: Path, *, section: List[str], model_cls, direct_mappings=None\n):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._model_cls = model_cls\n    self._section = section\n    super().__init__(\n        path, create_if_not_exists=False, direct_mappings=direct_mappings or {}\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the pyproject file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n\"\"\"Save the pyproject file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Poetry","title":"Poetry","text":"<p>             Bases: <code>PyprojectCommon</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Poetry(PyprojectCommon):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(self, path: Path):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(path, section=[\"tool\", \"poetry\"], model_cls=PoetryConfig)\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return f\"{person.full_name} &lt;{person.email}&gt;\"\n\n    @staticmethod\n    def _to_person(person_obj: str) -&gt; Person:\n\"\"\"Parse poetry person string to a Person.\"\"\"\n        m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", person_obj)\n        names, mail = (\n            list(map(lambda s: s.strip(), m.group(1).split())),\n            m.group(2).strip(),\n        )\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n                \"email\": mail,\n            }\n        )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Poetry.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(path, section=[\"tool\", \"poetry\"], model_cls=PoetryConfig)\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.SetupTools","title":"SetupTools","text":"<p>             Bases: <code>PyprojectCommon</code></p> <p>Setuptools config file handler parsed from setup.cfg.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class SetupTools(PyprojectCommon):\n\"\"\"Setuptools config file handler parsed from setup.cfg.\"\"\"\n\n    def __init__(self, path: Path):\n\"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        section = [\"project\"]\n        mappings = {\n            \"homepage\": [\"urls\", \"homepage\"],\n            \"repository\": [\"urls\", \"repository\"],\n        }\n        super().__init__(\n            path, section=section, direct_mappings=mappings, model_cls=SetuptoolsConfig\n        )\n\n    @staticmethod\n    def _from_person(person: Person):\n\"\"\"Convert project metadata person object to setuptools dict for person format.\"\"\"\n        return {\"name\": person.full_name, \"email\": person.email}\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Person:\n\"\"\"Parse setuptools person string to a Person.\"\"\"\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        names = list(map(lambda s: s.strip(), person_obj[\"name\"].split()))\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n                \"email\": person_obj[\"email\"].strip(),\n            }\n        )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.SetupTools.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Setuptools config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    section = [\"project\"]\n    mappings = {\n        \"homepage\": [\"urls\", \"homepage\"],\n        \"repository\": [\"urls\", \"repository\"],\n    }\n    super().__init__(\n        path, section=section, direct_mappings=mappings, model_cls=SetuptoolsConfig\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Pyproject","title":"Pyproject","text":"<p>             Bases: <code>wrapt.ObjectProxy</code></p> <p>Class for syncing pyproject file with other metadata files.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Pyproject(wrapt.ObjectProxy):\n\"\"\"Class for syncing pyproject file with other metadata files.\"\"\"\n\n    __wrapped__: Union[SetupTools, Poetry]\n\n    def __init__(self, path: Path):\n\"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n        Args:\n            path (Path): Path to pyproject.toml file.\n\n        Raises:\n            FileNotFoundError: Raised when pyproject.toml file is not found.\n            ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n        \"\"\"\n        data = None\n        if not path.is_file():\n            raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n        with open(path, \"r\") as f:\n            data = load(f)\n\n        # inspect file to pick suitable project metadata writer\n        if \"project\" in data:\n            logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n            self.__wrapped__ = SetupTools(path)\n        elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n            logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n            self.__wrapped__ = Poetry(path)\n        else:\n            msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n            raise ValueError(msg)\n\n        super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Pyproject.__init__","title":"__init__","text":"<pre><code>__init__(path: Path)\n</code></pre> <p>Pyproject wrapper class. Wraps either setuptools or poetry.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to pyproject.toml file.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised when pyproject.toml file is not found.</p> <code>ValueError</code> <p>Neither project nor tool.poetry object is found in pyproject.toml file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path):\n\"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n    Args:\n        path (Path): Path to pyproject.toml file.\n\n    Raises:\n        FileNotFoundError: Raised when pyproject.toml file is not found.\n        ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n    \"\"\"\n    data = None\n    if not path.is_file():\n        raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n    with open(path, \"r\") as f:\n        data = load(f)\n\n    # inspect file to pick suitable project metadata writer\n    if \"project\" in data:\n        logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n        self.__wrapped__ = SetupTools(path)\n    elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n        logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n        self.__wrapped__ = Poetry(path)\n    else:\n        msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n        raise ValueError(msg)\n\n    super().__init__(self.__wrapped__)\n</code></pre>"}]}