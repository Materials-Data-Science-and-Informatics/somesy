{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#somesy","title":"somesy","text":"<p>Somesy (software metadata sync) is a CLI tool to avoid messy software project metadata by keeping it in sync.</p>"},{"location":"#description","title":"Description","text":"<p>Many development tools either declare or need information about the software project they are used in, such as: the project name, description, version, repository url, license or project authors. Most such tools come with configuration files and conventions that are specific to the programming language or chosen technology. Emerging best practices for FAIR software metadata require to add even more files where such metadata must be stated.</p> <p>If good project metadata was a fire-and-forget issue, this would be acceptable, but software is never standing still - maintainers change, contributors come and go, the version number is regularly increased, the project might be moved to a different location. Properly maintaining this kind of information in various files scattered around the project is usually tedious, error-prone and time consuming manual labor.</p> <p>Somesy automates the synchronization of software project metadata and frees your time to focus on your actual work.</p>"},{"location":"#usage","title":"Usage","text":"<p>To get started, please check out the quickstart guide.</p>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>If you want to cite this project in your scientific work, please use the citation file in the repository.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>We kindly thank all authors and contributors.</p> <p></p> <p>This project was developed at the Institute for Materials Data Science and Informatics (IAS-9) of the J\u00fclich Research Center and funded by the Helmholtz Metadata Collaboration (HMC), an incubator-platform of the Helmholtz Association within the framework of the Information and Data Science strategic initiative.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>Here we provide notes that summarize the most important changes in each released version.</p> <p>Please consult the changelog to inform yourself about breaking changes and security issues.</p>"},{"location":"changelog/#0.7.0","title":"v0.7.0 (2025-xx-xx)","text":"<ul> <li>make validation of output files, such as pyproject.toml, optional</li> <li>make somesy project metadata input <code>version</code> optional</li> <li>multiple output file support</li> <li>enable having packages support</li> <li>fix: package.json url set error on None value</li> </ul>"},{"location":"changelog/#0.6.0","title":"v0.6.0 (2025-02-14)","text":"<ul> <li>implement CFF Entity (Organization) model for author/maintainer/contributor</li> <li>add a new config option to use existing codemeta.json when syncing</li> <li>fix SomesyBaseModel kwargs being overwritten</li> </ul>"},{"location":"changelog/#0.5.0","title":"v0.5.0 (2025-01-15)","text":"<ul> <li>make person (and entity) argument email optional</li> </ul>"},{"location":"changelog/#0.4.3","title":"v0.4.3 (2024-07-29)","text":"<ul> <li>update python dependencies</li> <li>update pre-commit hook versions</li> <li>fix package.json person validation</li> <li>update poetry, julia, and package.json person validation: entries without an email wont't raise an error, they will be ignored.</li> </ul>"},{"location":"changelog/#0.4.2","title":"v0.4.2 (2024-04-30)","text":"<ul> <li>fix rich logging bug for error messages and tracebacks</li> </ul>"},{"location":"changelog/#0.4.1","title":"v0.4.1 (2024-04-08)","text":"<ul> <li>fix package.json and mkdocs.yml validation bug about optional fields</li> </ul>"},{"location":"changelog/#0.4.0","title":"v0.4.0 (2024-03-08)","text":"<ul> <li>added separate <code>documentation</code> URL to Project metadata model</li> <li>added support for Julia <code>Project.toml</code> file</li> <li>added support for Fortran <code>fpm.toml</code> file</li> <li>added support for Java <code>pom.xml</code> file</li> <li>added support for MkDocs <code>mkdocs.yml</code> file</li> <li>added support for Rust <code>Cargo.toml</code> file</li> </ul>"},{"location":"changelog/#0.3.1","title":"v0.3.1 (2024-01-23)","text":"<ul> <li>fix setuptools license writing bug</li> </ul>"},{"location":"changelog/#0.3.0","title":"v0.3.0 (2024-01-12)","text":"<ul> <li>replace codemetapy with an in-house writer, which enables windows support</li> </ul>"},{"location":"changelog/#0.2.1","title":"v0.2.1 (2023-11-29)","text":"<ul> <li>internal: updated linters and dependencies</li> <li>internal: pin codemetapy version to 2.5.2 to avoid breaking changes</li> <li>fix bug caused by missing <code>config</code> section</li> </ul>"},{"location":"changelog/#0.2.0","title":"v0.2.0 (2023-11-29)","text":"<ul> <li>internal: Test refactoring</li> <li>internal: Pydantic 2 implementation</li> <li>Added <code>publication_author</code> field to Person model</li> </ul>"},{"location":"changelog/#0.1.0","title":"v0.1.0 (2023-08-10)","text":"<ul> <li>First release</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project maintainers by e-mail. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"How To Contribute","text":"<p>All kinds of contributions are very welcome! You can contribute in various ways, e.g. by</p> <ul> <li>providing feedback</li> <li>asking questions</li> <li>suggesting ideas</li> <li>implementing features</li> <li>fixing problems</li> <li>improving documentation</li> </ul> <p>To make contributing to open source projects a good experience to everyone involved, please make sure that you follow our code of conduct when communicating with others.</p>"},{"location":"contributing/#ideas-questions-and-problems","title":"Ideas, Questions and Problems","text":"<p>If you have questions or difficulties using this software, please use the issue tracker.</p> <p>If your topic is not already covered by an existing issue, please create a new issue using one of the provided issue templates.</p> <p>If your issue is caused by incomplete, unclear or outdated documentation, we are also happy to get suggestions on how to improve it. Outdated or incorrect documentation is a bug, while missing documentation is a feature request.</p> <p>NOTE: If you want to report a critical security problem, do not open an issue! Instead, please create a private security advisory, or contact the current package maintainers directly by e-mail.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>This project uses Poetry for dependency management.</p> <p>You can run the following lines to check out the project and prepare it for development:</p> <pre><code>git clone git@github.com:Materials-Data-Science-and-Informatics/somesy.git\ncd somesy\npoetry install --with docs\npoetry run poe init-dev\n</code></pre> <p>Common tasks are accessible via poe:</p> <ul> <li> <p>Use <code>poetry run poe lint</code> to run linters manually, add <code>--all-files</code> to check everything.</p> </li> <li> <p>Use <code>poetry run poe test</code> to run tests, add <code>--cov</code> to also show test coverage.</p> </li> <li> <p>Use <code>poetry run poe docs</code> to generate local documentation</p> </li> </ul> <p>In order to contribute code, please open a pull request to the <code>dev</code> branch.</p> <p>Before opening the PR, please make sure that your changes</p> <ul> <li>are sufficiently covered by meaningful tests,</li> <li>are reflected in suitable documentation (API docs, guides, etc.), and</li> <li>successfully pass all pre-commit hooks.</li> </ul>"},{"location":"coverage/","title":"Coverage Report","text":""},{"location":"credits/","title":"Authors and Contributors","text":"<p>Authors are people whose contributions significantly shaped the state of <code>somesy</code> at some point in time.</p> <p>Additional contributors are people who contributed non-trivially to this project in different ways, e.g. by providing smaller fixes and enhancements to the code and/or documentation.</p> <p>Of course, this is just a rough overview and categorization. For a more complete overview of all contributors and contributions, please inspect the git history of this repository.</p>"},{"location":"credits/#authors","title":"Authors","text":"<ul> <li>Mustafa Soylu (   E-Mail,   ORCID   ): Main developer, maintainer and tester.</li> <li>Anton Pirogov (   E-Mail,   ORCID   ): Concepts, tool development and enhancement, documentation.</li> </ul>"},{"location":"credits/#additional-contributors","title":"Additional Contributors","text":"<ul> <li>Jens Br\u00f6der (   E-Mail,   ORCID   ): Discussions and suggestions concerning metadata standards and usability.</li> <li>Volker Hofmann (   E-Mail,   ORCID   ): Discussions and suggestions concerning tool scope and usability.</li> <li>Stefan Sandfeld (   E-Mail,   ORCID   )</li> </ul> <p>... maybe you?</p>"},{"location":"dev_guide/","title":"Developer Guide","text":"<p>This guide is targeting mainly developers, maintainers and other technical contributors and provides more information on how to work with this repository.</p>"},{"location":"dev_guide/#overview","title":"Overview","text":""},{"location":"dev_guide/#repository-structure","title":"Repository Structure","text":"<p>Here is a non-exhaustive list of the most important files and directories in the repository.</p> <p>General:</p> <ul> <li><code>AUTHORS.md</code>: acknowledges and lists all contributors</li> <li><code>CHANGELOG.md</code>: summarizes the changes for each version of the software for users</li> <li><code>CODE_OF_CONDUCT.md</code>: defines the social standards that must be followed by contributors</li> <li><code>CONTRIBUTING.md</code>: explains  how others can contribute to the project</li> <li><code>README.md</code>: provides an overview and points to other resources</li> </ul> <p>Metadata:</p> <ul> <li><code>CITATION.cff</code>: metadata stating how to cite the project</li> <li><code>codemeta.json</code>: metadata for harvesting by other tools and services</li> <li><code>LICENSE</code>: the (main) license of the project</li> <li><code>LICENSES</code>: copies of all licenses that apply to files in the project</li> <li><code>.reuse/dep5</code>: granular license and copyright information for all files and directories</li> </ul> <p>Development:</p> <ul> <li><code>pyproject.toml</code>: project metadata, dependencies, development tool configurations</li> <li><code>poetry.lock</code>: needed for reproducible installation of the project</li> <li><code>src</code>: actual code provided by the project</li> <li><code>tests</code>: all tests for the code in the project</li> <li><code>mkdocs.yml</code>: configuration of the project website</li> <li><code>docs</code>: most contents used for the project website</li> </ul> <p>Automation and Quality Control:</p> <ul> <li><code>.pre-commit-config.yaml</code>: quality assurance tools used in the project</li> <li><code>.github/workflows</code>: CI scripts for GitHub (QA, documentation and package deployment)</li> <li><code>.github/ISSUE_TEMPLATE</code>: templates for the GitHub issue tracker</li> <li><code>.gitlab-ci.yml</code>: mostly equivalent CI scripts, but for GitLab</li> <li><code>.gitlab/issue_templates</code>: The same issues templates, but for GitLab</li> </ul>"},{"location":"dev_guide/#used-tools","title":"Used Tools","text":"<p>Here is a non-exhaustive list of the most important tools used in the project.</p> <p>Best practices for modern Python development are implemented by using:</p> <ul> <li><code>poetry</code> for dependency management and packaging</li> <li><code>pytest</code> for unit testing</li> <li><code>hypothesis</code> for property-based testing</li> <li><code>pre-commit</code> for orchestrating linters, formatters and other utilities</li> <li><code>ruff</code> for source-code formatting and for general linting</li> <li><code>pydocstyle</code> for checking docstring conventions</li> <li><code>interrogate</code> for computing docstring coverage</li> <li><code>mypy</code> for editor-independent type-checking</li> <li><code>mkdocs</code> for generating the project documentation website</li> <li><code>bandit</code> for checking security issues in the code</li> <li><code>safety</code> for checking security issues in the current dependencies</li> </ul> <p>Metadata best practices for FAIR software are implemented using:</p> <ul> <li><code>cffconvert</code> to check the <code>CITATION.cff</code> (citation metadata)</li> <li><code>codemetapy</code> to generate a <code>codemeta.json</code> (general software metadata)</li> <li><code>reuse</code> to check REUSE-compliance (granular copyright and license metadata)</li> <li><code>licensecheck</code> to scan for possible license incompatibilities in the dependencies</li> </ul>"},{"location":"dev_guide/#basics","title":"Basics","text":"<p>The project</p> <ul> <li>heavily uses <code>pyproject.toml</code>, which is a recommended standard</li> <li>adopts the <code>src</code> layout, to avoid common problems</li> <li>keeps the actual code (<code>src</code>) and test code (<code>tests</code>) separated</li> </ul> <p>The <code>pyproject.toml</code> is the main configuration file for the project. It contains both general information about the software as well as configuration for various tools.</p> <p>In older software, most of this information is often scattered over many little tool-specific configuration files and a <code>setup.py</code>, <code>setup.cfg</code> and/or <code>requirements.txt</code> file.</p> <p>In this project, <code>pyproject.toml</code> is the first place that should be checked when looking for the configuration of some development tool.</p>"},{"location":"dev_guide/#configuration","title":"Configuration","text":"<p>The main tool needed to manage and configure the project is Poetry.</p> <p>Please follow its setup documentation to install it correctly. Poetry should not be installed with <code>pip</code> like other Python tools.</p> <p>Poetry performs many important tasks:</p> <ul> <li>it manages the virtual environment(s) used for the project</li> <li>it manages all the dependencies needed for the code to work</li> <li>it takes care of packaging the code into a <code>pip</code>-installable package</li> </ul> <p>You can find a cheatsheet with the most important commands here and consult its official documentation for detailed information.</p> <p>Note that <code>poetry</code> is only needed for development of the repository. The end-users who just want to install and use this project do not need to set up or know anything about poetry.</p> <p>Note that if you use <code>poetry shell</code> and the project is installed with <code>poetry install</code>, in the following you do not have to prepend <code>poetry run</code> to commands you will see below.</p>"},{"location":"dev_guide/#task-runner","title":"Task Runner","text":"<p>It is a good practice to have a common way for launching different project-related tasks. It removes the need of remembering flags for various tools, and avoids duplication of the same commands in the CI pipelines. If something in a workflow needs to change, it can be changed in just one place, thus reducing the risk of making a mistake.</p> <p>Often projects use a shell script or <code>Makefile</code> for this purpose. This project uses poethepoet, as it integrates nicely with <code>poetry</code>. The tasks are defined in <code>pyproject.toml</code> and can be launched using:</p> <pre><code>poetry run poe TASK_NAME\n</code></pre>"},{"location":"dev_guide/#ci-workflows","title":"CI Workflows","text":"<p>The project contains CI workflows for both GitHub and GitLab.</p> <p>The main CI pipeline runs on each new pushed commit and will</p> <ol> <li>Run all configured code analysis tools,</li> <li>Run code tests with multiple versions of Python,</li> <li>build and deploy the online project documentation website, and</li> <li>if a new version tag was pushed, launch the release workflow</li> </ol>"},{"location":"dev_guide/#quality-control","title":"Quality Control","text":""},{"location":"dev_guide/#static-analysis","title":"Static Analysis","text":"<p>Except for code testing, most tools for quality control are added to the project as <code>pre-commit</code> hooks. The <code>pre-commit</code> tool takes care of installing, updating and running the tools according to the configuration in the <code>.pre-commit-config.yaml</code> file.</p> <p>For every new copy of the repository (e.g. after <code>git clone</code>), <code>pre-commit</code> first must be activated. This is usually done using <code>pre-commit install</code>, which also requires that <code>pre-commit</code> is already available. For more convenience, we simplified the procedure.</p> <p>In this project, you can run:</p> <pre><code>poetry run poe init-dev\n</code></pre> <p>This will make sure that <code>pre-commit</code> is enabled in your repository copy.</p> <p>Once enabled, every time you try to <code>git commit</code> some changed files various tools will run on those (and only those) files.</p> <p>This means that (with some exceptions) <code>pre-commit</code> by default will run only on the changed files that were added to the next commit (i.e., files in the git staging area). These files are usually colored in green when running <code>git status</code>.</p> <ul> <li>Some tools only report the problems they detected</li> <li>Some tools actively modify files (e.g., fix formatting)</li> </ul> <p>In any case, the <code>git commit</code> will fail if a file was modified by a tool, or some problems were reported. In order to complete the commit, you need to</p> <ul> <li>resolve all problems (by fixing them or marking them as false alarm), and</li> <li><code>git add</code> all changed files again (to update the files in the staging area).</li> </ul> <p>After doing that, you can retry to <code>git commit</code> your changes.</p> <p>To avoid having to deal with many issues at once, it is a good habit to run <code>pre-commit</code> by hand from time to time. In this project, this can be done with:</p> <pre><code>poetry run poe lint --all-files\n</code></pre>"},{"location":"dev_guide/#testing","title":"Testing","text":"<p>pytest is used as the main framework for testing.</p> <p>The project uses the <code>pytest-cov</code> plugin to integrate <code>pytest</code> with <code>coverage</code>, which collects and reports test coverage information.</p> <p>In addition to writing regular unit tests with <code>pytest</code>, consider using hypothesis, which integrates nicely with <code>pytest</code> and implements property-based testing - which involves automatic generation of randomized inputs for test cases. This can help to find bugs often found for various edge cases that are easy to overlook in ad-hoc manual tests. Such randomized tests can be a good addition to hand-crafted tests and inputs.</p> <p>To run all tests, either invoke <code>pytest</code> directly, or use the provided task:</p> <pre><code>poetry run poe test\n</code></pre>"},{"location":"dev_guide/#documentation","title":"Documentation","text":"<p>The project uses <code>mkdocs</code> with the popular and excellent <code>mkdocs-material</code> theme to generate the project documentation website, which provides both user and developer documentation.</p> <p><code>mkdocs</code> is configured in the <code>mkdocs.yml</code> file, which we prepared in a way that there is</p> <ul> <li>no need to duplicate sections from files in other places (such as <code>README.md</code>)</li> <li>fully automatic API documentation pages based on Python docstrings in the code</li> <li>a detailed test coverage report is included in the website</li> </ul> <p>The first point is important, because avoiding duplication means avoiding errors whenever text or examples are updated. The second point is convenient, as modules and functions do not need to be added by hand, which is easy to forget. The third point removes the need to use an external service such as CodeCov to store and present code coverage information.</p> <p>As software changes over time and users cannot always keep up with the latest developments, each new version of the software should provide version-specific documentation. To make this both possible as well as convenient, this project uses <code>mike</code> to generate and manage the <code>mkdocs</code> documentation for different versions of the software.</p>"},{"location":"dev_guide/#online-documentation","title":"Online Documentation","text":"<p>To avoid dependence on additional services such as readthedocs, the project website is deployed using GitHub Pages.</p> <p>The provided CI pipeline automatically generates the documentation for the latest development version (i.e., current state of the <code>main</code> branch) as well as every released version (i.e., marked by a version tag <code>vX.Y.Z</code>).</p>"},{"location":"dev_guide/#offline-documentation","title":"Offline Documentation","text":"<p>You can manually generate a local and fully offline copy of the documentation, which can be useful for e.g. previewing the results during active work on the documentation:</p> <pre><code>poetry install --with docs\npoetry run poe docs\n</code></pre> <p>Once the documentation site is built, run <code>mkdocs serve</code> and open <code>https://localhost:8000</code> in your browser to see the local copy of the website.</p>"},{"location":"dev_guide/#releases","title":"Releases","text":"<p>From time to time the project is ready for a new release for users.</p>"},{"location":"dev_guide/#creating-a-new-release","title":"Creating a New Release","text":"<p>Before releasing a new version, push the commit the new release should be based on to the upstream repository, and make sure that:</p> <ul> <li>the CI pipeline completes successfully</li> <li>the version number in <code>pyproject.toml</code> is updated, in particular:</li> <li>it must be larger than the previous released version</li> <li>it should adequately reflect the severity of changes</li> <li>the provided user and developer documentation is up-to-date, including:</li> <li>a new section in the <code>CHANGELOG.md</code> file summarizing changes in the new version</li> <li>possibly revised information about contributors and/or maintainers</li> </ul> <p>If this is the case, proceed with the release by:</p> <ul> <li>creating a new tag that matches the version in the <code>pyproject.toml</code>: <code>git tag vX.Y.Z</code></li> <li>pushing the new tag to the upstream repository: <code>git push origin vX.Y.Z</code></li> </ul> <p>The pushed version tag will trigger a pipeline that will:</p> <ul> <li>build and deploy the documentation website for the specific version</li> <li>publish the package to enabled targets (see below)</li> </ul>"},{"location":"dev_guide/#release-targets","title":"Release Targets","text":"<p>Targets for releases can be enabled or disabled in <code>.github/workflows/ci.yml</code> and configured by adapting the corresponding actions in <code>.github/workflows/releases.yml</code>.</p>"},{"location":"dev_guide/#github-release","title":"Github Release","text":"<p>By default, the release workflow will create a basic Github Release that provides a snapshot of the repository as a download. This requires no additional configuration.</p> <p>See here for information on how the Github release can be customized.</p> <p>Note that this release target is mostly for demonstration purposes. For most Python projects, using PyPI is the recommended primary distribution method.</p>"},{"location":"dev_guide/#pypi-and-compatible-package-indices","title":"PyPI (and compatible package indices)","text":"<p>For releases to PyPI and Test PyPI the project uses the new Trusted Publishers workflow that is both more secure and convenient to use than other authorization methods.</p> <p>Before the project can be released to PyPI or Test PyPI the first time, first a pending publisher must be added in the PyPI account of the main project maintainer, using <code>release.yml</code> as the requested workflow name.</p> <p>Once this is done, set the corresponding option (<code>to_pypi</code> / <code>to_test_pypi</code>) to <code>true</code> in the <code>publish</code> job in <code>ci.yml</code> to enable the corresponding publication target.</p> <p>If the old and less secure token-based authentication method is needed or the package should be published to a different PyPI-compatible package index, please adapt <code>release.yml</code> accordingly).</p>"},{"location":"license/","title":"License","text":"<p>Unless stated otherwise, all code provided by this project (excluding external dependencies) is distributed under the following license:</p> <pre><code>MIT License\n\nCopyright (c) 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre> <p>This project is REUSE compliant. The following detailed license and copyright information in DEP5 format can also be found in the <code>.reuse/dep5</code> file in the project source directory:</p> <pre><code>Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\nUpstream-Name: somesy\nUpstream-Contact: Mustafa Soylu &lt;m.soylu@fz-juelich.de&gt;\nSource: https://github.com/Materials-Data-Science-and-Informatics/somesy\n\nFiles: .gitignore pyproject.toml poetry.lock .pre-commit-config.yaml .pre-commit-hooks.yaml .sourcery.yaml .somesy.toml codemeta.json CITATION.cff README.md RELEASE_NOTES.md CHANGELOG.md CODE_OF_CONDUCT.md AUTHORS.md CONTRIBUTING.md .gitlab-ci.yml .gitlab/* .github/* mkdocs.yml docs/*\nCopyright: 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\nLicense: CC0-1.0\n\nFiles: src/somesy/* tests/*\nCopyright: 2023 Forschungszentrum J\u00fclich GmbH - Institute Materials Data Science and Informatics (IAS9) - Stefan Sandfeld (s.sandfeld@fz-juelich.de)\nLicense: MIT\n</code></pre>"},{"location":"manual/","title":"User Manual","text":"<p>This is the reference manual for <code>somesy</code> providing details about its configuration and behavior.</p> <p>Before you proceed, make sure you have read the introduction and the quick-start guide.</p>"},{"location":"manual/#somesy-metadata-schemas","title":"Somesy Metadata Schemas","text":"<p>Because the same information is represented in different ways and more or less detail in different files, somesy requires to put all project information in a somesy-specific input section is located in a supported input file. Somesy will use this as the single source of truth for the supported project metadata fields and can synchronize this information into different target files.</p> <p>Info</p> <p>The somesy schemas are designed to allow expressing metadata in the most useful and rich form, i.e. the best form that some of the target formats supports.</p> <p>Somesy project metadata consists of two main schemas - one schema for describing people (authors, maintainers, contributors), and a schema describing the project.</p> <p>The somesy metadata fields (especially for people) are mostly based on Citation File Format 1.2, with some custom extensions. Somesy will try staying aligned with future revisions of <code>CITATION.cff</code>, unless for technical or practical reasons a deviation or extension is justified.</p> <p>One useful distinction somesy does in contrast to many target formats is to allow stating all people in one place. If a person is both an author and a maintainer, that person does not need to be listed with all information twice.</p> <p>This is done by adding the <code>author</code> and <code>maintainer</code> flags that can be set for every listed person. Somesy will take care of duplicating the entries where this is needed.</p> <p>Furthermore <code>somesy</code> allows to provide more fine-grained information about the contribution of a person and acknowledge contributors that are neither full authors or maintainers.</p> <p>Note</p> <p>Currently, provided information about contributors that are neither authors nor maintainers, and all the detailed information on the contributions is not used.</p> <p>Nevertheless, we encourage tracking granular contributor and contribution information in order to motivate and acknowledge also minor or invisible contributions to a projects.</p> <p>Once CITATION.cff introduces corresponding mechanisms, <code>somesy</code> will be aligned with the corresponding capabilities. Furthermore, <code>somesy</code> might support the allcontributors tool as a target in the future.</p>"},{"location":"manual/#schemas-overview","title":"Schemas Overview","text":"<p>Here is an overview of the schemas used in somesy.</p> SomesyInputProjectMetadataPersonEntitySomesyConfig <p>The complete somesy input file (<code>somesy.toml</code>) or section (<code>pyproject.toml</code>).   </p> Field Type Required? Default Description project ProjectMetadata yes Project metadata to be used and synchronized. config SomesyConfig no somesy tool configuration (matches CLI flags). <p>Pydantic model for Project Metadata Input.  </p> Field Type Required? Default Description name str yes Project name. description str yes Project description. version str no Project version. license LicenseEnum yes SPDX License string. homepage Annotated no URL of the project homepage. repository Annotated no URL of the project source code repository. documentation Annotated no URL of the project documentation. keywords List[str] no Keywords that describe the project. people List[Person] no Project authors, maintainers and contributors. entities List[Entity] no Project authors, maintainers and contributors as entities (organizations). <p>Metadata about a person in the context of a software project.</p> <p>This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Field Type Required? Default Description email str no The person's email address. alias str no The contributor's alias. address str no The contributor's address. city str no The entity's city. country Country no The entity's country. fax str no The person's fax number. post_code str no The entity's post-code. region str no The entity's region. tel str no The entity's phone number. author bool no false Indicates whether the entity is an author of the project (i.e. significant contributor). publication_author bool no Indicates whether the entity is to be listed as an author in academic citations. maintainer bool no false Indicates whether the entity is a maintainer of the project (i.e. for contact). contribution str no Summary of how the entity contributed to the project. contribution_types List[ContributionTypeEnum] no Relevant types of contributions (see https://allcontributors.org/docs/de/emoji-key). contribution_begin date no Beginning date of the contribution. contribution_end date no Ending date of the contribution. orcid Annotated no The person's ORCID url (not required, but highly suggested). family_names str yes The person's family names. given_names str yes The person's given names. name_particle str no The person's name particle, e.g., a nobiliary particle or a preposition meaning 'of' or 'from' (for example 'von' in 'Alexander von Humboldt'). name_suffix str no The person's name-suffix, e.g. 'Jr.' for Sammy Davis Jr. or 'III' for Frank Edwin Wright III. affiliation str no The person's affiliation. <p>Metadata about an entity in the context of a software project ownership.</p> <p>An entity, i.e., an institution, team, research group, company, conference, etc., as opposed to a single natural person. This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Field Type Required? Default Description email str no The person's email address. alias str no The contributor's alias. address str no The contributor's address. city str no The entity's city. country Country no The entity's country. fax str no The person's fax number. post_code str no The entity's post-code. region str no The entity's region. tel str no The entity's phone number. author bool no false Indicates whether the entity is an author of the project (i.e. significant contributor). publication_author bool no Indicates whether the entity is to be listed as an author in academic citations. maintainer bool no false Indicates whether the entity is a maintainer of the project (i.e. for contact). contribution str no Summary of how the entity contributed to the project. contribution_types List[ContributionTypeEnum] no Relevant types of contributions (see https://allcontributors.org/docs/de/emoji-key). contribution_begin date no Beginning date of the contribution. contribution_end date no Ending date of the contribution. date_end date no The entity's ending date, e.g., when the entity is a conference. date_start date no The entity's starting date, e.g., when the entity is a conference. location str no The entity's location, e.g., when the entity is a conference. name str yes The entity's name. website Annotated no The entity's website. rorid Annotated no The entity's ROR ID url (not required, but highly suggested). <p>Pydantic model for somesy tool configuration.</p> <p>Note that all fields match CLI options, and CLI options will override the values declared in a somesy input file (such as <code>somesy.toml</code>).</p> Field Type Required? Default Description show_info bool no false Show basic information messages on run (-v flag). verbose bool no false Show verbose messages on run (-vv flag). debug bool no false Show debug messages on run (-vvv flag). input_file Path no \"somesy.toml\" Project metadata input file path. no_sync_pyproject bool no false Do not sync with pyproject.toml. pyproject_file Path / List[Path] no \"pyproject.toml\" pyproject.toml file path. no_sync_package_json bool no false Do not sync with package.json. package_json_file Path / List[Path] no \"package.json\" package.json file path. no_sync_julia bool no false Do not sync with Project.toml. julia_file Path / List[Path] no \"Project.toml\" Project.toml file path. no_sync_fortran bool no false Do not sync with fpm.toml. fortran_file Path / List[Path] no \"fpm.toml\" fpm.toml file path. no_sync_pom_xml bool no false Do not sync with pom.xml. pom_xml_file Path / List[Path] no \"pom.xml\" pom.xml file path. no_sync_mkdocs bool no false Do not sync with mkdocs.yml. mkdocs_file Path / List[Path] no \"mkdocs.yml\" mkdocs.yml file path. no_sync_rust bool no false Do not sync with Cargo.toml. rust_file Path / List[Path] no \"Cargo.toml\" Cargo.toml file path. no_sync_cff bool no false Do not sync with CFF. cff_file Path / List[Path] no \"CITATION.cff\" CFF file path. no_sync_codemeta bool no false Do not sync with codemeta.json. codemeta_file Path / List[Path] no \"codemeta.json\" codemeta.json file path. merge_codemeta bool no false Merge codemeta.json with with an existing codemeta.json file. pass_validation bool no false Pass validation for all output files. packages Path / List[Path] no Packages (sub-folders) for monorepos with their own somesy config."},{"location":"manual/#metadata-mapping","title":"Metadata Mapping","text":"<p>From its own schema <code>somesy</code> must convert the information into the target formats. The following tables sketch how fields are mapped to corresponding other fields in some of the currently supported formats. Bold field names are mandatory, the others are optional.</p> Person MetadataEntity MetadataProject Metadata Somesy Field Poetry Config SetupTools Config Java POM Julia Config Fortran Config package.json mkdocs.yml Rust Config CITATION.cff CodeMeta given-names name(+email) name name name(+email) name(+email) name name(+email) name(+email) givenName name(+email) family-names name(+email) name name name(+email) name(+email) name name(+email) name(+email) familyName name(+email) email name(+email) email email name(+email) name(+email) email name(+email) name(+email) email name(+email) orcid - - url - - url - - id - (many others) - - - - - - - - (same) - Somesy Field Poetry Config SetupTools Config Java POM Julia Config Fortran Config package.json mkdocs.yml Rust Config CITATION.cff CodeMeta name name(+email) name name name(+email) name(+email) name name(+email) name(+email) givenName name(+email) email name(+email) email email name(+email) name(+email) email name(+email) name(+email) email name(+email) rorid - - url - - url - - id - website - - url - - url - - id - (many others) - - - - - - - - (same) - Somesy Field Poetry Config SetupTools Config Java POM Julia Config Fortran Config package.json mkdocs.yml Rust Config CITATION.cff CodeMeta name name name name name name name site_name name title name description description description description - description description site_description description abstract description license license license licenses.license - license license - license license license version version version version version version version - version version version author=true authors authors developers authors author author site_author authors authors author maintainer=true maintainers maintainers - - maintainer maintainers - - contact maintainer people - - - - - contributors - - - contributor entities - - - - - contributors - - - contributor keywords keywords keywords - - keywords keywords - keywords keywords keywords homepage homepage urls.homepage urls - homepage homepage site_url homepage url url repository repository urls.repository scm.url - - repository repo_url repository repository_code codeRepository documentation documentation urls.documentation distributionManagement.site.url - - - - documentation - buildInstructions <p>Note that the mapping is often not 1-to-1. For example, CITATION.cff allows rich specification of author contact information and complex names. In contrast, poetry only supports a simple string with a name and email (like in git commits) to list authors and maintainers. Therefore somesy sometimes must do much more than just move or rename fields. This means that giving a clean and complete mapping overview is not feasible. In case of doubt or confusion, please open an issue or consult the <code>somesy</code> code.</p> <p>people and entities are mapped to authors/maintainers/contributors depending on the output format. Both fields are marked as necessary but what <code>somesy</code> need is an author either in people or entities.</p> <p>When an entity has a <code>ror id</code> but no <code>website</code> set, url related fields will be filled with <code>ror id</code>.</p>"},{"location":"manual/#the-somesy-cli-tool","title":"The somesy CLI tool","text":"<p>You can see all supported somesy CLI command options using <code>somesy --help</code>:</p> <pre><code>somesy sync --help\n</code></pre> <pre><code>                                                                                \n Usage: somesy sync [OPTIONS] COMMAND [ARGS]...                                 \n                                                                                \n Sync project metadata input with metadata files.                               \n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --input-file            -i                 FILE  Somesy input file path      \u2502\n\u2502                                                  (default: .somesy.toml)     \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-pyproject     -P                       Do not sync pyproject.toml  \u2502\n\u2502                                                  file (default: False)       \u2502\n\u2502 --pyproject-file        -p                 FILE  Existing pyproject.toml     \u2502\n\u2502                                                  file path(s) (default:      \u2502\n\u2502                                                  pyproject.toml)             \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-package-json  -J                       Do not sync package.json    \u2502\n\u2502                                                  file (default: False)       \u2502\n\u2502 --package-json-file     -j                 FILE  Existing package.json file  \u2502\n\u2502                                                  path(s) (default:           \u2502\n\u2502                                                  package.json)               \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-julia         -L                       Do not sync Project.toml    \u2502\n\u2502                                                  (Julia) file (default:      \u2502\n\u2502                                                  False)                      \u2502\n\u2502 --julia-file            -l                 FILE  Custom Project.toml (Julia) \u2502\n\u2502                                                  file path(s) (default:      \u2502\n\u2502                                                  Project.toml)               \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-fortran       -F                       Do not sync fpm.toml        \u2502\n\u2502                                                  (Fortran) file (default:    \u2502\n\u2502                                                  False)                      \u2502\n\u2502 --fortran-file          -f                 FILE  Custom fpm.toml (Fortran)   \u2502\n\u2502                                                  file path(s) (default:      \u2502\n\u2502                                                  fpm.toml)                   \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-pomxml        -X                       Do not sync pom.xml (Java   \u2502\n\u2502                                                  Maven) file (default:       \u2502\n\u2502                                                  False)                      \u2502\n\u2502 --pomxml-file           -x                 FILE  Custom pom.xml (Java Maven) \u2502\n\u2502                                                  file path(s) (default:      \u2502\n\u2502                                                  pom.xml)                    \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-mkdocs        -D                       Do not sync mkdocs.yml file \u2502\n\u2502                                                  (default: False)            \u2502\n\u2502 --mkdocs-file           -d                 FILE  Custom mkdocs.yml file      \u2502\n\u2502                                                  path(s) (default:           \u2502\n\u2502                                                  mkdocs.yml)                 \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-rust          -R                       Do not sync Cargo.toml file \u2502\n\u2502                                                  (default: False)            \u2502\n\u2502 --rust-file             -r                 FILE  Custom Cargo.toml file      \u2502\n\u2502                                                  path(s) (default:           \u2502\n\u2502                                                  Cargo.toml)                 \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-cff           -C                       Do not sync CITATION.cff    \u2502\n\u2502                                                  file (default: False)       \u2502\n\u2502 --cff-file              -c                 FILE  CITATION.cff file path(s)   \u2502\n\u2502                                                  (default: CITATION.cff)     \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --no-sync-codemeta      -M                       Do not sync codemeta.json   \u2502\n\u2502                                                  file (default: False)       \u2502\n\u2502 --codemeta-file         -m                 FILE  Custom codemeta.json file   \u2502\n\u2502                                                  path(s) (default:           \u2502\n\u2502                                                  codemeta.json)              \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --merge                     --overwrite          Merge codemeta.json with    \u2502\n\u2502                                                  with an existing            \u2502\n\u2502                                                  codemeta.json file          \u2502\n\u2502                                                  (default: False)            \u2502\n\u2502                                                  [default: overwrite]        \u2502\n\u2502 --pass-validation       -P                       Pass validation of metadata \u2502\n\u2502                                                  files (default: False)      \u2502\n\u2502 --packages              -k                 FILE  Packages (subfolders) for   \u2502\n\u2502                                                  monorepos with their own    \u2502\n\u2502                                                  somesy config.              \u2502\n\u2502                                                  [default: None]             \u2502\n\u2502 --help                                           Show this message and exit. \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Everything that can be configured as a CLI flag can also be set in a <code>somesy.toml</code> file in the <code>[config]</code> section. CLI arguments set in an input file override the defaults, while options passed as CLI arguments override the configuration.</p> <p>Without an input file specifically provided, somesy will check if it can find a valid</p> <ul> <li><code>.somesy.toml</code></li> <li><code>somesy.toml</code></li> <li><code>pyproject.toml</code> (in <code>tool.somesy</code> section)</li> <li><code>Project.toml</code> (in <code>tool.somesy</code> section)</li> <li><code>fpm.toml</code> (in <code>tool.somesy</code> section)</li> <li><code>package.json</code> (in <code>somesy</code> section)</li> <li><code>Cargo.toml</code> (in <code>package.metadata.somesy</code> section)</li> </ul> <p>which is located in the current working directory. If you want to provide the somesy input file from a different location, you can pass it with the <code>-i</code> option.</p>"},{"location":"manual/#somesy-input-file","title":"Somesy Input File","text":"<p>Here is an example how project metadata and <code>somesy</code> can be configured using one of the supported input formats:</p> somesy.tomlpyproject.toml <pre><code>[project]\nname = \"my-amazing-project\"\nversion = \"0.1.0\"\ndescription = \"Brief description of my amazing software.\"\n\nkeywords = [\"some\", \"descriptive\", \"keywords\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/username/my-amazing-project\"\n\n# This is you, the proud author of your project:\n[[project.people]]\ngiven-names = \"Jane\"\nfamily-names = \"Doe\"\nemail = \"j.doe@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0001\"\nauthor = true      # is a full author of the project (i.e. appears in citations)\nmaintainer = true  # currently maintains the project (i.e. is a contact person)\n\n# this person is an acknowledged contributor, but not author or maintainer:\n[[project.people]]\ngiven-names = \"Another\"\nfamily-names = \"Contributor\"\nemail = \"a.contributor@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0002\"\n# ... but for scientific publications, this contributor should be listed as author:\npublication_author = true\n\n# add an organization as a maintainer\n[[project.entities]]\nname = \"My Super Organization\"\nemail = \"info@my-super-org.com\"\nwebsite = \"https://my-super-org.com\"\nrorid = \"https://ror.org/02nv7yv05\" # highly recommended set a ror id for your organization\n\n[config]\nverbose = true     # show detailed information about what somesy is doing\n</code></pre> <pre><code>[tool.poetry]\nname = \"my-amazing-project\"\nversion = \"0.1.0\"\n...\n\n[tool.somesy.project]\nname = \"my-amazing-project\"\nversion = \"0.1.0\"\ndescription = \"Brief description of my amazing software.\"\n\nkeywords = [\"some\", \"descriptive\", \"keywords\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/username/my-amazing-project\"\n\n# This is you, the proud author of your project\n[[tool.somesy.project.people]]\ngiven-names = \"Jane\"\nfamily-names = \"Doe\"\nemail = \"j.doe@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0001\"\nauthor = true      # is a full author of the project (i.e. appears in citations)\nmaintainer = true  # currently maintains the project (i.e. is a contact person)\n\n# this person is a acknowledged contributor, but not author or maintainer:\n[[tool.somesy.project.people]]\ngiven-names = \"Another\"\nfamily-names = \"Contributor\"\nemail = \"a.contributor@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0002\"\n\n# add an organization as a maintainer\n[[tool.somesy.project.entities]]\nname = \"My Super Organization\"\nemail = \"info@my-super-org.com\"\nwebsite = \"https://my-super-org.com\"\nrorid = \"https://ror.org/02nv7yv05\" # highly recommended set a ror id for your organization\n\n[tool.somesy.config]\nverbose = true     # show detailed information about what somesy is doing\n</code></pre>"},{"location":"manual/#support-for-mono-repos-and-multi-package-projects","title":"Support for mono-repos and multi-package projects","text":"<p>A research software project might have multiple packages in the root repository. These packages might be in the same or different software languages or frameworks. <code>somesy</code> currently supports synchronizing multiple output files from one somesy project metadata input.</p>"},{"location":"manual/#sync-from-one-somesy-input","title":"Sync from one somesy input","text":"<p>This is the case where you have only one somesy metadata set in your root folder. Output files can be set in the somesy config section.</p> <pre><code>[project]\n...\n\n[config]\npass_validation = true\npackage_json_file = ['package.json', 'package1/package.json']\npyproject_toml_file = 'package2/pyproject.toml'\n</code></pre> <p>Warning</p> <p>Each output file, such as package.json file, have its required fields and these fields are enforced by <code>somesy</code>. However, in case of mono-repos or multi-package repositories, some of the fields could be omitted, such as <code>version</code>. Therefore, we suggest users to set <code>pass_validation</code> to <code>true</code> if this is the case. <code>somesy</code> will fail otherwise.</p> <p>The example above shows a project with a <code>package.json</code> file in the root folder and 2 packages in it. Three files are set here so all of them will be updated according to ground truth of <code>somesy project metadata</code>.</p> <p>Note</p> <p>Let's remember <code>somesy</code> will create a <code>CITATION.CFF</code> and <code>codemeta.json</code> file in the root folder if it is set otherwise either by cli or by config.</p>"},{"location":"manual/#packages-sub-modules-with-their-own-somesy-file","title":"Packages (sub-modules) with their own somesy file","text":"<p>A project with multiple packages inside can have completely different metadata such version and authors. Therefore, each package should have a separate metadata, in other words, separate <code>somesy</code> config and project metadata.</p> <pre><code>[project]\n...\n\n[config]\npackages = ['package1', 'package2', 'package3']\n</code></pre> <p>Each of these packages (sub-folders) are assumed to have separate somesy metadata in the folder. These packages could be a <code>somesy</code> supported language/framework or it could be any other language. <code>somesy</code> will create at least <code>CITATION.CFF</code> and <code>codemeta.json</code> regardless if not instructed otherwise.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#getting-started","title":"Getting Started","text":""},{"location":"quickstart/#platform-support","title":"Platform Support","text":"<p>Starting with version 0.3.0, <code>somesy</code> supports Linux, MacOS and Windows.</p> <p>Make sure that you use the latest version in order to avoid any problems.</p>"},{"location":"quickstart/#installing-somesy","title":"Installing somesy","text":"<p>Somesy requires Python <code>&gt;=3.8</code>. To get a first impression, you can install the latest stable version of somesy from PyPI using <code>pip</code>:</p> <pre><code>pip install somesy\n</code></pre> <p>Note</p> <p>If you use somesy as a pre-commit hook, you don't have to install somesy on your PC nor add it as a dependency in your Python project. Pre-commit will handle the installation automatically.</p>"},{"location":"quickstart/#configuring-somesy","title":"Configuring somesy","text":"<p>Yes, somesy is another tool with its own configuration. However, for your project metadata it is hopefully the last file you need, and the only one you have to think about, <code>somesy</code> will take care of the others for you!</p> <p>To get started, create a file named <code>somesy.toml</code>:</p> <pre><code>[project]\nname = \"my-amazing-project\"\nversion = \"0.1.0\"\ndescription = \"Brief description of my amazing software.\"\n\nkeywords = [\"some\", \"descriptive\", \"keywords\"]\nlicense = \"MIT\"\nrepository = \"https://github.com/username/my-amazing-project\"\n\n# This is you, the proud author of your project:\n[[project.people]]\ngiven-names = \"Jane\"\nfamily-names = \"Doe\"\nemail = \"j.doe@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0001\"\nauthor = true      # is a full author of the project (i.e. appears in citations)\nmaintainer = true  # currently maintains the project (i.e. is a contact person)\n\n# this person is an acknowledged contributor, but not author or maintainer:\n[[project.people]]\ngiven-names = \"Another\"\nfamily-names = \"Contributor\"\nemail = \"a.contributor@example.com\"\norcid = \"https://orcid.org/0000-0000-0000-0002\"\n# ... but for scientific publications, this contributor should be listed as author:\npublication_author = true\n\n# add an organization as a maintainer\n[[project.entities]]\nname = \"My Super Organization\"\nemail = \"info@my-super-org.com\"\nwebsite = \"https://my-super-org.com\"\nrorid = \"https://ror.org/02nv7yv05\" # highly recommended set a ror id for your organization\n\n[config]\nverbose = true     # show detailed information about what somesy is doing\n</code></pre> <p>As Helmholtz Metadata Collaboration (HMC), our goal is to increase usage of metadata and improve metadata quality. Therefore, some fields in <code>somesy.toml</code> are set as required fields. This is to increase rigour and completeness of metadata recorded with <code>somesy</code> .</p> <p>Alternatively, you can also add the somesy configuration to an existing <code>pyproject.toml</code>, <code>package.json</code>, <code>Project.toml</code>, or <code>fpm.toml</code> file. The somesy manual contains examples showing how to do that.</p>"},{"location":"quickstart/#using-somesy","title":"Using somesy","text":"<p>Once somesy is installed and configured, somesy can take over and manage your project metadata. Now you can run <code>somesy</code> simply by using</p> <pre><code>somesy sync\n</code></pre> <p>The information in your <code>somesy.toml</code> is used as the primary and authoritative source for project metadata, which is used to update all supported (and enabled) target files. You can find an overview of supported formats further below.</p> <p>By default, <code>somesy</code> will create (if they did not exist) or update <code>CITATION.cff</code> and <code>codemeta.json</code> files in your repository. If you happen to use</p> <ul> <li><code>pyproject.toml</code> (in Python projects),</li> <li><code>package.json</code> (in JavaScript projects),</li> <li><code>Project.toml</code> (in Julia projects),</li> <li><code>fpm.toml</code> (in Fortran projects),</li> <li><code>pom.xml</code> (in Java projects),</li> <li><code>mkdocs.yml</code> (in projects using MkDocs),</li> <li><code>Cargo.toml</code> (in Rust projects)</li> </ul> <p>then somesy would also update the respective information there.</p> <p>You can see call available options with <code>somesy --help</code>, all of these can also be conveniently set in your <code>somesy.toml</code> file.</p>"},{"location":"quickstart/#somesy-as-a-pre-commit-hook","title":"Somesy as a pre-commit hook","text":"<p>We highly recommend to use <code>somesy</code> as a pre-commit hook. A pre-commit hook runs on every commit to automatically point out issues or fix them on the spot, so if you do not use pre-commit in your project yet, you should start today! When used this way, <code>somesy</code> can fix most typical issues with your project metadata even before your changes can leave your computer.</p> <p>To add <code>somesy</code> as a pre-commit hook, add it to your <code>.pre-commit-config.yaml</code> file in the root folder of your repository:</p> <pre><code>repos:\n    # ... (your other hooks) ...\n    - repo: https://github.com/Materials-Data-Science-and-Informatics/somesy\n      rev: 'v0.6.0'\n      hooks:\n          - id: somesy\n</code></pre> <p>Note</p> <p>Please add the latest version of Somesy to your project. You can update the version of Somesy in your config file now and later to use the newest versions as they become available.</p> <p>Note that <code>pre-commit</code> gives <code>somesy</code> the staged version of files, so when using <code>somesy</code> with pre-commit, keep in mind that</p> <ul> <li>if <code>somesy</code> changed some files, you need to <code>git add</code> them again (and rerun pre-commit)</li> <li>if you explicitly run <code>pre-commit</code>, make sure to <code>git add</code> all changed files (just like before a commit)</li> </ul>"},{"location":"quickstart/#supported-file-formats","title":"Supported File Formats","text":"<p>Here is an overview of all the currently supported files and formats.</p> Input Formats Status Target Formats Status (.)somesy.toml \u2713 pyproject.toml (poetry) \u2713 pyproject.toml \u2713 pyproject.toml (setuptools) \u2713(1.) package.json \u2713 package.json (JavaScript) \u2713(2.) Project.toml \u2713 Project.toml (Julia) \u2713 fpm.toml \u2713 fpm.toml (Fortran) \u2713(3.) \u2713 pom.toml (Java) \u2713(4.) Cargo.toml \u2713 Cargo.toml (Rust) \u2713 mkdocs.yml \u2713(5.) CITATION.cff \u2713 codemeta.json \u2713(6.) <p>Notes:</p> <ol> <li>note that <code>somesy</code> does not support setuptools dynamic fields</li> <li><code>package.json</code> only supports one author, so <code>somesy</code> will pick the first listed author</li> <li><code>fpm.toml</code> only supports one author and maintainer, so <code>somesy</code> will pick the first listed author and maintainer</li> <li><code>pom.xml</code> has no concept of <code>maintainers</code>, but it can have multiple licenses (somesy only supports one main project license)</li> <li><code>mkdocs.yml</code> is a bit special, as it is not a project file, but a documentation file. <code>somesy</code> will only update it if it exists and is enabled in the configuration</li> <li>For handling <code>codemeta.json</code> different options exists: Either (A) <code>somesy</code> removes any prior existing <code>codemata.json</code> files and re-creates it anew, or (B) <code>somesy</code> merges an existing <code>codemeta.json</code> with the information handled by <code>somesy</code>. See the user manual for additional details about CodeMeta handling.</li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>somesy<ul> <li>cff<ul> <li>writer</li> </ul> </li> <li>cli<ul> <li>fill</li> <li>init</li> <li>sync</li> <li>util</li> </ul> </li> <li>codemeta<ul> <li>utils</li> <li>writer</li> </ul> </li> <li>commands<ul> <li>init_config</li> <li>sync</li> </ul> </li> <li>core<ul> <li>core</li> <li>log</li> <li>models</li> <li>types</li> <li>writer</li> </ul> </li> <li>fortran<ul> <li>models</li> <li>writer</li> </ul> </li> <li>json_wrapper</li> <li>julia<ul> <li>models</li> <li>writer</li> </ul> </li> <li>main</li> <li>mkdocs<ul> <li>models</li> <li>writer</li> </ul> </li> <li>package_json<ul> <li>models</li> <li>writer</li> </ul> </li> <li>pom_xml<ul> <li>writer</li> <li>xmlproxy</li> </ul> </li> <li>pyproject<ul> <li>models</li> <li>writer</li> </ul> </li> <li>rust<ul> <li>models</li> <li>writer</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/somesy/","title":"somesy","text":"<p>somesy package.</p>"},{"location":"reference/somesy/json_wrapper/","title":"json_wrapper","text":"<p>Utility functions for somesy.</p>"},{"location":"reference/somesy/json_wrapper/#somesy.json_wrapper.json_dump_wrapper","title":"json_dump_wrapper","text":"<pre><code>json_dump_wrapper(wrapped, instance, args, kwargs)\n</code></pre> <p>Wrap json.dump to write non-ascii characters with default indentation.</p> Source code in <code>src/somesy/json_wrapper.py</code> <pre><code>@wrapt.decorator\ndef json_dump_wrapper(wrapped, instance, args, kwargs):\n    \"\"\"Wrap json.dump to write non-ascii characters with default indentation.\"\"\"\n    # Ensure ensure_ascii is set to False\n    kwargs[\"ensure_ascii\"] = False\n    # set indent to 2 if not set\n    kwargs[\"indent\"] = kwargs.get(\"indent\", 2)\n    return wrapped(*args, **kwargs)\n</code></pre>"},{"location":"reference/somesy/main/","title":"main","text":"<p>Main entry point for the somesy CLI.</p>"},{"location":"reference/somesy/main/#somesy.main.version","title":"version","text":"<pre><code>version(value: bool)\n</code></pre> <p>Show somesy version and exit.</p> Source code in <code>src/somesy/main.py</code> <pre><code>@app.callback()\ndef version(value: bool):\n    \"\"\"Show somesy version and exit.\"\"\"\n    if value:\n        typer.echo(f\"somesy version: {__version__}\")\n        raise typer.Exit()\n</code></pre>"},{"location":"reference/somesy/main/#somesy.main.common","title":"common","text":"<pre><code>common(\n    ctx: typer.Context,\n    version: bool = typer.Option(\n        None,\n        \"--version\",\n        help=version.__doc__,\n        callback=version,\n    ),\n    show_info: bool = typer.Option(\n        None, \"--info\", \"-v\", help=\"Enable basic logging.\"\n    ),\n    verbose: bool = typer.Option(\n        None,\n        \"--verbose\",\n        \"-vv\",\n        help=\"Enable verbose logging.\",\n    ),\n    debug: bool = typer.Option(\n        None,\n        \"--debug\",\n        \"-vvv\",\n        help=\"Enable debug logging.\",\n    ),\n)\n</code></pre> <p>General flags and arguments for somesy.</p> Source code in <code>src/somesy/main.py</code> <pre><code>@app.callback()\ndef common(\n    ctx: typer.Context,\n    version: bool = typer.Option(\n        None, \"--version\", help=version.__doc__, callback=version\n    ),\n    show_info: bool = typer.Option(\n        None,\n        \"--info\",\n        \"-v\",\n        help=\"Enable basic logging.\",\n    ),\n    verbose: bool = typer.Option(\n        None,\n        \"--verbose\",\n        \"-vv\",\n        help=\"Enable verbose logging.\",\n    ),\n    debug: bool = typer.Option(\n        None,\n        \"--debug\",\n        \"-vvv\",\n        help=\"Enable debug logging.\",\n    ),\n):\n    \"\"\"General flags and arguments for somesy.\"\"\"\n    init_log()\n\n    if sum(map(int, map(bool, [show_info, verbose, debug]))) &gt; 1:\n        typer.echo(\n            \"Only one of --info, --verbose or --debug may be set!\", file=sys.stderr\n        )\n        raise typer.Exit(1)\n\n    if show_info or verbose or debug:\n        # NOTE: only explicitly setting log level if a flag is passed,\n        # in order to distinguish from using the \"default log level\"\n        # (needed to check if the user did override the log level as a CLI flag)\n        set_log_level(\n            SomesyLogLevel.from_flags(info=show_info, verbose=verbose, debug=debug)\n        )\n</code></pre>"},{"location":"reference/somesy/cff/","title":"cff","text":"<p>CFF module.</p>"},{"location":"reference/somesy/cff/#somesy.cff.CFF","title":"CFF","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Citation File Format (CFF) parser and saver.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>class CFF(ProjectMetadataWriter):\n    \"\"\"Citation File Format (CFF) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = True,\n        pass_validation: bool = False,\n    ):\n        \"\"\"Citation File Format (CFF) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings: FieldKeyMapping = {\n            \"name\": [\"title\"],\n            \"description\": [\"abstract\"],\n            \"homepage\": [\"url\"],\n            \"repository\": [\"repository-code\"],\n            \"documentation\": IgnoreKey(),\n            \"maintainers\": [\"contact\"],\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=create_if_not_exists,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _init_new_file(self):\n        \"\"\"Initialize new CFF file.\"\"\"\n        self._data = {\n            \"cff-version\": \"1.2.0\",\n            \"message\": \"If you use this software, please cite it using these metadata.\",\n            \"type\": \"software\",\n        }\n        with open(self.path, \"w\") as f:\n            self._yaml.dump(self._data, f)\n\n    def _load(self):\n        \"\"\"Load the CFF file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the CFF file.\"\"\"\n        if self.pass_validation:\n            return\n        try:\n            citation = create_citation(self.path, None)\n            citation.validate()\n        except ValueError as e:\n            raise ValueError(f\"CITATION.cff file is not valid!\\n{e}\") from e\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the CFF object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    def _sync_authors(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Ensure that publication authors are added all into author list.\"\"\"\n        self.authors = self._sync_person_list(\n            self.authors, metadata.publication_authors()\n        )\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person or entity object to cff dict for person format.\"\"\"\n        json_str = person.model_dump_json(\n            exclude={\n                \"contribution\",\n                \"contribution_types\",\n                \"contribution_begin\",\n                \"contribution_end\",\n                \"author\",\n                \"publication_author\",\n                \"maintainer\",\n            },\n            by_alias=True,  # e.g. family_names -&gt; family-names, etc.\n        )\n        return json.loads(json_str)\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Union[Person, Entity]:\n        \"\"\"Parse CFF Person to a somesy Person or entity.\"\"\"\n        # if the object has key name, it is an entity\n        if \"name\" in person_obj:\n            Entity._aliases()\n            ret = Entity.make_partial(person_obj)\n        else:\n            Person._aliases()\n            ret = Person.make_partial(person_obj)\n\n        # construct (partial) Person while preserving key order from YAML\n        ret.set_key_order(list(person_obj.keys()))\n        return ret\n</code></pre>"},{"location":"reference/somesy/cff/#somesy.cff.CFF.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: bool = False,\n)\n</code></pre> <p>Citation File Format (CFF) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: bool = False,\n):\n    \"\"\"Citation File Format (CFF) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings: FieldKeyMapping = {\n        \"name\": [\"title\"],\n        \"description\": [\"abstract\"],\n        \"homepage\": [\"url\"],\n        \"repository\": [\"repository-code\"],\n        \"documentation\": IgnoreKey(),\n        \"maintainers\": [\"contact\"],\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=create_if_not_exists,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/cff/#somesy.cff.CFF.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the CFF object to a file.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the CFF object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/cff/writer/","title":"writer","text":"<p>Citation File Format (CFF) parser and saver.</p>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF","title":"CFF","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Citation File Format (CFF) parser and saver.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>class CFF(ProjectMetadataWriter):\n    \"\"\"Citation File Format (CFF) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = True,\n        pass_validation: bool = False,\n    ):\n        \"\"\"Citation File Format (CFF) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings: FieldKeyMapping = {\n            \"name\": [\"title\"],\n            \"description\": [\"abstract\"],\n            \"homepage\": [\"url\"],\n            \"repository\": [\"repository-code\"],\n            \"documentation\": IgnoreKey(),\n            \"maintainers\": [\"contact\"],\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=create_if_not_exists,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _init_new_file(self):\n        \"\"\"Initialize new CFF file.\"\"\"\n        self._data = {\n            \"cff-version\": \"1.2.0\",\n            \"message\": \"If you use this software, please cite it using these metadata.\",\n            \"type\": \"software\",\n        }\n        with open(self.path, \"w\") as f:\n            self._yaml.dump(self._data, f)\n\n    def _load(self):\n        \"\"\"Load the CFF file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the CFF file.\"\"\"\n        if self.pass_validation:\n            return\n        try:\n            citation = create_citation(self.path, None)\n            citation.validate()\n        except ValueError as e:\n            raise ValueError(f\"CITATION.cff file is not valid!\\n{e}\") from e\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the CFF object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    def _sync_authors(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Ensure that publication authors are added all into author list.\"\"\"\n        self.authors = self._sync_person_list(\n            self.authors, metadata.publication_authors()\n        )\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person or entity object to cff dict for person format.\"\"\"\n        json_str = person.model_dump_json(\n            exclude={\n                \"contribution\",\n                \"contribution_types\",\n                \"contribution_begin\",\n                \"contribution_end\",\n                \"author\",\n                \"publication_author\",\n                \"maintainer\",\n            },\n            by_alias=True,  # e.g. family_names -&gt; family-names, etc.\n        )\n        return json.loads(json_str)\n\n    @staticmethod\n    def _to_person(person_obj) -&gt; Union[Person, Entity]:\n        \"\"\"Parse CFF Person to a somesy Person or entity.\"\"\"\n        # if the object has key name, it is an entity\n        if \"name\" in person_obj:\n            Entity._aliases()\n            ret = Entity.make_partial(person_obj)\n        else:\n            Person._aliases()\n            ret = Person.make_partial(person_obj)\n\n        # construct (partial) Person while preserving key order from YAML\n        ret.set_key_order(list(person_obj.keys()))\n        return ret\n</code></pre>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: bool = False,\n)\n</code></pre> <p>Citation File Format (CFF) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: bool = False,\n):\n    \"\"\"Citation File Format (CFF) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings: FieldKeyMapping = {\n        \"name\": [\"title\"],\n        \"description\": [\"abstract\"],\n        \"homepage\": [\"url\"],\n        \"repository\": [\"repository-code\"],\n        \"documentation\": IgnoreKey(),\n        \"maintainers\": [\"contact\"],\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=create_if_not_exists,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/cff/writer/#somesy.cff.writer.CFF.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the CFF object to a file.</p> Source code in <code>src/somesy/cff/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the CFF object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/cli/","title":"cli","text":"<p>CLI commands for somesy.</p>"},{"location":"reference/somesy/cli/fill/","title":"fill","text":"<p>Fill command of somesy.</p>"},{"location":"reference/somesy/cli/fill/#somesy.cli.fill.fill","title":"fill","text":"<pre><code>fill(\n    template_file: Path = typer.Option(\n        None,\n        \"--template\",\n        \"-t\",\n        help=\"Path to a Jinja2 template for somesy to fill (default: stdin).\",\n        **existing_file_arg_config\n    ),\n    input_file: Path = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        help=\"Path of somesy input file (default: try to infer).\",\n        **existing_file_arg_config\n    ),\n    output_file: Path = typer.Option(\n        None,\n        \"--output-file\",\n        \"-o\",\n        help=\"Path for target file (default: stdout).\",\n        **file_arg_config\n    ),\n)\n</code></pre> <p>Fill a Jinja2 template with somesy project metadata (e.g. list authors in project docs).</p> Source code in <code>src/somesy/cli/fill.py</code> <pre><code>@app.callback(invoke_without_command=True)\n@wrap_exceptions\ndef fill(\n    template_file: Path = typer.Option(\n        None,\n        \"--template\",\n        \"-t\",\n        help=\"Path to a Jinja2 template for somesy to fill (default: stdin).\",\n        **existing_file_arg_config,\n    ),\n    input_file: Path = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        help=\"Path of somesy input file (default: try to infer).\",\n        **existing_file_arg_config,\n    ),\n    output_file: Path = typer.Option(\n        None,\n        \"--output-file\",\n        \"-o\",\n        help=\"Path for target file (default: stdout).\",\n        **file_arg_config,\n    ),\n):\n    \"\"\"Fill a Jinja2 template with somesy project metadata (e.g. list authors in project docs).\"\"\"\n    somesy_input = resolved_somesy_input(input_file=input_file)\n\n    if template_file:\n        logger.debug(f\"Reading Jinja2 template from '{template_file}'.\")\n        with open(template_file, \"r\") as f:\n            template_str = f.read()\n    else:\n        logger.debug(\"Reading Jinja2 template from stdin.\")\n        template_str = stdin.read()\n\n    result = (\n        Environment(\n            loader=FunctionLoader(lambda _: template_str),\n            autoescape=select_autoescape(),\n        )\n        .get_template(\"\")\n        .render(project=somesy_input.project)\n    )\n\n    if output_file:\n        logger.debug(f\"Writing result to '{output_file}'.\")\n        with open(output_file, \"w\") as f:\n            f.write(result)\n    else:\n        logger.debug(\"Writing result to stdout.\")\n        print(result)\n</code></pre>"},{"location":"reference/somesy/cli/init/","title":"init","text":"<p>Set config files for somesy.</p>"},{"location":"reference/somesy/cli/init/#somesy.cli.init.config","title":"config","text":"<pre><code>config()\n</code></pre> <p>Set CLI configs for somesy.</p> Source code in <code>src/somesy/cli/init.py</code> <pre><code>@app.command()\n@wrap_exceptions\ndef config():\n    \"\"\"Set CLI configs for somesy.\"\"\"\n    # check if input file exists, if not, try to find it from default list\n    input_file_default = discover_input()\n\n    # prompt for inputs\n    input_file = typer.prompt(\"Input file path\", default=input_file_default)\n    options = dict(input_file=Path(input_file))\n\n    # ----\n\n    options[\"no_sync_cff\"] = not typer.confirm(\n        \"Do you want to sync to a CFF file?\", default=True\n    )\n    if cff_file := typer.prompt(\"CFF file path\", default=\"CITATION.cff\"):\n        options[\"cff_file\"] = cff_file\n\n    options[\"no_sync_codemeta\"] = not typer.confirm(\n        \"Do you want to sync to a codemeta.json file?\", default=True\n    )\n    if codemeta_file := typer.prompt(\n        \"codemeta.json file path\", default=\"codemeta.json\"\n    ):\n        options[\"codemeta_file\"] = codemeta_file\n\n    options[\"no_sync_pyproject\"] = not typer.confirm(\n        \"Do you want to sync to a pyproject.toml file?\", default=True\n    )\n    if pyproject_file := typer.prompt(\n        \"pyproject.toml file path\", default=\"pyproject.toml\"\n    ):\n        options[\"pyproject_file\"] = pyproject_file\n\n    options[\"sync_package_json\"] = typer.confirm(\n        \"Do you want to sync to a package.json file?\", default=False\n    )\n    if package_json_file := typer.prompt(\n        \"package.json file path\", default=\"package.json\"\n    ):\n        options[\"package_json_file\"] = package_json_file\n\n    options[\"no_sync_julia\"] = not typer.confirm(\n        \"Do you want to sync to a Project.toml(Julia) file?\", default=True\n    )\n    if julia_file := typer.prompt(\n        \"Project.toml (Julia) file path\", default=\"Project.toml\"\n    ):\n        options[\"julia_file\"] = julia_file\n\n    options[\"no_sync_fortran\"] = not typer.confirm(\n        \"Do you want to sync to a fpm.toml(fortran) file?\", default=True\n    )\n    fortran_file = typer.prompt(\"fpm.toml(fortran) file path\", default=\"fpm.toml\")\n    if fortran_file is not None or fortran_file != \"\":\n        options[\"fortran_file\"] = fortran_file\n\n    options[\"no_sync_pom_xml\"] = not typer.confirm(\n        \"Do you want to sync to a pom.xml file?\", default=True\n    )\n    if pom_xml_file := typer.prompt(\"pom.xml file path\", default=\"pom.xml\"):\n        options[\"pom_xml_file\"] = pom_xml_file\n\n    options[\"no_sync_mkdocs\"] = not typer.confirm(\n        \"Do you want to sync to a mkdocs.yml file?\", default=True\n    )\n    if mkdocs_file := typer.prompt(\"mkdocs.yml file path\", default=\"mkdocs.yml\"):\n        options[\"mkdocs_file\"] = mkdocs_file\n\n    options[\"no_sync_rust\"] = not typer.confirm(\n        \"Do you want to sync to a Cargo.toml file?\", default=True\n    )\n    if rust_file := typer.prompt(\"Cargo.toml file path\", default=\"Cargo.toml\"):\n        options[\"rust_file\"] = rust_file\n\n    # ----\n\n    options[\"show_info\"] = typer.confirm(\n        \"Do you want to show info about the sync process?\"\n    )\n    options[\"verbose\"] = typer.confirm(\"Do you want to show verbose logs?\")\n    options[\"debug\"] = typer.confirm(\"Do you want to show debug logs?\")\n\n    set_log_level(\n        SomesyLogLevel.from_flags(\n            debug=options[\"debug\"],\n            verbose=options[\"verbose\"],\n            info=options[\"show_info\"],\n        )\n    )\n\n    logger.debug(f\"CLI options entered: {options}\")\n\n    init_config(input_file, options)\n    logger.info(\n        f\"[bold green]Input file is updated/created at {input_file}[/bold green]\"\n    )\n</code></pre>"},{"location":"reference/somesy/cli/sync/","title":"sync","text":"<p>Sync command for somesy.</p>"},{"location":"reference/somesy/cli/sync/#somesy.cli.sync.sync","title":"sync","text":"<pre><code>sync(\n    input_file: Optional[Path] = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        help=\"Somesy input file path (default: .somesy.toml)\",\n        **file_arg_config\n    ),\n    no_sync_pyproject: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-pyproject\",\n        \"-P\",\n        help=\"Do not sync pyproject.toml file (default: False)\",\n    ),\n    pyproject_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--pyproject-file\",\n        \"-p\",\n        help=\"Existing pyproject.toml file path(s) (default: pyproject.toml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_package_json: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-package-json\",\n        \"-J\",\n        help=\"Do not sync package.json file (default: False)\",\n    ),\n    package_json_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--package-json-file\",\n        \"-j\",\n        help=\"Existing package.json file path(s) (default: package.json)\",\n        **existing_file_arg_config\n    ),\n    no_sync_julia: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-julia\",\n        \"-L\",\n        help=\"Do not sync Project.toml (Julia) file (default: False)\",\n    ),\n    julia_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--julia-file\",\n        \"-l\",\n        help=\"Custom Project.toml (Julia) file path(s) (default: Project.toml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_fortran: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-fortran\",\n        \"-F\",\n        help=\"Do not sync fpm.toml (Fortran) file (default: False)\",\n    ),\n    fortran_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--fortran-file\",\n        \"-f\",\n        help=\"Custom fpm.toml (Fortran) file path(s) (default: fpm.toml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_pom_xml: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-pomxml\",\n        \"-X\",\n        help=\"Do not sync pom.xml (Java Maven) file (default: False)\",\n    ),\n    pom_xml_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--pomxml-file\",\n        \"-x\",\n        help=\"Custom pom.xml (Java Maven) file path(s) (default: pom.xml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_mkdocs: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-mkdocs\",\n        \"-D\",\n        help=\"Do not sync mkdocs.yml file (default: False)\",\n    ),\n    mkdocs_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--mkdocs-file\",\n        \"-d\",\n        help=\"Custom mkdocs.yml file path(s) (default: mkdocs.yml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_rust: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-rust\",\n        \"-R\",\n        help=\"Do not sync Cargo.toml file (default: False)\",\n    ),\n    rust_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--rust-file\",\n        \"-r\",\n        help=\"Custom Cargo.toml file path(s) (default: Cargo.toml)\",\n        **existing_file_arg_config\n    ),\n    no_sync_cff: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-cff\",\n        \"-C\",\n        help=\"Do not sync CITATION.cff file (default: False)\",\n    ),\n    cff_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--cff-file\",\n        \"-c\",\n        help=\"CITATION.cff file path(s) (default: CITATION.cff)\",\n        **file_arg_config\n    ),\n    no_sync_codemeta: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-codemeta\",\n        \"-M\",\n        help=\"Do not sync codemeta.json file (default: False)\",\n    ),\n    codemeta_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--codemeta-file\",\n        \"-m\",\n        help=\"Custom codemeta.json file path(s) (default: codemeta.json)\",\n        **file_arg_config\n    ),\n    merge_codemeta: Optional[bool] = typer.Option(\n        False,\n        \"--merge/--overwrite\",\n        help=\"Merge codemeta.json with with an existing codemeta.json file (default: False)\",\n    ),\n    pass_validation: Optional[bool] = typer.Option(\n        False,\n        \"--pass-validation\",\n        \"-P\",\n        help=\"Pass validation of metadata files (default: False)\",\n    ),\n    packages: Optional[List[Path]] = typer.Option(\n        None,\n        \"--packages\",\n        \"-k\",\n        help=\"Packages (subfolders) for monorepos with their own somesy config.\",\n        **existing_file_arg_config\n    ),\n)\n</code></pre> <p>Sync project metadata input with metadata files.</p> Source code in <code>src/somesy/cli/sync.py</code> <pre><code>@app.callback(invoke_without_command=True)\n@wrap_exceptions\ndef sync(\n    input_file: Optional[Path] = typer.Option(\n        None,\n        \"--input-file\",\n        \"-i\",\n        help=\"Somesy input file path (default: .somesy.toml)\",\n        **file_arg_config,\n    ),\n    no_sync_pyproject: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-pyproject\",\n        \"-P\",\n        help=\"Do not sync pyproject.toml file (default: False)\",\n    ),\n    pyproject_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--pyproject-file\",\n        \"-p\",\n        help=\"Existing pyproject.toml file path(s) (default: pyproject.toml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_package_json: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-package-json\",\n        \"-J\",\n        help=\"Do not sync package.json file (default: False)\",\n    ),\n    package_json_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--package-json-file\",\n        \"-j\",\n        help=\"Existing package.json file path(s) (default: package.json)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_julia: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-julia\",\n        \"-L\",\n        help=\"Do not sync Project.toml (Julia) file (default: False)\",\n    ),\n    julia_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--julia-file\",\n        \"-l\",\n        help=\"Custom Project.toml (Julia) file path(s) (default: Project.toml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_fortran: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-fortran\",\n        \"-F\",\n        help=\"Do not sync fpm.toml (Fortran) file (default: False)\",\n    ),\n    fortran_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--fortran-file\",\n        \"-f\",\n        help=\"Custom fpm.toml (Fortran) file path(s) (default: fpm.toml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_pom_xml: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-pomxml\",\n        \"-X\",\n        help=\"Do not sync pom.xml (Java Maven) file (default: False)\",\n    ),\n    pom_xml_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--pomxml-file\",\n        \"-x\",\n        help=\"Custom pom.xml (Java Maven) file path(s) (default: pom.xml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_mkdocs: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-mkdocs\",\n        \"-D\",\n        help=\"Do not sync mkdocs.yml file (default: False)\",\n    ),\n    mkdocs_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--mkdocs-file\",\n        \"-d\",\n        help=\"Custom mkdocs.yml file path(s) (default: mkdocs.yml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_rust: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-rust\",\n        \"-R\",\n        help=\"Do not sync Cargo.toml file (default: False)\",\n    ),\n    rust_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--rust-file\",\n        \"-r\",\n        help=\"Custom Cargo.toml file path(s) (default: Cargo.toml)\",\n        **existing_file_arg_config,\n    ),\n    no_sync_cff: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-cff\",\n        \"-C\",\n        help=\"Do not sync CITATION.cff file (default: False)\",\n    ),\n    cff_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--cff-file\",\n        \"-c\",\n        help=\"CITATION.cff file path(s) (default: CITATION.cff)\",\n        **file_arg_config,\n    ),\n    no_sync_codemeta: Optional[bool] = typer.Option(\n        None,\n        \"--no-sync-codemeta\",\n        \"-M\",\n        help=\"Do not sync codemeta.json file (default: False)\",\n    ),\n    codemeta_file: Optional[List[Path]] = typer.Option(\n        None,\n        \"--codemeta-file\",\n        \"-m\",\n        help=\"Custom codemeta.json file path(s) (default: codemeta.json)\",\n        **file_arg_config,\n    ),\n    merge_codemeta: Optional[bool] = typer.Option(\n        False,\n        \"--merge/--overwrite\",\n        help=\"Merge codemeta.json with with an existing codemeta.json file (default: False)\",\n    ),\n    pass_validation: Optional[bool] = typer.Option(\n        False,\n        \"--pass-validation\",\n        \"-P\",\n        help=\"Pass validation of metadata files (default: False)\",\n    ),\n    packages: Optional[List[Path]] = typer.Option(\n        None,\n        \"--packages\",\n        \"-k\",\n        help=\"Packages (subfolders) for monorepos with their own somesy config.\",\n        **existing_file_arg_config,\n    ),\n):\n    \"\"\"Sync project metadata input with metadata files.\"\"\"\n    somesy_input = resolved_somesy_input(\n        input_file=input_file,\n        no_sync_cff=no_sync_cff,\n        cff_file=cff_file,\n        no_sync_pyproject=no_sync_pyproject,\n        pyproject_file=pyproject_file,\n        no_sync_package_json=no_sync_package_json,\n        package_json_file=package_json_file,\n        no_sync_codemeta=no_sync_codemeta,\n        codemeta_file=codemeta_file,\n        no_sync_julia=no_sync_julia,\n        julia_file=julia_file,\n        no_sync_fortran=no_sync_fortran,\n        fortran_file=fortran_file,\n        no_sync_pom_xml=no_sync_pom_xml,\n        pom_xml_file=pom_xml_file,\n        no_sync_mkdocs=no_sync_mkdocs,\n        mkdocs_file=mkdocs_file,\n        no_sync_rust=no_sync_rust,\n        rust_file=rust_file,\n        merge_codemeta=merge_codemeta,\n        pass_validation=pass_validation,\n        packages=packages,\n    )\n\n    run_sync(somesy_input)\n</code></pre>"},{"location":"reference/somesy/cli/sync/#somesy.cli.sync.run_sync","title":"run_sync","text":"<pre><code>run_sync(somesy_input: SomesyInput)\n</code></pre> <p>Write log messages and run synchronization based on passed config.</p> Source code in <code>src/somesy/cli/sync.py</code> <pre><code>def run_sync(somesy_input: SomesyInput):\n    \"\"\"Write log messages and run synchronization based on passed config.\"\"\"\n    conf = somesy_input.config\n    logger.info(\"[bold green]Synchronizing project metadata...[/bold green]\")\n    logger.info(\"Files to sync:\")\n    if not conf.no_sync_pyproject:\n        logger.info(\n            f\"  - [italic]pyproject.toml[/italic]:\\t[grey]{conf.pyproject_file}[/grey]\"\n        )\n    if not conf.no_sync_package_json:\n        logger.info(\n            f\"  - [italic]package.json[/italic]:\\t[grey]{conf.package_json_file}[/grey]\"\n        )\n    if not conf.no_sync_julia:\n        logger.info(\n            f\"  - [italic]Project.toml[/italic]:\\t[grey]{conf.julia_file}[/grey]\\n\"\n        )\n    if not conf.no_sync_fortran:\n        logger.info(\n            f\"  - [italic]fpm.toml(fortran)[/italic]:\\t[grey]{conf.fortran_file}[/grey]\"\n        )\n    if not conf.no_sync_pom_xml:\n        logger.info(\n            f\"  - [italic]pom.xml[/italic]:\\t[grey]{conf.pom_xml_file}[/grey]\\n\"\n        )\n    if not conf.no_sync_mkdocs:\n        logger.info(\n            f\"  - [italic]mkdocs.yml[/italic]:\\t[grey]{conf.mkdocs_file}[/grey]\"\n        )\n    if not conf.no_sync_rust:\n        logger.info(f\"  - [italic]Cargo.toml[/italic]:\\t[grey]{conf.rust_file}[/grey]\")\n\n    if not conf.no_sync_cff:\n        logger.info(f\"  - [italic]CITATION.cff[/italic]:\\t[grey]{conf.cff_file}[/grey]\")\n    if not conf.no_sync_codemeta:\n        logger.info(\n            f\"  - [italic]codemeta.json[/italic]:\\t[grey]{conf.codemeta_file}[/grey]\\n\"\n        )\n    # ----\n    if conf.pass_validation:\n        logger.info(\"[bold yellow]Passing validation of metadata files.[/bold yellow]\")\n    sync_command(somesy_input)\n    # ----\n    logger.info(\"[bold green]Metadata synchronization completed.[/bold green]\")\n</code></pre>"},{"location":"reference/somesy/cli/util/","title":"util","text":"<p>Utility functions for CLI commands.</p>"},{"location":"reference/somesy/cli/util/#somesy.cli.util.wrap_exceptions","title":"wrap_exceptions","text":"<pre><code>wrap_exceptions(wrapped, instance, args, kwargs)\n</code></pre> <p>Format and log exceptions for cli commands.</p> Source code in <code>src/somesy/cli/util.py</code> <pre><code>@wrapt.decorator\ndef wrap_exceptions(wrapped, instance, args, kwargs):\n    \"\"\"Format and log exceptions for cli commands.\"\"\"\n    try:\n        return wrapped(*args, **kwargs)\n\n    except Exception as e:\n        # Escape the error message to prevent Rich from misinterpreting it\n        escaped_error_message = escape(str(e))\n        escaped_traceback = escape(traceback.format_exc())\n\n        logger.error(f\"[bold red]Error: {escaped_error_message}[/bold red]\")\n        logger.debug(f\"[red]{escaped_traceback}[/red]\")\n        raise typer.Exit(code=1) from e\n</code></pre>"},{"location":"reference/somesy/cli/util/#somesy.cli.util.resolved_somesy_input","title":"resolved_somesy_input","text":"<pre><code>resolved_somesy_input(**cli_args) -&gt; SomesyInput\n</code></pre> <p>Return a combined <code>SomesyInput</code> based on config file and passed CLI args.</p> <p>Will also adjust log levels accordingly.</p> Source code in <code>src/somesy/cli/util.py</code> <pre><code>def resolved_somesy_input(**cli_args) -&gt; SomesyInput:\n    \"\"\"Return a combined `SomesyInput` based on config file and passed CLI args.\n\n    Will also adjust log levels accordingly.\n    \"\"\"\n    # figure out what input file to use\n    input_file = discover_input(cli_args.pop(\"input_file\", None))\n\n    # create config based on passed arguments\n    passed_args = {k: v for k, v in cli_args.items() if v is not None}\n    somesy_conf = SomesyConfig(input_file=input_file, **passed_args)\n\n    # cli_log_level is None if the user did not pass a log level (-&gt; \"default\")\n    cli_log_level: Optional[SomesyLogLevel] = get_log_level()\n\n    if cli_log_level is not None:\n        # update log level flags if cli log level was set\n        somesy_conf.update_log_level(cli_log_level)\n\n    somesy_input: SomesyInput = somesy_conf.get_input()\n\n    if cli_log_level is None:\n        # no cli log level -&gt; set it according to the loaded configuration\n        set_log_level(somesy_input.config.log_level())\n\n    logger.debug(\n        f\"Combined config (Defaults + File + CLI):\\n{pretty_repr(somesy_input.config)}\"\n    )\n    return somesy_input\n</code></pre>"},{"location":"reference/somesy/codemeta/","title":"codemeta","text":"<p>Integration with codemeta.json (to re-generate codemeta as part of somesy sync).</p>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta","title":"CodeMeta","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Codemeta.json parser and saver.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>class CodeMeta(ProjectMetadataWriter):\n    \"\"\"Codemeta.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        merge: Optional[bool] = False,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Codemeta.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self.merge = merge\n        self._default_context = [\n            \"https://doi.org/10.5063/schema/codemeta-2.0\",\n            \"https://w3id.org/software-iodata\",\n            \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n            \"https://schema.org\",\n            \"https://w3id.org/software-types\",\n        ]\n        mappings: FieldKeyMapping = {\n            \"repository\": [\"codeRepository\"],\n            \"homepage\": [\"softwareHelp\"],\n            \"documentation\": [\"buildInstructions\"],\n            \"keywords\": [\"keywords\"],\n            \"authors\": [\"author\"],\n            \"maintainers\": [\"maintainer\"],\n            \"contributors\": [\"contributor\"],\n        }\n        # delete the file if it exists\n        if path.is_file() and not self.merge:\n            logger.verbose(\"Deleting existing codemeta.json file.\")\n            path.unlink()\n        super().__init__(\n            path,\n            create_if_not_exists=True,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n        # if merge is True, add necessary keys to the codemeta.json file\n        if self.merge:\n            # check if the context exists but is not a list\n            if isinstance(self._data[\"@context\"], str):\n                self._data[\"@context\"] = [self._data[\"@context\"]]\n            # finally add each item in the context to the codemeta.json file if it does not exist in the list\n            for item in self._default_context:\n                if item not in self._data[\"@context\"]:\n                    self._data[\"@context\"].append(item)\n\n            # add (or overwrite) the type\n            self._data[\"@type\"] = \"SoftwareSourceCode\"\n\n            # overwrite authors, maintainers, contributors\n            self._data[\"author\"] = []\n            self._data[\"maintainer\"] = []\n            self._data[\"contributor\"] = []\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the codemeta.json file as list.\"\"\"\n        return self._get_property(self._get_key(\"publication_authors\")) or []\n\n    @authors.setter\n    def authors(self, authors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors_dict = [self._from_person(a) for a in authors]\n        self._set_property(self._get_key(\"authors\"), authors_dict)\n\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the codemeta.json file.\"\"\"\n        return self._get_property(self._get_key(\"contributors\"))\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contributors_dict = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors_dict)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load codemeta.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate codemeta.json content using pydantic class.\"\"\"\n        if self.pass_validation:\n            return\n        invalid_fields = validate_codemeta(self._data)\n        if invalid_fields and self.merge:\n            raise ValueError(\n                f\"Invalid fields in codemeta.json: {invalid_fields}. Cannot merge with invalid fields.\"\n            )\n\n    def _init_new_file(self) -&gt; None:\n        \"\"\"Create a new codemeta.json file with bare minimum generic data.\"\"\"\n        data = {\n            \"@context\": [\n                \"https://doi.org/10.5063/schema/codemeta-2.0\",\n                \"https://w3id.org/software-iodata\",\n                \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n                \"https://schema.org\",\n                \"https://w3id.org/software-types\",\n            ],\n            \"@type\": \"SoftwareSourceCode\",\n            \"author\": [],\n        }\n        # dump to file\n        with self.path.open(\"w+\") as f:\n            json.dump(data, f)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the codemeta.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving codemeta.json to {path}\")\n\n        # copy the _data\n        data = self._data.copy()\n\n        # set license\n        if \"license\" in data:\n            data[\"license\"] = (f\"https://spdx.org/licenses/{data['license']}\",)\n\n        # if softwareHelp is set, set url to softwareHelp\n        if \"softwareHelp\" in data:\n            data[\"url\"] = data[\"softwareHelp\"]\n\n        with path.open(\"w\") as f:\n            # codemeta.json indentation is 2 spaces\n            json.dump(data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]) -&gt; dict:\n        \"\"\"Convert project metadata person object to codemeta.json dict for person format.\"\"\"\n        if isinstance(person, Person):\n            person_dict = {\n                \"@type\": \"Person\",\n            }\n            if person.given_names:\n                person_dict[\"givenName\"] = person.given_names\n            if person.family_names:\n                person_dict[\"familyName\"] = person.family_names\n            if person.email:\n                person_dict[\"email\"] = person.email\n            if person.orcid:\n                person_dict[\"@id\"] = str(person.orcid)\n                person_dict[\"identifier\"] = str(person.orcid)\n            if person.address:\n                person_dict[\"address\"] = person.address\n            if person.affiliation:\n                person_dict[\"affiliation\"] = person.affiliation\n            return person_dict\n        else:\n            entity_dict = {\"@type\": \"Organization\", \"name\": person.name}\n            if person.address:\n                entity_dict[\"address\"] = person.address\n            if person.email:\n                entity_dict[\"email\"] = person.email\n            if person.date_start:\n                entity_dict[\"startDate\"] = person.date_start.isoformat()\n            if person.date_end:\n                entity_dict[\"endDate\"] = person.date_end.isoformat()\n            if person.website:\n                entity_dict[\"@id\"] = str(person.website)\n                entity_dict[\"identifier\"] = str(person.website)\n            if person.rorid:\n                entity_dict[\"@id\"] = str(person.rorid)\n                entity_dict[\"identifier\"] = str(person.rorid)\n            return entity_dict\n\n    @staticmethod\n    def _to_person(person) -&gt; Union[Person, Entity]:\n        \"\"\"Convert codemeta.json dict or str for person/entity format to project metadata person object.\"\"\"\n        if \"name\" in person:\n            entity_obj = {\"name\": person[\"name\"]}\n            return Entity(**entity_obj)\n        else:\n            person_obj = {}\n            if \"givenName\" in person:\n                person_obj[\"given_names\"] = person[\"givenName\"].strip()\n            if \"familyName\" in person:\n                person_obj[\"family_names\"] = person[\"familyName\"].strip()\n            if \"email\" in person:\n                person_obj[\"email\"] = person[\"email\"].strip()\n            if \"@id\" in person:\n                person_obj[\"orcid\"] = person[\"@id\"].strip()\n            if \"address\" in person:\n                person_obj[\"address\"] = person[\"address\"].strip()\n\n            return Person(**person_obj)\n\n    def _sync_person_list(\n        self, old: List[Any], new: List[Union[Person, Entity]]\n    ) -&gt; List[Any]:\n        \"\"\"Override the _sync_person_list function from ProjectMetadataWriter.\n\n        This method wont care about existing persons in codemeta.json file.\n\n        Args:\n            old (List[Any]): existing persons in codemeta.json file, in this case ignored in the output. However, it is necessary to make the function compatible with the parent class.\n            new (List[Person]): new persons to add to codemeta.json file\n\n        Returns:\n            List[Any]: list of new persons to add to codemeta.json file\n\n        \"\"\"\n        return new\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync codemeta.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = metadata.contributors()\n\n        # add the default context items if they are not already in the codemeta.json file\n        for item in self._default_context:\n            if item not in self._data[\"@context\"]:\n                self._data[\"@context\"].append(item)\n</code></pre>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the codemeta.json file as list.</p>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the codemeta.json file.</p>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False,\n)\n</code></pre> <p>Codemeta.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Codemeta.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self.merge = merge\n    self._default_context = [\n        \"https://doi.org/10.5063/schema/codemeta-2.0\",\n        \"https://w3id.org/software-iodata\",\n        \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n        \"https://schema.org\",\n        \"https://w3id.org/software-types\",\n    ]\n    mappings: FieldKeyMapping = {\n        \"repository\": [\"codeRepository\"],\n        \"homepage\": [\"softwareHelp\"],\n        \"documentation\": [\"buildInstructions\"],\n        \"keywords\": [\"keywords\"],\n        \"authors\": [\"author\"],\n        \"maintainers\": [\"maintainer\"],\n        \"contributors\": [\"contributor\"],\n    }\n    # delete the file if it exists\n    if path.is_file() and not self.merge:\n        logger.verbose(\"Deleting existing codemeta.json file.\")\n        path.unlink()\n    super().__init__(\n        path,\n        create_if_not_exists=True,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n\n    # if merge is True, add necessary keys to the codemeta.json file\n    if self.merge:\n        # check if the context exists but is not a list\n        if isinstance(self._data[\"@context\"], str):\n            self._data[\"@context\"] = [self._data[\"@context\"]]\n        # finally add each item in the context to the codemeta.json file if it does not exist in the list\n        for item in self._default_context:\n            if item not in self._data[\"@context\"]:\n                self._data[\"@context\"].append(item)\n\n        # add (or overwrite) the type\n        self._data[\"@type\"] = \"SoftwareSourceCode\"\n\n        # overwrite authors, maintainers, contributors\n        self._data[\"author\"] = []\n        self._data[\"maintainer\"] = []\n        self._data[\"contributor\"] = []\n</code></pre>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the codemeta.json file.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the codemeta.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving codemeta.json to {path}\")\n\n    # copy the _data\n    data = self._data.copy()\n\n    # set license\n    if \"license\" in data:\n        data[\"license\"] = (f\"https://spdx.org/licenses/{data['license']}\",)\n\n    # if softwareHelp is set, set url to softwareHelp\n    if \"softwareHelp\" in data:\n        data[\"url\"] = data[\"softwareHelp\"]\n\n    with path.open(\"w\") as f:\n        # codemeta.json indentation is 2 spaces\n        json.dump(data, f)\n</code></pre>"},{"location":"reference/somesy/codemeta/#somesy.codemeta.CodeMeta.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync codemeta.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync codemeta.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = metadata.contributors()\n\n    # add the default context items if they are not already in the codemeta.json file\n    for item in self._default_context:\n        if item not in self._data[\"@context\"]:\n            self._data[\"@context\"].append(item)\n</code></pre>"},{"location":"reference/somesy/codemeta/utils/","title":"utils","text":"<p>Utility functions for codemeta.json.</p>"},{"location":"reference/somesy/codemeta/utils/#somesy.codemeta.utils.validate_codemeta","title":"validate_codemeta","text":"<pre><code>validate_codemeta(codemeta: dict) -&gt; list\n</code></pre> <p>Validate the codemeta.json file against the codemeta.jsonld schema.</p> <p>Parameters:</p> Name Type Description Default <code>codemeta</code> <code>dict</code> <p>codemeta.json file as a dictionary.</p> required <p>Returns:</p> Name Type Description <code>invalid_fields</code> <code>list</code> <p>List of invalid fields.</p> Source code in <code>src/somesy/codemeta/utils.py</code> <pre><code>def validate_codemeta(codemeta: dict) -&gt; list:\n    \"\"\"Validate the codemeta.json file against the codemeta.jsonld schema.\n\n    Args:\n        codemeta (dict): codemeta.json file as a dictionary.\n\n    Returns:\n        invalid_fields (list): List of invalid fields.\n\n    \"\"\"\n    schema_path = Path(__file__).parent / \"schema-2.jsonld\"\n    invalid_fields = []\n\n    # Check for required fields\n    required_fields = {\"@context\", \"@type\", \"name\"}\n    missing_fields = [field for field in required_fields if field not in codemeta]\n    if missing_fields:\n        invalid_fields.extend(missing_fields)\n\n    # Validate @context\n    codemeta_context = codemeta.get(\"@context\", [])\n    if isinstance(codemeta_context, str):\n        codemeta_context = [codemeta_context]\n    if V2_DOI not in codemeta_context:\n        invalid_fields.append(\"@context\")\n        logger.warning(\n            \"The @context field in codemeta.json does not contain the Codemeta v2 DOI.\"\n        )\n\n    try:\n        # Load Codemeta JSON-LD Schema\n        with open(schema_path, \"r\", encoding=\"utf-8\") as f:\n            schema = json.load(f)\n\n        # Use schema's context to avoid network fetch issues\n        schema_context = schema[\"@context\"]\n        codemeta_copy = copy.deepcopy(codemeta)\n        codemeta_copy[\"@context\"] = schema_context\n\n        # Expand and compact to validate terms\n        expanded = jsonld.expand(codemeta_copy)\n        compacted = jsonld.compact(expanded, schema_context)\n\n        # Check for unmapped fields (fields with ':' indicating schema prefix)\n        compacted_keys = compacted.keys()\n        for key in compacted_keys:\n            if \":\" in key:\n                logger.error(f\"Invalid schema reference found: {key}\")\n                invalid_fields.append(key)\n\n        # Check for unsupported terms by comparing original and compacted keys\n        original_keys = set(codemeta.keys())\n        compacted_keys = set(compacted.keys())\n\n        # Remove @type from comparison as it might be handled differently in compaction\n        if \"@type\" in original_keys:\n            original_keys.remove(\"@type\")\n        if \"@type\" in compacted_keys:\n            compacted_keys.remove(\"@type\")\n\n        unsupported_terms = original_keys - compacted_keys\n        if unsupported_terms:\n            logger.warning(f\"Unsupported terms found: {sorted(unsupported_terms)}\")\n            invalid_fields.extend(unsupported_terms)\n\n    except Exception as e:\n        logger.error(f\"Codemeta validation failed: {e}\")\n        return [\"Validation error\"]\n\n    return list(set(invalid_fields))  # Remove duplicates\n</code></pre>"},{"location":"reference/somesy/codemeta/writer/","title":"writer","text":"<p>codemeta.json creation module.</p>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta","title":"CodeMeta","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Codemeta.json parser and saver.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>class CodeMeta(ProjectMetadataWriter):\n    \"\"\"Codemeta.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        merge: Optional[bool] = False,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Codemeta.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self.merge = merge\n        self._default_context = [\n            \"https://doi.org/10.5063/schema/codemeta-2.0\",\n            \"https://w3id.org/software-iodata\",\n            \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n            \"https://schema.org\",\n            \"https://w3id.org/software-types\",\n        ]\n        mappings: FieldKeyMapping = {\n            \"repository\": [\"codeRepository\"],\n            \"homepage\": [\"softwareHelp\"],\n            \"documentation\": [\"buildInstructions\"],\n            \"keywords\": [\"keywords\"],\n            \"authors\": [\"author\"],\n            \"maintainers\": [\"maintainer\"],\n            \"contributors\": [\"contributor\"],\n        }\n        # delete the file if it exists\n        if path.is_file() and not self.merge:\n            logger.verbose(\"Deleting existing codemeta.json file.\")\n            path.unlink()\n        super().__init__(\n            path,\n            create_if_not_exists=True,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n        # if merge is True, add necessary keys to the codemeta.json file\n        if self.merge:\n            # check if the context exists but is not a list\n            if isinstance(self._data[\"@context\"], str):\n                self._data[\"@context\"] = [self._data[\"@context\"]]\n            # finally add each item in the context to the codemeta.json file if it does not exist in the list\n            for item in self._default_context:\n                if item not in self._data[\"@context\"]:\n                    self._data[\"@context\"].append(item)\n\n            # add (or overwrite) the type\n            self._data[\"@type\"] = \"SoftwareSourceCode\"\n\n            # overwrite authors, maintainers, contributors\n            self._data[\"author\"] = []\n            self._data[\"maintainer\"] = []\n            self._data[\"contributor\"] = []\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the codemeta.json file as list.\"\"\"\n        return self._get_property(self._get_key(\"publication_authors\")) or []\n\n    @authors.setter\n    def authors(self, authors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors_dict = [self._from_person(a) for a in authors]\n        self._set_property(self._get_key(\"authors\"), authors_dict)\n\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the codemeta.json file.\"\"\"\n        return self._get_property(self._get_key(\"contributors\"))\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contributors_dict = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors_dict)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load codemeta.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate codemeta.json content using pydantic class.\"\"\"\n        if self.pass_validation:\n            return\n        invalid_fields = validate_codemeta(self._data)\n        if invalid_fields and self.merge:\n            raise ValueError(\n                f\"Invalid fields in codemeta.json: {invalid_fields}. Cannot merge with invalid fields.\"\n            )\n\n    def _init_new_file(self) -&gt; None:\n        \"\"\"Create a new codemeta.json file with bare minimum generic data.\"\"\"\n        data = {\n            \"@context\": [\n                \"https://doi.org/10.5063/schema/codemeta-2.0\",\n                \"https://w3id.org/software-iodata\",\n                \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n                \"https://schema.org\",\n                \"https://w3id.org/software-types\",\n            ],\n            \"@type\": \"SoftwareSourceCode\",\n            \"author\": [],\n        }\n        # dump to file\n        with self.path.open(\"w+\") as f:\n            json.dump(data, f)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the codemeta.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving codemeta.json to {path}\")\n\n        # copy the _data\n        data = self._data.copy()\n\n        # set license\n        if \"license\" in data:\n            data[\"license\"] = (f\"https://spdx.org/licenses/{data['license']}\",)\n\n        # if softwareHelp is set, set url to softwareHelp\n        if \"softwareHelp\" in data:\n            data[\"url\"] = data[\"softwareHelp\"]\n\n        with path.open(\"w\") as f:\n            # codemeta.json indentation is 2 spaces\n            json.dump(data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]) -&gt; dict:\n        \"\"\"Convert project metadata person object to codemeta.json dict for person format.\"\"\"\n        if isinstance(person, Person):\n            person_dict = {\n                \"@type\": \"Person\",\n            }\n            if person.given_names:\n                person_dict[\"givenName\"] = person.given_names\n            if person.family_names:\n                person_dict[\"familyName\"] = person.family_names\n            if person.email:\n                person_dict[\"email\"] = person.email\n            if person.orcid:\n                person_dict[\"@id\"] = str(person.orcid)\n                person_dict[\"identifier\"] = str(person.orcid)\n            if person.address:\n                person_dict[\"address\"] = person.address\n            if person.affiliation:\n                person_dict[\"affiliation\"] = person.affiliation\n            return person_dict\n        else:\n            entity_dict = {\"@type\": \"Organization\", \"name\": person.name}\n            if person.address:\n                entity_dict[\"address\"] = person.address\n            if person.email:\n                entity_dict[\"email\"] = person.email\n            if person.date_start:\n                entity_dict[\"startDate\"] = person.date_start.isoformat()\n            if person.date_end:\n                entity_dict[\"endDate\"] = person.date_end.isoformat()\n            if person.website:\n                entity_dict[\"@id\"] = str(person.website)\n                entity_dict[\"identifier\"] = str(person.website)\n            if person.rorid:\n                entity_dict[\"@id\"] = str(person.rorid)\n                entity_dict[\"identifier\"] = str(person.rorid)\n            return entity_dict\n\n    @staticmethod\n    def _to_person(person) -&gt; Union[Person, Entity]:\n        \"\"\"Convert codemeta.json dict or str for person/entity format to project metadata person object.\"\"\"\n        if \"name\" in person:\n            entity_obj = {\"name\": person[\"name\"]}\n            return Entity(**entity_obj)\n        else:\n            person_obj = {}\n            if \"givenName\" in person:\n                person_obj[\"given_names\"] = person[\"givenName\"].strip()\n            if \"familyName\" in person:\n                person_obj[\"family_names\"] = person[\"familyName\"].strip()\n            if \"email\" in person:\n                person_obj[\"email\"] = person[\"email\"].strip()\n            if \"@id\" in person:\n                person_obj[\"orcid\"] = person[\"@id\"].strip()\n            if \"address\" in person:\n                person_obj[\"address\"] = person[\"address\"].strip()\n\n            return Person(**person_obj)\n\n    def _sync_person_list(\n        self, old: List[Any], new: List[Union[Person, Entity]]\n    ) -&gt; List[Any]:\n        \"\"\"Override the _sync_person_list function from ProjectMetadataWriter.\n\n        This method wont care about existing persons in codemeta.json file.\n\n        Args:\n            old (List[Any]): existing persons in codemeta.json file, in this case ignored in the output. However, it is necessary to make the function compatible with the parent class.\n            new (List[Person]): new persons to add to codemeta.json file\n\n        Returns:\n            List[Any]: list of new persons to add to codemeta.json file\n\n        \"\"\"\n        return new\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync codemeta.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = metadata.contributors()\n\n        # add the default context items if they are not already in the codemeta.json file\n        for item in self._default_context:\n            if item not in self._data[\"@context\"]:\n                self._data[\"@context\"].append(item)\n</code></pre>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the codemeta.json file as list.</p>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the codemeta.json file.</p>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False,\n)\n</code></pre> <p>Codemeta.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Codemeta.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self.merge = merge\n    self._default_context = [\n        \"https://doi.org/10.5063/schema/codemeta-2.0\",\n        \"https://w3id.org/software-iodata\",\n        \"https://raw.githubusercontent.com/jantman/repostatus.org/master/badges/latest/ontology.jsonld\",\n        \"https://schema.org\",\n        \"https://w3id.org/software-types\",\n    ]\n    mappings: FieldKeyMapping = {\n        \"repository\": [\"codeRepository\"],\n        \"homepage\": [\"softwareHelp\"],\n        \"documentation\": [\"buildInstructions\"],\n        \"keywords\": [\"keywords\"],\n        \"authors\": [\"author\"],\n        \"maintainers\": [\"maintainer\"],\n        \"contributors\": [\"contributor\"],\n    }\n    # delete the file if it exists\n    if path.is_file() and not self.merge:\n        logger.verbose(\"Deleting existing codemeta.json file.\")\n        path.unlink()\n    super().__init__(\n        path,\n        create_if_not_exists=True,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n\n    # if merge is True, add necessary keys to the codemeta.json file\n    if self.merge:\n        # check if the context exists but is not a list\n        if isinstance(self._data[\"@context\"], str):\n            self._data[\"@context\"] = [self._data[\"@context\"]]\n        # finally add each item in the context to the codemeta.json file if it does not exist in the list\n        for item in self._default_context:\n            if item not in self._data[\"@context\"]:\n                self._data[\"@context\"].append(item)\n\n        # add (or overwrite) the type\n        self._data[\"@type\"] = \"SoftwareSourceCode\"\n\n        # overwrite authors, maintainers, contributors\n        self._data[\"author\"] = []\n        self._data[\"maintainer\"] = []\n        self._data[\"contributor\"] = []\n</code></pre>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the codemeta.json file.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the codemeta.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving codemeta.json to {path}\")\n\n    # copy the _data\n    data = self._data.copy()\n\n    # set license\n    if \"license\" in data:\n        data[\"license\"] = (f\"https://spdx.org/licenses/{data['license']}\",)\n\n    # if softwareHelp is set, set url to softwareHelp\n    if \"softwareHelp\" in data:\n        data[\"url\"] = data[\"softwareHelp\"]\n\n    with path.open(\"w\") as f:\n        # codemeta.json indentation is 2 spaces\n        json.dump(data, f)\n</code></pre>"},{"location":"reference/somesy/codemeta/writer/#somesy.codemeta.writer.CodeMeta.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync codemeta.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/codemeta/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync codemeta.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = metadata.contributors()\n\n    # add the default context items if they are not already in the codemeta.json file\n    for item in self._default_context:\n        if item not in self._data[\"@context\"]:\n            self._data[\"@context\"].append(item)\n</code></pre>"},{"location":"reference/somesy/commands/","title":"commands","text":"<p>Commands for somesy.</p>"},{"location":"reference/somesy/commands/init_config/","title":"init_config","text":"<p>CLI command to initialize somesy configuration file.</p>"},{"location":"reference/somesy/commands/init_config/#somesy.commands.init_config.init_config","title":"init_config","text":"<pre><code>init_config(input_path: Path, options: dict) -&gt; None\n</code></pre> <p>Initialize somesy configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Path</code> <p>Path to somesy file (will be created/overwritten).</p> required <code>options</code> <code>dict</code> <p>CLI options.</p> required Source code in <code>src/somesy/commands/init_config.py</code> <pre><code>def init_config(input_path: Path, options: dict) -&gt; None:\n    \"\"\"Initialize somesy configuration file.\n\n    Args:\n        input_path (Path): Path to somesy file (will be created/overwritten).\n        options (dict): CLI options.\n\n    \"\"\"\n    logger.info(f\"Updating input file ({input_path}) with CLI configurations...\")\n\n    content = get_input_content(input_path, no_unwrap=True)\n\n    is_somesy = SomesyInput.is_somesy_file_path(input_path)\n    input_file_type = \"somesy\" if is_somesy else \"pyproject\"\n    msg = f\"Found input file with {input_file_type} format.\"\n    logger.verbose(msg)\n\n    logger.debug(f\"Input file content: {options}\")\n\n    if \"input_file\" in options:\n        del options[\"input_file\"]\n    if is_somesy:\n        content[\"config\"] = options\n    else:\n        if \"tool\" not in content:\n            content[\"tool\"] = {}\n        if \"somesy\" not in content[\"tool\"]:\n            content[\"tool\"][\"somesy\"] = {}\n        content[\"tool\"][\"somesy\"][\"config\"] = options\n\n    with open(input_path, \"w\") as f:\n        tomlkit.dump(content, f)\n\n    logger.info(f\"Input file ({input_path}) updated.\")\n    logger.debug(f\"Input file content: {content}\")\n</code></pre>"},{"location":"reference/somesy/commands/sync/","title":"sync","text":"<p>Sync selected metadata files with given input file.</p>"},{"location":"reference/somesy/commands/sync/#somesy.commands.sync.sync","title":"sync","text":"<pre><code>sync(somesy_input: SomesyInput, is_package: bool = False)\n</code></pre> <p>Sync selected metadata files with given input file.</p> <p>Parameters:</p> Name Type Description Default <code>somesy_input</code> <code>SomesyInput</code> <p>The input configuration and metadata to sync</p> required <code>is_package</code> <code>bool</code> <p>Whether this is a package (subfolder) being synced</p> <code>False</code> Source code in <code>src/somesy/commands/sync.py</code> <pre><code>def sync(somesy_input: SomesyInput, is_package: bool = False):\n    \"\"\"Sync selected metadata files with given input file.\n\n    Args:\n        somesy_input: The input configuration and metadata to sync\n        is_package: Whether this is a package (subfolder) being synced\n\n    \"\"\"\n    conf, metadata = somesy_input.config, somesy_input.project\n\n    # Get the base directory from the input file's location\n    try:\n        base_dir = somesy_input._origin.parent\n    except AttributeError:\n        logger.warning(\n            \"No origin found for somesy input, using current working directory.\"\n        )\n        base_dir = Path.cwd()\n\n    # Resolve all paths in the config relative to the base directory\n    conf.resolve_paths(base_dir)\n\n    if is_package:\n        logger.info(\"\\n[bold green]Synchronizing package metadata...[/bold green]\")\n    else:\n        logger.info(\"\\n[bold green]Synchronizing root project metadata...[/bold green]\")\n\n    pp_metadata = pretty_repr(metadata.model_dump(exclude_defaults=True))\n    logger.debug(f\"Project metadata: {pp_metadata}\")\n\n    # First sync the current project\n    _sync_root_project(conf, metadata)\n\n    # Then sync each package if defined\n    if conf.packages:\n        packages = [conf.packages] if isinstance(conf.packages, Path) else conf.packages\n        for package in packages:\n            logger.info(f\"\\n[bold blue]Processing package {package}...[/bold blue]\")\n\n            # Try all possible input files in order of priority\n            config_files = [package / file for file in INPUT_FILES_ORDERED]\n            package_input = None\n\n            for config_file in config_files:\n                try:\n                    package_input = SomesyInput.from_input_file(config_file)\n                    logger.debug(f\"Found config file: {config_file}\")\n                    break\n                except (FileNotFoundError, RuntimeError):\n                    continue\n\n            if package_input is None:\n                logger.warning(\n                    f\"No valid somesy config found in package {package} \"\n                    f\"(tried: {', '.join(str(f) for f in config_files)})\"\n                )\n                continue\n\n            # Create new config with CLI options and package's input file\n            cli_options = {\n                \"no_sync_pyproject\": conf.no_sync_pyproject,\n                \"no_sync_package_json\": conf.no_sync_package_json,\n                \"no_sync_julia\": conf.no_sync_julia,\n                \"no_sync_fortran\": conf.no_sync_fortran,\n                \"no_sync_pom_xml\": conf.no_sync_pom_xml,\n                \"no_sync_mkdocs\": conf.no_sync_mkdocs,\n                \"no_sync_rust\": conf.no_sync_rust,\n                \"no_sync_cff\": conf.no_sync_cff,\n                \"no_sync_codemeta\": conf.no_sync_codemeta,\n                \"merge_codemeta\": conf.merge_codemeta,\n                \"pass_validation\": conf.pass_validation,\n                \"packages\": None,  # Don't pass packages to avoid recursive package handling\n            }\n            package_input.config = SomesyConfig(input_file=config_file, **cli_options)\n\n            # Set default CFF and CodeMeta paths in package directory if not specified\n            if not package_input.config.no_sync_cff:\n                package_input.config.cff_file = Path(\"CITATION.cff\")\n            if not package_input.config.no_sync_codemeta:\n                package_input.config.codemeta_file = Path(\"codemeta.json\")\n\n            # Recursively call sync on the package\n            sync(package_input, is_package=True)\n</code></pre>"},{"location":"reference/somesy/core/","title":"core","text":"<p>Somesy core module.</p>"},{"location":"reference/somesy/core/core/","title":"core","text":"<p>Core somesy functions.</p>"},{"location":"reference/somesy/core/core/#somesy.core.core.INPUT_FILES_ORDERED","title":"INPUT_FILES_ORDERED  <code>module-attribute</code>","text":"<pre><code>INPUT_FILES_ORDERED = [\n    \".somesy.toml\",\n    \"somesy.toml\",\n    \"pyproject.toml\",\n    \"package.json\",\n    \"Project.toml\",\n    \"fpm.toml\",\n    \"Cargo.toml\",\n]\n</code></pre> <p>Input files ordered by priority for discovery.</p>"},{"location":"reference/somesy/core/core/#somesy.core.core.discover_input","title":"discover_input","text":"<pre><code>discover_input(input_file: Optional[Path] = None) -&gt; Path\n</code></pre> <p>Check given input file path. If not given, find somesy configuration file path from default list.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>Optional[Path]</code> <p>somesy configuration file path. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised if no somesy input file found from cli input or the defaults.</p> <p>Returns:</p> Type Description <code>Path</code> <p>somesy configuration file path.</p> Source code in <code>src/somesy/core/core.py</code> <pre><code>def discover_input(input_file: Optional[Path] = None) -&gt; Path:\n    \"\"\"Check given input file path. If not given, find somesy configuration file path from default list.\n\n    Args:\n        input_file: somesy configuration file path. Defaults to None.\n\n    Raises:\n        FileNotFoundError: Raised if no somesy input file found from cli input or the defaults.\n\n    Returns:\n        somesy configuration file path.\n\n    \"\"\"\n    if input_file:\n        if input_file.is_file():\n            logger.info(f\"Using provided file '{input_file}' as somesy input file.\")\n            return input_file\n        else:\n            msg = f\"Passed file '{input_file}' does not exist. Searching for usable somesy input file...\"\n            logger.verbose(msg)\n\n    for filename in INPUT_FILES_ORDERED:\n        input_file = Path(filename)\n        if input_file.is_file():\n            try:\n                get_input_content(input_file)\n            except RuntimeError:\n                continue\n\n            msg = f\"Using '{input_file}' as somesy input file.\"\n            logger.verbose(msg)\n            return input_file\n\n    raise FileNotFoundError(\"No somesy input file found.\")\n</code></pre>"},{"location":"reference/somesy/core/core/#somesy.core.core.get_input_content","title":"get_input_content","text":"<pre><code>get_input_content(\n    path: Path, *, no_unwrap: bool = False\n) -&gt; Dict[str, Any]\n</code></pre> <p>Read contents of a supported somesy input file.</p> <p>Given a path to a TOML file, this function reads the file and returns its content as a TOMLDocument object. The function checks if the file is a valid somesy input file by checking its name and content.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>path to the input file</p> required <code>no_unwrap</code> <code>bool</code> <p>if True, the function returns the TOMLDocument object instead of unwrapping it</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>the content of the input file as a TOMLDocument object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the input file is not a valid somesy input file or if the file is not a TOML file.</p> <code>RuntimeError</code> <p>if the input file does not contain a somesy input section at expected key</p> Source code in <code>src/somesy/core/core.py</code> <pre><code>def get_input_content(path: Path, *, no_unwrap: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Read contents of a supported somesy input file.\n\n    Given a path to a TOML file, this function reads the file and returns its content as a TOMLDocument object.\n    The function checks if the file is a valid somesy input file by checking its name and content.\n\n    Args:\n        path (Path): path to the input file\n        no_unwrap (bool): if True, the function returns the TOMLDocument object instead of unwrapping it\n\n    Returns:\n        the content of the input file as a TOMLDocument object\n\n    Raises:\n        ValueError: if the input file is not a valid somesy input file or if the file is not a TOML file.\n        RuntimeError: if the input file does not contain a somesy input section at expected key\n\n    \"\"\"\n    logger.debug(f\"Path {path}\")\n    # somesy.toml / .somesy.toml\n    if path.suffix == \".toml\" and \"somesy\" in path.name:\n        with open(path, \"r\") as f:\n            ret = tomlkit.load(f)\n            return ret if no_unwrap else ret.unwrap()\n\n    # pyproject.toml or fpm.toml\n    if (path.suffix == \".toml\" and \"pyproject\" in path.name) or path.name in [\n        \"Project.toml\",\n        \"fpm.toml\",\n    ]:\n        with open(path, \"r\") as f:\n            input_content = tomlkit.load(f)\n            if \"tool\" in input_content and \"somesy\" in input_content[\"tool\"]:\n                return input_content[\"tool\"][\"somesy\"].unwrap()\n            else:\n                raise RuntimeError(\n                    \"No tool.somesy section found in pyproject.toml file!\"\n                )\n\n    # Cargo.toml\n    if path.name == \"Cargo.toml\":\n        with open(path, \"r\") as f:\n            input_content = tomlkit.load(f)\n            if (\n                \"package\" in input_content\n                and \"metadata\" in input_content[\"package\"]\n                and \"somesy\" in input_content[\"package\"][\"metadata\"]\n            ):\n                return input_content[\"package\"][\"metadata\"][\"somesy\"].unwrap()\n            else:\n                raise RuntimeError(\n                    \"No package.somesy section found in Cargo.toml file!\"\n                )\n\n    # package.json\n    if path.suffix == \".json\" and \"package\" in path.name:\n        with open(path, \"r\") as f:\n            input_content = json.load(f)\n            if \"somesy\" in input_content:\n                return input_content[\"somesy\"]\n            else:\n                raise RuntimeError(\"No somesy section found in package.json file!\")\n\n    # no match:\n    raise ValueError(\"Unsupported input file.\")\n</code></pre>"},{"location":"reference/somesy/core/log/","title":"log","text":"<p>Somesy log configuration.</p>"},{"location":"reference/somesy/core/log/#somesy.core.log.VERBOSE","title":"VERBOSE  <code>module-attribute</code>","text":"<pre><code>VERBOSE: int = 15\n</code></pre> <p>Custom logging level between INFO and DEBUG.</p>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel","title":"SomesyLogLevel","text":"<p>               Bases: <code>Enum</code></p> <p>Somesy-specific log levels.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>class SomesyLogLevel(Enum):\n    \"\"\"Somesy-specific log levels.\"\"\"\n\n    SILENT = auto()\n    INFO = auto()\n    VERBOSE = auto()\n    DEBUG = auto()\n\n    @staticmethod\n    def from_flags(\n        *,\n        info: Optional[bool] = None,\n        verbose: Optional[bool] = None,\n        debug: Optional[bool] = None,\n    ):\n        \"\"\"Convert CLI/config flags into a log level.\"\"\"\n        if debug:\n            return SomesyLogLevel.DEBUG\n        elif verbose:\n            return SomesyLogLevel.VERBOSE\n        elif info:\n            return SomesyLogLevel.INFO\n        return SomesyLogLevel.SILENT\n\n    @staticmethod\n    def to_logging(lv):\n        \"\"\"Convert a somesy log level into a logging log level.\"\"\"\n        if lv == SomesyLogLevel.SILENT:\n            return logging.WARNING\n        if lv == SomesyLogLevel.INFO:\n            return logging.INFO\n        if lv == SomesyLogLevel.VERBOSE:\n            return VERBOSE\n        if lv == SomesyLogLevel.DEBUG:\n            return logging.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel.from_flags","title":"from_flags  <code>staticmethod</code>","text":"<pre><code>from_flags(\n    *,\n    info: Optional[bool] = None,\n    verbose: Optional[bool] = None,\n    debug: Optional[bool] = None\n)\n</code></pre> <p>Convert CLI/config flags into a log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>@staticmethod\ndef from_flags(\n    *,\n    info: Optional[bool] = None,\n    verbose: Optional[bool] = None,\n    debug: Optional[bool] = None,\n):\n    \"\"\"Convert CLI/config flags into a log level.\"\"\"\n    if debug:\n        return SomesyLogLevel.DEBUG\n    elif verbose:\n        return SomesyLogLevel.VERBOSE\n    elif info:\n        return SomesyLogLevel.INFO\n    return SomesyLogLevel.SILENT\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.SomesyLogLevel.to_logging","title":"to_logging  <code>staticmethod</code>","text":"<pre><code>to_logging(lv)\n</code></pre> <p>Convert a somesy log level into a logging log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>@staticmethod\ndef to_logging(lv):\n    \"\"\"Convert a somesy log level into a logging log level.\"\"\"\n    if lv == SomesyLogLevel.SILENT:\n        return logging.WARNING\n    if lv == SomesyLogLevel.INFO:\n        return logging.INFO\n    if lv == SomesyLogLevel.VERBOSE:\n        return VERBOSE\n    if lv == SomesyLogLevel.DEBUG:\n        return logging.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.get_log_level","title":"get_log_level","text":"<pre><code>get_log_level() -&gt; Optional[SomesyLogLevel]\n</code></pre> <p>Return current user-defined log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def get_log_level() -&gt; Optional[SomesyLogLevel]:\n    \"\"\"Return current user-defined log level.\"\"\"\n    return _log_level\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.set_log_level","title":"set_log_level","text":"<pre><code>set_log_level(log_level: SomesyLogLevel) -&gt; None\n</code></pre> <p>Set the current log level.</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def set_log_level(log_level: SomesyLogLevel) -&gt; None:\n    \"\"\"Set the current log level.\"\"\"\n    global _log_level\n    # update current somesy log level\n    _log_level = log_level\n    # (re-)init logging (rich formatter config depends on passed log level)\n    init_log()\n    # set the current logging log level\n    logger.setLevel(SomesyLogLevel.to_logging(log_level))\n</code></pre>"},{"location":"reference/somesy/core/log/#somesy.core.log.init_log","title":"init_log","text":"<pre><code>init_log()\n</code></pre> <p>Initialize logging (add VERBOSE log level and Rich formatter).</p> Source code in <code>src/somesy/core/log.py</code> <pre><code>def init_log():\n    \"\"\"Initialize logging (add VERBOSE log level and Rich formatter).\"\"\"\n    _add_verbose_level()\n    _init_rich_handler(get_log_level())\n</code></pre>"},{"location":"reference/somesy/core/models/","title":"models","text":"<p>Core models for the somesy package.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel","title":"SomesyBaseModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Customized pydantic BaseModel for somesy.</p> <p>Apart from some general tweaks for better defaults, adds a private <code>_key_order</code> field, which is used to track the preferred order for serialization (usually coming from some existing input).</p> <p>It can be set on an instance using the set_key_order method, and is preserved by <code>copy()</code>.</p> <p>NOTE: The custom order is intended for leaf models (no further nested models), custom order will not work correctly across nesting layers.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyBaseModel(BaseModel):\n    \"\"\"Customized pydantic BaseModel for somesy.\n\n    Apart from some general tweaks for better defaults,\n    adds a private `_key_order` field, which is used to track the\n    preferred order for serialization (usually coming from some existing input).\n\n    It can be set on an instance using the set_key_order method,\n    and is preserved by `copy()`.\n\n    NOTE: The custom order is intended for leaf models (no further nested models),\n    custom order will not work correctly across nesting layers.\n    \"\"\"\n\n    model_config = dict(\n        extra=\"forbid\",\n        validate_assignment=True,\n        populate_by_name=True,\n        str_strip_whitespace=True,\n        str_min_length=1,\n    )\n\n    # ----\n    # Key order magic\n\n    _key_order: List[str] = PrivateAttr([])\n    \"\"\"List of field names (NOT aliases!) in the order they should be written in.\"\"\"\n\n    @classmethod\n    @functools.lru_cache()  # compute once per class\n    def _aliases(cls) -&gt; Dict[str, str]:\n        \"\"\"Map back from alias field names to internal field names.\"\"\"\n        return {v.alias or k: k for k, v in cls.model_fields.items()}\n\n    @classmethod\n    def make_partial(cls, dct):\n        \"\"\"Construct unvalidated partial model from dict.\n\n        Handles aliases correctly, unlike `construct`.\n        \"\"\"\n        un_alias = cls._aliases()\n        return cls.model_construct(**{un_alias.get(k) or k: v for k, v in dct.items()})\n\n    def set_key_order(self, keys: List[str]):\n        \"\"\"Setter for custom key order used in serialization.\"\"\"\n        un_alias = self._aliases()\n        # make sure we use the _actual_ field names\n        self._key_order = list(map(lambda k: un_alias.get(k) or k, keys))\n\n    def model_copy(self, *args, **kwargs):\n        \"\"\"Patched copy method (to preserve custom key order).\"\"\"\n        ret = super().model_copy(*args, **kwargs)\n        ret.set_key_order(list(self._key_order))\n        return ret\n\n    @staticmethod\n    def _patch_kwargs_defaults(kwargs):\n        \"\"\"Set some default arguments if they are not set by kwargs.\"\"\"\n        for key in [\"exclude_defaults\", \"exclude_none\"]:\n            if kwargs.get(key, None) is None:\n                kwargs[key] = True\n\n    def _reorder_dict(self, dct):\n        \"\"\"Return dict with patched key order (according to `self._key_order`).\n\n        Keys in `dct` not listed in `self._key_order` come after all others.\n\n        Used to patch up `model_dump()` and `model_dump_json()`.\n        \"\"\"\n        key_order = self._key_order or []\n        existing = set(key_order).intersection(set(dct.keys()))\n        key_order = [k for k in key_order if k in existing]\n        key_order += list(set(dct.keys()) - set(key_order))\n        return {k: dct[k] for k in key_order}\n\n    def model_dump(self, *args, **kwargs):\n        \"\"\"Patched dict method (to preserve custom key order).\"\"\"\n        self._patch_kwargs_defaults(kwargs)\n        by_alias = kwargs.pop(\"by_alias\", False)\n\n        dct = super().model_dump(*args, **kwargs, by_alias=False)\n        ret = self._reorder_dict(dct)\n\n        if by_alias:\n            ret = {self.model_fields[k].alias or k: v for k, v in ret.items()}\n        return ret\n\n    def model_dump_json(self, *args, **kwargs):\n        \"\"\"Patched json method (to preserve custom key order).\"\"\"\n        self._patch_kwargs_defaults(kwargs)\n        by_alias = kwargs.pop(\"by_alias\", False)\n\n        # loop back json through dict to apply custom key order\n        dct = json.loads(super().model_dump_json(*args, **kwargs, by_alias=False))\n        ret = self._reorder_dict(dct)\n\n        if by_alias:\n            ret = {self.model_fields[k].alias or k: v for k, v in ret.items()}\n        return json.dumps(ret, ensure_ascii=False)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.make_partial","title":"make_partial  <code>classmethod</code>","text":"<pre><code>make_partial(dct)\n</code></pre> <p>Construct unvalidated partial model from dict.</p> <p>Handles aliases correctly, unlike <code>construct</code>.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef make_partial(cls, dct):\n    \"\"\"Construct unvalidated partial model from dict.\n\n    Handles aliases correctly, unlike `construct`.\n    \"\"\"\n    un_alias = cls._aliases()\n    return cls.model_construct(**{un_alias.get(k) or k: v for k, v in dct.items()})\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.set_key_order","title":"set_key_order","text":"<pre><code>set_key_order(keys: List[str])\n</code></pre> <p>Setter for custom key order used in serialization.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def set_key_order(self, keys: List[str]):\n    \"\"\"Setter for custom key order used in serialization.\"\"\"\n    un_alias = self._aliases()\n    # make sure we use the _actual_ field names\n    self._key_order = list(map(lambda k: un_alias.get(k) or k, keys))\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.model_copy","title":"model_copy","text":"<pre><code>model_copy(*args, **kwargs)\n</code></pre> <p>Patched copy method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def model_copy(self, *args, **kwargs):\n    \"\"\"Patched copy method (to preserve custom key order).\"\"\"\n    ret = super().model_copy(*args, **kwargs)\n    ret.set_key_order(list(self._key_order))\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.model_dump","title":"model_dump","text":"<pre><code>model_dump(*args, **kwargs)\n</code></pre> <p>Patched dict method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def model_dump(self, *args, **kwargs):\n    \"\"\"Patched dict method (to preserve custom key order).\"\"\"\n    self._patch_kwargs_defaults(kwargs)\n    by_alias = kwargs.pop(\"by_alias\", False)\n\n    dct = super().model_dump(*args, **kwargs, by_alias=False)\n    ret = self._reorder_dict(dct)\n\n    if by_alias:\n        ret = {self.model_fields[k].alias or k: v for k, v in ret.items()}\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyBaseModel.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*args, **kwargs)\n</code></pre> <p>Patched json method (to preserve custom key order).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def model_dump_json(self, *args, **kwargs):\n    \"\"\"Patched json method (to preserve custom key order).\"\"\"\n    self._patch_kwargs_defaults(kwargs)\n    by_alias = kwargs.pop(\"by_alias\", False)\n\n    # loop back json through dict to apply custom key order\n    dct = json.loads(super().model_dump_json(*args, **kwargs, by_alias=False))\n    ret = self._reorder_dict(dct)\n\n    if by_alias:\n        ret = {self.model_fields[k].alias or k: v for k, v in ret.items()}\n    return json.dumps(ret, ensure_ascii=False)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig","title":"SomesyConfig","text":"<p>               Bases: <code>SomesyBaseModel</code></p> <p>Pydantic model for somesy tool configuration.</p> <p>Note that all fields match CLI options, and CLI options will override the values declared in a somesy input file (such as <code>somesy.toml</code>).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyConfig(SomesyBaseModel):\n    \"\"\"Pydantic model for somesy tool configuration.\n\n    Note that all fields match CLI options, and CLI options will override the\n    values declared in a somesy input file (such as `somesy.toml`).\n    \"\"\"\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def at_least_one_target(cls, values):\n        \"\"\"Check that at least one output file is enabled.\"\"\"\n        if all(map(lambda x: values.get(f\"no_sync_{x}\"), _SOMESY_TARGETS)):\n            msg = \"No sync target enabled, nothing to do. Probably this is a mistake?\"\n            raise ValueError(msg)\n\n        return values\n\n    # cli flags\n    show_info: Annotated[\n        bool,\n        Field(\n            description=\"Show basic information messages on run (-v flag).\",\n        ),\n    ] = False\n    verbose: Annotated[\n        bool, Field(description=\"Show verbose messages on run (-vv flag).\")\n    ] = False\n    debug: Annotated[\n        bool, Field(description=\"Show debug messages on run (-vvv flag).\")\n    ] = False\n\n    input_file: Annotated[\n        Optional[Path], Field(description=\"Project metadata input file path.\")\n    ] = Path(\"somesy.toml\")\n\n    no_sync_pyproject: Annotated[\n        bool, Field(description=\"Do not sync with pyproject.toml.\")\n    ] = False\n    pyproject_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"pyproject.toml file path.\")\n    ] = Path(\"pyproject.toml\")\n\n    no_sync_package_json: Annotated[\n        bool, Field(description=\"Do not sync with package.json.\")\n    ] = False\n    package_json_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"package.json file path.\")\n    ] = Path(\"package.json\")\n\n    no_sync_julia: Annotated[\n        bool, Field(description=\"Do not sync with Project.toml.\")\n    ] = False\n    julia_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"Project.toml file path.\")\n    ] = Path(\"Project.toml\")\n\n    no_sync_fortran: Annotated[\n        bool, Field(description=\"Do not sync with fpm.toml.\")\n    ] = False\n    fortran_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"fpm.toml file path.\")\n    ] = Path(\"fpm.toml\")\n\n    no_sync_pom_xml: Annotated[bool, Field(description=\"Do not sync with pom.xml.\")] = (\n        False\n    )\n    pom_xml_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"pom.xml file path.\")\n    ] = Path(\"pom.xml\")\n\n    no_sync_mkdocs: Annotated[\n        bool, Field(description=\"Do not sync with mkdocs.yml.\")\n    ] = False\n    mkdocs_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"mkdocs.yml file path.\")\n    ] = Path(\"mkdocs.yml\")\n\n    no_sync_rust: Annotated[bool, Field(description=\"Do not sync with Cargo.toml.\")] = (\n        False\n    )\n    rust_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"Cargo.toml file path.\")\n    ] = Path(\"Cargo.toml\")\n\n    no_sync_cff: Annotated[bool, Field(description=\"Do not sync with CFF.\")] = False\n    cff_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"CFF file path.\")\n    ] = Path(\"CITATION.cff\")\n\n    no_sync_codemeta: Annotated[\n        bool, Field(description=\"Do not sync with codemeta.json.\")\n    ] = False\n    codemeta_file: Annotated[\n        Union[Path, List[Path]], Field(description=\"codemeta.json file path.\")\n    ] = Path(\"codemeta.json\")\n    merge_codemeta: Annotated[\n        bool,\n        Field(\n            description=\"Merge codemeta.json with with an existing codemeta.json file.\"\n        ),\n    ] = False\n\n    # property to pass validation for all inputs/outputs\n    pass_validation: Annotated[\n        Optional[bool],\n        Field(description=\"Pass validation for all output files.\"),\n    ] = False\n\n    # packages (sub-folders) for monorepos with their own somesy config\n    packages: Annotated[\n        Optional[Union[Path, List[Path]]],\n        Field(\n            description=\"Packages (sub-folders) for monorepos with their own somesy config.\"\n        ),\n    ] = None\n\n    def log_level(self) -&gt; SomesyLogLevel:\n        \"\"\"Return log level derived from this configuration.\"\"\"\n        return SomesyLogLevel.from_flags(\n            info=self.show_info, verbose=self.verbose, debug=self.debug\n        )\n\n    def update_log_level(self, log_level: SomesyLogLevel):\n        \"\"\"Update config flags according to passed log level.\"\"\"\n        self.show_info = log_level == SomesyLogLevel.INFO\n        self.verbose = log_level == SomesyLogLevel.VERBOSE\n        self.debug = log_level == SomesyLogLevel.DEBUG\n\n    def get_input(self) -&gt; SomesyInput:\n        \"\"\"Based on the somesy config, load the complete somesy input.\"\"\"\n        # get metadata+config from specified input file\n        somesy_input = SomesyInput.from_input_file(self.input_file)\n        # update input with merged config settings (cli overrides config file)\n        dct: Dict[str, Any] = {}\n        dct.update(somesy_input.config or {})\n        dct.update(self.model_dump())\n        somesy_input.config = SomesyConfig(**dct)\n        return somesy_input\n\n    def resolve_paths(self, base_dir: Path) -&gt; None:\n        \"\"\"Resolve all paths in the config relative to the given base directory.\n\n        Args:\n            base_dir: The base directory to resolve paths against.\n\n        \"\"\"\n\n        def resolve_path(\n            paths: Optional[Union[Path, List[Path]]],\n        ) -&gt; Optional[Union[Path, List[Path]]]:\n            if paths is None:\n                return None\n            if isinstance(paths, list):\n                return [base_dir / p for p in paths]\n            return base_dir / paths\n\n        # Resolve all file paths\n        resolved_input = resolve_path(self.input_file)\n        self.input_file = resolved_input if isinstance(resolved_input, Path) else None\n        self.pyproject_file = resolve_path(self.pyproject_file)\n        self.package_json_file = resolve_path(self.package_json_file)\n        self.julia_file = resolve_path(self.julia_file)\n        self.fortran_file = resolve_path(self.fortran_file)\n        self.pom_xml_file = resolve_path(self.pom_xml_file)\n        self.mkdocs_file = resolve_path(self.mkdocs_file)\n        self.rust_file = resolve_path(self.rust_file)\n        self.cff_file = resolve_path(self.cff_file)\n        self.codemeta_file = resolve_path(self.codemeta_file)\n        self.packages = resolve_path(self.packages)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.at_least_one_target","title":"at_least_one_target  <code>classmethod</code>","text":"<pre><code>at_least_one_target(values)\n</code></pre> <p>Check that at least one output file is enabled.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef at_least_one_target(cls, values):\n    \"\"\"Check that at least one output file is enabled.\"\"\"\n    if all(map(lambda x: values.get(f\"no_sync_{x}\"), _SOMESY_TARGETS)):\n        msg = \"No sync target enabled, nothing to do. Probably this is a mistake?\"\n        raise ValueError(msg)\n\n    return values\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.log_level","title":"log_level","text":"<pre><code>log_level() -&gt; SomesyLogLevel\n</code></pre> <p>Return log level derived from this configuration.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def log_level(self) -&gt; SomesyLogLevel:\n    \"\"\"Return log level derived from this configuration.\"\"\"\n    return SomesyLogLevel.from_flags(\n        info=self.show_info, verbose=self.verbose, debug=self.debug\n    )\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.update_log_level","title":"update_log_level","text":"<pre><code>update_log_level(log_level: SomesyLogLevel)\n</code></pre> <p>Update config flags according to passed log level.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def update_log_level(self, log_level: SomesyLogLevel):\n    \"\"\"Update config flags according to passed log level.\"\"\"\n    self.show_info = log_level == SomesyLogLevel.INFO\n    self.verbose = log_level == SomesyLogLevel.VERBOSE\n    self.debug = log_level == SomesyLogLevel.DEBUG\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.get_input","title":"get_input","text":"<pre><code>get_input() -&gt; SomesyInput\n</code></pre> <p>Based on the somesy config, load the complete somesy input.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def get_input(self) -&gt; SomesyInput:\n    \"\"\"Based on the somesy config, load the complete somesy input.\"\"\"\n    # get metadata+config from specified input file\n    somesy_input = SomesyInput.from_input_file(self.input_file)\n    # update input with merged config settings (cli overrides config file)\n    dct: Dict[str, Any] = {}\n    dct.update(somesy_input.config or {})\n    dct.update(self.model_dump())\n    somesy_input.config = SomesyConfig(**dct)\n    return somesy_input\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyConfig.resolve_paths","title":"resolve_paths","text":"<pre><code>resolve_paths(base_dir: Path) -&gt; None\n</code></pre> <p>Resolve all paths in the config relative to the given base directory.</p> <p>Parameters:</p> Name Type Description Default <code>base_dir</code> <code>Path</code> <p>The base directory to resolve paths against.</p> required Source code in <code>src/somesy/core/models.py</code> <pre><code>def resolve_paths(self, base_dir: Path) -&gt; None:\n    \"\"\"Resolve all paths in the config relative to the given base directory.\n\n    Args:\n        base_dir: The base directory to resolve paths against.\n\n    \"\"\"\n\n    def resolve_path(\n        paths: Optional[Union[Path, List[Path]]],\n    ) -&gt; Optional[Union[Path, List[Path]]]:\n        if paths is None:\n            return None\n        if isinstance(paths, list):\n            return [base_dir / p for p in paths]\n        return base_dir / paths\n\n    # Resolve all file paths\n    resolved_input = resolve_path(self.input_file)\n    self.input_file = resolved_input if isinstance(resolved_input, Path) else None\n    self.pyproject_file = resolve_path(self.pyproject_file)\n    self.package_json_file = resolve_path(self.package_json_file)\n    self.julia_file = resolve_path(self.julia_file)\n    self.fortran_file = resolve_path(self.fortran_file)\n    self.pom_xml_file = resolve_path(self.pom_xml_file)\n    self.mkdocs_file = resolve_path(self.mkdocs_file)\n    self.rust_file = resolve_path(self.rust_file)\n    self.cff_file = resolve_path(self.cff_file)\n    self.codemeta_file = resolve_path(self.codemeta_file)\n    self.packages = resolve_path(self.packages)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ContributorBaseModel","title":"ContributorBaseModel","text":"<p>               Bases: <code>SomesyBaseModel</code></p> <p>Base model for Person and Entity models.</p> <p>This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class ContributorBaseModel(SomesyBaseModel):\n    \"\"\"Base model for Person and Entity models.\n\n    This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.\n    \"\"\"\n\n    email: Annotated[\n        Optional[str],\n        Field(\n            pattern=r\"^[\\S]+@[\\S]+\\.[\\S]{2,}$\",\n            description=\"The person's email address.\",\n        ),\n    ] = None\n\n    alias: Annotated[Optional[str], Field(description=\"The contributor's alias.\")] = (\n        None\n    )\n    address: Annotated[\n        Optional[str], Field(description=\"The contributor's address.\")\n    ] = None\n    city: Annotated[Optional[str], Field(description=\"The entity's city.\")] = None\n    country: Annotated[\n        Optional[Country], Field(description=\"The entity's country.\")\n    ] = None\n    fax: Annotated[Optional[str], Field(description=\"The person's fax number.\")] = None\n    post_code: Annotated[\n        Optional[str], Field(alias=\"post-code\", description=\"The entity's post-code.\")\n    ] = None\n    region: Annotated[Optional[str], Field(description=\"The entity's region.\")] = None\n    tel: Annotated[Optional[str], Field(description=\"The entity's phone number.\")] = (\n        None\n    )\n\n    # ----\n    # somesy-specific extensions\n    author: Annotated[\n        bool,\n        Field(\n            description=\"Indicates whether the entity is an author of the project (i.e. significant contributor).\"\n        ),\n    ] = False\n    publication_author: Annotated[\n        Optional[bool],\n        Field(\n            description=\"Indicates whether the entity is to be listed as an author in academic citations.\"\n        ),\n    ] = None\n    maintainer: Annotated[\n        bool,\n        Field(\n            description=\"Indicates whether the entity is a maintainer of the project (i.e. for contact).\"\n        ),\n    ] = False\n\n    # NOTE: CFF 1.3 (once done) might provide ways for refined contributor description. That should be implemented here.\n    contribution: Annotated[\n        Optional[str],\n        Field(description=\"Summary of how the entity contributed to the project.\"),\n    ] = None\n    contribution_types: Annotated[\n        Optional[List[ContributionTypeEnum]],\n        Field(\n            description=\"Relevant types of contributions (see https://allcontributors.org/docs/de/emoji-key).\",\n            min_length=1,\n        ),\n    ] = None\n    contribution_begin: Annotated[\n        Optional[date], Field(description=\"Beginning date of the contribution.\")\n    ] = None\n    contribution_end: Annotated[\n        Optional[date], Field(description=\"Ending date of the contribution.\")\n    ] = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def author_implies_publication(cls, values):\n        \"\"\"Ensure consistency of author and publication_author.\"\"\"\n        if values.get(\"author\"):\n            # NOTE: explicitly check for False (different case from None = missing!)\n            if values.get(\"publication_author\") is False:\n                msg = \"Combining author=true and publication_author=false is invalid!\"\n                raise ValueError(msg)\n            values[\"publication_author\"] = True\n        return values\n\n    # helper methods\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Return the name of the contributor.\"\"\"\n        pass\n\n    def to_name_email_string(self) -&gt; str:\n        \"\"\"Convert project metadata person object to poetry string for person format `full name &lt;x@y.z&gt;`.\"\"\"\n        if self.email:\n            return f\"{self.full_name} &lt;{self.email}&gt;\"\n        else:\n            return self.full_name\n\n    @classmethod\n    def from_name_email_string(cls, person: str):\n        \"\"\"Return the type of class based on an name/e-mail string like `full name &lt;x@y.z&gt;`.\n\n        If the name is `A B C`, then `A B` will be the given names and `C` will be the family name.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ContributorBaseModel.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Return the name of the contributor.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.ContributorBaseModel.author_implies_publication","title":"author_implies_publication  <code>classmethod</code>","text":"<pre><code>author_implies_publication(values)\n</code></pre> <p>Ensure consistency of author and publication_author.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef author_implies_publication(cls, values):\n    \"\"\"Ensure consistency of author and publication_author.\"\"\"\n    if values.get(\"author\"):\n        # NOTE: explicitly check for False (different case from None = missing!)\n        if values.get(\"publication_author\") is False:\n            msg = \"Combining author=true and publication_author=false is invalid!\"\n            raise ValueError(msg)\n        values[\"publication_author\"] = True\n    return values\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ContributorBaseModel.to_name_email_string","title":"to_name_email_string","text":"<pre><code>to_name_email_string() -&gt; str\n</code></pre> <p>Convert project metadata person object to poetry string for person format <code>full name &lt;x@y.z&gt;</code>.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def to_name_email_string(self) -&gt; str:\n    \"\"\"Convert project metadata person object to poetry string for person format `full name &lt;x@y.z&gt;`.\"\"\"\n    if self.email:\n        return f\"{self.full_name} &lt;{self.email}&gt;\"\n    else:\n        return self.full_name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ContributorBaseModel.from_name_email_string","title":"from_name_email_string  <code>classmethod</code>","text":"<pre><code>from_name_email_string(person: str)\n</code></pre> <p>Return the type of class based on an name/e-mail string like <code>full name &lt;x@y.z&gt;</code>.</p> <p>If the name is <code>A B C</code>, then <code>A B</code> will be the given names and <code>C</code> will be the family name.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef from_name_email_string(cls, person: str):\n    \"\"\"Return the type of class based on an name/e-mail string like `full name &lt;x@y.z&gt;`.\n\n    If the name is `A B C`, then `A B` will be the given names and `C` will be the family name.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Entity","title":"Entity","text":"<p>               Bases: <code>ContributorBaseModel</code></p> <p>Metadata about an entity in the context of a software project ownership.</p> <p>An entity, i.e., an institution, team, research group, company, conference, etc., as opposed to a single natural person. This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class Entity(ContributorBaseModel):\n    \"\"\"Metadata about an entity in the context of a software project ownership.\n\n    An entity, i.e., an institution, team, research group, company, conference, etc., as opposed to a single natural person.\n    This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.\n    \"\"\"\n\n    # NOTE: we rely on the defined aliases for direct CITATION.cff interoperability.\n\n    date_end: Annotated[\n        Optional[date],\n        Field(\n            alias=\"date-end\",\n            description=\"The entity's ending date, e.g., when the entity is a conference.\",\n        ),\n    ] = None\n    date_start: Annotated[\n        Optional[date],\n        Field(\n            alias=\"date-start\",\n            description=\"The entity's starting date, e.g., when the entity is a conference.\",\n        ),\n    ] = None\n    location: Annotated[\n        Optional[str],\n        Field(\n            description=\"The entity's location, e.g., when the entity is a conference.\"\n        ),\n    ] = None\n    name: Annotated[str, Field(description=\"The entity's name.\")]\n    website: Annotated[\n        Optional[HttpUrlStr], Field(description=\"The entity's website.\")\n    ] = None\n    rorid: Annotated[\n        Optional[HttpUrlStr],\n        Field(\n            description=\"The entity's ROR ID url **(not required, but highly suggested)**.\"\n        ),\n    ] = None\n\n    # helper methods\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Use same property as Person for code integration.\"\"\"\n        return self.name\n\n    @classmethod\n    def from_name_email_string(cls, entity: str) -&gt; Entity:\n        \"\"\"Return an `Entity` based on an name/e-mail string like `name &lt;x@y.z&gt;`.\"\"\"\n        m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", entity)\n        if m is None:\n            return Entity(**{\"name\": entity})\n\n        name, mail = (\n            m.group(1).strip(),\n            m.group(2).strip(),\n        )\n        return Entity(\n            **{\n                \"name\": name,\n                \"email\": mail,\n            }\n        )\n\n    def same_person(self, other: Entity) -&gt; bool:\n        \"\"\"Return whether two Entity metadata records are about the same real person.\n\n        Uses heuristic match based on email and name (whichever are provided).\n        \"\"\"\n        if not isinstance(other, Entity):\n            return False\n        if self.rorid is not None and other.rorid is not None:\n            if self.rorid == other.rorid:\n                return True\n        if self.website is not None and other.website is not None:\n            if self.website == other.website:\n                return True\n        if self.email is not None and other.email is not None:\n            if self.email == other.email:\n                return True\n        return self.name == other.name\n\n    def model_dump_json(self, *args, **kwargs):\n        \"\"\"Patched json method (to preserve custom key order), remove rorid and set it as website if it is not None.\"\"\"\n        ret = super().model_dump_json(*args, **kwargs)\n        # convert ret to dict\n        ret = json.loads(ret)\n        if self.rorid is not None and \"website\" not in ret:\n            ret[\"website\"] = str(self.rorid)\n            ret.pop(\"rorid\")\n        # convert ret back to json string\n        return json.dumps(ret)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Entity.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Use same property as Person for code integration.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.Entity.from_name_email_string","title":"from_name_email_string  <code>classmethod</code>","text":"<pre><code>from_name_email_string(entity: str) -&gt; Entity\n</code></pre> <p>Return an <code>Entity</code> based on an name/e-mail string like <code>name &lt;x@y.z&gt;</code>.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef from_name_email_string(cls, entity: str) -&gt; Entity:\n    \"\"\"Return an `Entity` based on an name/e-mail string like `name &lt;x@y.z&gt;`.\"\"\"\n    m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", entity)\n    if m is None:\n        return Entity(**{\"name\": entity})\n\n    name, mail = (\n        m.group(1).strip(),\n        m.group(2).strip(),\n    )\n    return Entity(\n        **{\n            \"name\": name,\n            \"email\": mail,\n        }\n    )\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Entity.same_person","title":"same_person","text":"<pre><code>same_person(other: Entity) -&gt; bool\n</code></pre> <p>Return whether two Entity metadata records are about the same real person.</p> <p>Uses heuristic match based on email and name (whichever are provided).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def same_person(self, other: Entity) -&gt; bool:\n    \"\"\"Return whether two Entity metadata records are about the same real person.\n\n    Uses heuristic match based on email and name (whichever are provided).\n    \"\"\"\n    if not isinstance(other, Entity):\n        return False\n    if self.rorid is not None and other.rorid is not None:\n        if self.rorid == other.rorid:\n            return True\n    if self.website is not None and other.website is not None:\n        if self.website == other.website:\n            return True\n    if self.email is not None and other.email is not None:\n        if self.email == other.email:\n            return True\n    return self.name == other.name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Entity.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*args, **kwargs)\n</code></pre> <p>Patched json method (to preserve custom key order), remove rorid and set it as website if it is not None.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def model_dump_json(self, *args, **kwargs):\n    \"\"\"Patched json method (to preserve custom key order), remove rorid and set it as website if it is not None.\"\"\"\n    ret = super().model_dump_json(*args, **kwargs)\n    # convert ret to dict\n    ret = json.loads(ret)\n    if self.rorid is not None and \"website\" not in ret:\n        ret[\"website\"] = str(self.rorid)\n        ret.pop(\"rorid\")\n    # convert ret back to json string\n    return json.dumps(ret)\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person","title":"Person","text":"<p>               Bases: <code>ContributorBaseModel</code></p> <p>Metadata about a person in the context of a software project.</p> <p>This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class Person(ContributorBaseModel):\n    \"\"\"Metadata about a person in the context of a software project.\n\n    This schema is based on CITATION.cff 1.2, modified and extended for the needs of somesy.\n    \"\"\"\n\n    # NOTE: we rely on the defined aliases for direct CITATION.cff interoperability.\n\n    orcid: Annotated[\n        Optional[HttpUrlStr],\n        Field(\n            description=\"The person's ORCID url **(not required, but highly suggested)**.\"\n        ),\n    ] = None\n    family_names: Annotated[\n        str, Field(alias=\"family-names\", description=\"The person's family names.\")\n    ]\n    given_names: Annotated[\n        str, Field(alias=\"given-names\", description=\"The person's given names.\")\n    ]\n    name_particle: Annotated[\n        Optional[str],\n        Field(\n            alias=\"name-particle\",\n            description=\"The person's name particle, e.g., a nobiliary particle or a preposition meaning 'of' or 'from'\"\n            \" (for example 'von' in 'Alexander von Humboldt').\",\n            examples=[\"von\"],\n        ),\n    ] = None\n    name_suffix: Annotated[\n        Optional[str],\n        Field(\n            alias=\"name-suffix\",\n            description=\"The person's name-suffix, e.g. 'Jr.' for Sammy Davis Jr. or 'III' for Frank Edwin Wright III.\",\n            examples=[\"Jr.\", \"III\"],\n        ),\n    ] = None\n    affiliation: Annotated[\n        Optional[str], Field(description=\"The person's affiliation.\")\n    ] = None\n\n    # helper methods\n\n    @property\n    def full_name(self) -&gt; str:\n        \"\"\"Return the full name of the person.\"\"\"\n        names = []\n\n        if self.given_names:\n            names.append(self.given_names)\n\n        if self.name_particle:\n            names.append(self.name_particle)\n\n        if self.family_names:\n            names.append(self.family_names)\n\n        if self.name_suffix:\n            names.append(self.name_suffix)\n\n        return \" \".join(names) if names else \"\"\n\n    @classmethod\n    def from_name_email_string(cls, person: str) -&gt; Person:\n        \"\"\"Return a `Person` based on an name/e-mail string like `full name &lt;x@y.z&gt;`.\n\n        If the name is `A B C`, then `A B` will be the given names and `C` will be the family name.\n        \"\"\"\n        m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", person)\n        if m is None:\n            names = list(map(lambda s: s.strip(), person.split()))\n            return Person(\n                **{\n                    \"given-names\": \" \".join(names[:-1]),\n                    \"family-names\": names[-1],\n                }\n            )\n        if m is None:\n            names = list(map(lambda s: s.strip(), person.split()))\n            return Person(\n                **{\n                    \"given-names\": \" \".join(names[:-1]),\n                    \"family-names\": names[-1],\n                }\n            )\n        names, mail = (\n            list(map(lambda s: s.strip(), m.group(1).split())),\n            m.group(2).strip(),\n        )\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n                \"email\": mail,\n            }\n        )\n\n    def same_person(self, other) -&gt; bool:\n        \"\"\"Return whether two Person metadata records are about the same real person.\n\n        Uses heuristic match based on orcid, email and name (whichever are provided).\n        \"\"\"\n        if not isinstance(other, Person):\n            return False\n        if self.orcid is not None and other.orcid is not None:\n            # having orcids is the best case, a real identifier\n            # NOTE: converting to str from pydantic-internal Url object for == !\n            return str(self.orcid) == str(other.orcid)\n\n        # otherwise, try to match according to mail/name\n        # sourcery skip: merge-nested-ifs\n        if self.email is not None and other.email is not None:\n            if self.email == other.email:\n                # an email address belongs to exactly one person\n                # =&gt; same email -&gt; same person\n                return True\n            # otherwise, need to check name\n            # (a person often has multiple email addresses)\n\n        # no orcids, no/distinct email address\n        # -&gt; decide based on full_name (which is always present)\n        return self.full_name == other.full_name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Return the full name of the person.</p>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person.from_name_email_string","title":"from_name_email_string  <code>classmethod</code>","text":"<pre><code>from_name_email_string(person: str) -&gt; Person\n</code></pre> <p>Return a <code>Person</code> based on an name/e-mail string like <code>full name &lt;x@y.z&gt;</code>.</p> <p>If the name is <code>A B C</code>, then <code>A B</code> will be the given names and <code>C</code> will be the family name.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef from_name_email_string(cls, person: str) -&gt; Person:\n    \"\"\"Return a `Person` based on an name/e-mail string like `full name &lt;x@y.z&gt;`.\n\n    If the name is `A B C`, then `A B` will be the given names and `C` will be the family name.\n    \"\"\"\n    m = re.match(r\"\\s*([^&lt;]+)&lt;([^&gt;]+)&gt;\", person)\n    if m is None:\n        names = list(map(lambda s: s.strip(), person.split()))\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n            }\n        )\n    if m is None:\n        names = list(map(lambda s: s.strip(), person.split()))\n        return Person(\n            **{\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n            }\n        )\n    names, mail = (\n        list(map(lambda s: s.strip(), m.group(1).split())),\n        m.group(2).strip(),\n    )\n    # NOTE: for our purposes, does not matter what are given or family names,\n    # we only compare on full_name anyway.\n    return Person(\n        **{\n            \"given-names\": \" \".join(names[:-1]),\n            \"family-names\": names[-1],\n            \"email\": mail,\n        }\n    )\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.Person.same_person","title":"same_person","text":"<pre><code>same_person(other) -&gt; bool\n</code></pre> <p>Return whether two Person metadata records are about the same real person.</p> <p>Uses heuristic match based on orcid, email and name (whichever are provided).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def same_person(self, other) -&gt; bool:\n    \"\"\"Return whether two Person metadata records are about the same real person.\n\n    Uses heuristic match based on orcid, email and name (whichever are provided).\n    \"\"\"\n    if not isinstance(other, Person):\n        return False\n    if self.orcid is not None and other.orcid is not None:\n        # having orcids is the best case, a real identifier\n        # NOTE: converting to str from pydantic-internal Url object for == !\n        return str(self.orcid) == str(other.orcid)\n\n    # otherwise, try to match according to mail/name\n    # sourcery skip: merge-nested-ifs\n    if self.email is not None and other.email is not None:\n        if self.email == other.email:\n            # an email address belongs to exactly one person\n            # =&gt; same email -&gt; same person\n            return True\n        # otherwise, need to check name\n        # (a person often has multiple email addresses)\n\n    # no orcids, no/distinct email address\n    # -&gt; decide based on full_name (which is always present)\n    return self.full_name == other.full_name\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata","title":"ProjectMetadata","text":"<p>               Bases: <code>SomesyBaseModel</code></p> <p>Pydantic model for Project Metadata Input.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class ProjectMetadata(SomesyBaseModel):\n    \"\"\"Pydantic model for Project Metadata Input.\"\"\"\n\n    model_config = dict(extra=\"ignore\")\n\n    @field_validator(\"people\")\n    @classmethod\n    def ensure_distinct_people(cls, people):\n        \"\"\"Make sure that no person is listed twice in the same list.\"\"\"\n        for i in range(len(people)):\n            for j in range(i + 1, len(people)):\n                if people[i].same_person(people[j]):\n                    p1 = pretty_repr(json.loads(people[i].model_dump_json()))\n                    p2 = pretty_repr(json.loads(people[j].model_dump_json()))\n                    msg = f\"Same person is listed twice:\\n{p1}\\n{p2}\"\n                    raise ValueError(msg)\n        return people\n\n    @field_validator(\"entities\")\n    @classmethod\n    def ensure_distinct_entities(cls, entities):\n        \"\"\"Make sure that no entity is listed twice in the same list.\"\"\"\n        for i in range(len(entities)):\n            for j in range(i + 1, len(entities)):\n                if entities[i].same_person(entities[j]):\n                    e1 = pretty_repr(json.loads(entities[i].model_dump_json()))\n                    e2 = pretty_repr(json.loads(entities[j].model_dump_json()))\n                    msg = f\"Same entity is listed twice:\\n{e1}\\n{e2}\"\n                    raise ValueError(msg)\n        return entities\n\n    @model_validator(mode=\"after\")\n    def at_least_one_author(self) -&gt; ProjectMetadata:\n        \"\"\"Make sure there is at least one author.\"\"\"\n        if not self.people and not self.entities:\n            raise ValueError(\n                \"There have to be at least a person or an organization in the input\"\n            )\n        if not any(map(lambda p: p.author, self.people)) and not any(\n            map(lambda e: e.author, self.entities)\n        ):\n            raise ValueError(\"At least one person must be an author of this project.\")\n        return self\n\n    name: Annotated[str, Field(description=\"Project name.\")]\n    description: Annotated[str, Field(description=\"Project description.\")]\n    version: Annotated[Optional[str], Field(description=\"Project version.\")] = None\n    license: Annotated[LicenseEnum, Field(description=\"SPDX License string.\")]\n\n    homepage: Annotated[\n        Optional[HttpUrlStr], Field(description=\"URL of the project homepage.\")\n    ] = None\n    repository: Annotated[\n        Optional[HttpUrlStr],\n        Field(description=\"URL of the project source code repository.\"),\n    ] = None\n    documentation: Annotated[\n        Optional[HttpUrlStr], Field(description=\"URL of the project documentation.\")\n    ] = None\n\n    keywords: Annotated[\n        Optional[List[str]],\n        Field(min_length=1, description=\"Keywords that describe the project.\"),\n    ] = None\n\n    people: Annotated[\n        Optional[List[Person]],\n        Field(\n            description=\"Project authors, maintainers and contributors.\",\n            default_factory=list,\n        ),\n    ]\n\n    entities: Annotated[\n        Optional[List[Entity]],\n        Field(\n            description=\"Project authors, maintainers and contributors as entities (organizations).\",\n            default_factory=list,\n        ),\n    ]\n\n    def authors(self):\n        \"\"\"Return people and entities explicitly marked as authors.\"\"\"\n        authors = [p for p in self.people if p.author]\n        authors.extend([e for e in self.entities if e.author])\n        return authors\n\n    def publication_authors(self):\n        \"\"\"Return people marked as publication authors.\n\n        This always includes people marked as authors.\n        \"\"\"\n        # return an empty list if no publication authors are specified\n        if not any(map(lambda p: p.publication_author, self.people)) and not any(\n            map(lambda p: p.publication_author, self.entities)\n        ):\n            return []\n        publication_authors = [p for p in self.people if p.publication_author]\n        publication_authors.extend([e for e in self.entities if e.publication_author])\n        return publication_authors\n\n    def maintainers(self):\n        \"\"\"Return people and entities marked as maintainers.\"\"\"\n        maintainers = [p for p in self.people if p.maintainer]\n        maintainers.extend([e for e in self.entities if e.maintainer])\n        return maintainers\n\n    def contributors(self):\n        \"\"\"Return only people and entities not marked as authors.\"\"\"\n        contributors = [p for p in self.people if not p.author]\n        contributors.extend([e for e in self.entities if not e.author])\n        return contributors\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.ensure_distinct_people","title":"ensure_distinct_people  <code>classmethod</code>","text":"<pre><code>ensure_distinct_people(people)\n</code></pre> <p>Make sure that no person is listed twice in the same list.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@field_validator(\"people\")\n@classmethod\ndef ensure_distinct_people(cls, people):\n    \"\"\"Make sure that no person is listed twice in the same list.\"\"\"\n    for i in range(len(people)):\n        for j in range(i + 1, len(people)):\n            if people[i].same_person(people[j]):\n                p1 = pretty_repr(json.loads(people[i].model_dump_json()))\n                p2 = pretty_repr(json.loads(people[j].model_dump_json()))\n                msg = f\"Same person is listed twice:\\n{p1}\\n{p2}\"\n                raise ValueError(msg)\n    return people\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.ensure_distinct_entities","title":"ensure_distinct_entities  <code>classmethod</code>","text":"<pre><code>ensure_distinct_entities(entities)\n</code></pre> <p>Make sure that no entity is listed twice in the same list.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@field_validator(\"entities\")\n@classmethod\ndef ensure_distinct_entities(cls, entities):\n    \"\"\"Make sure that no entity is listed twice in the same list.\"\"\"\n    for i in range(len(entities)):\n        for j in range(i + 1, len(entities)):\n            if entities[i].same_person(entities[j]):\n                e1 = pretty_repr(json.loads(entities[i].model_dump_json()))\n                e2 = pretty_repr(json.loads(entities[j].model_dump_json()))\n                msg = f\"Same entity is listed twice:\\n{e1}\\n{e2}\"\n                raise ValueError(msg)\n    return entities\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.at_least_one_author","title":"at_least_one_author","text":"<pre><code>at_least_one_author() -&gt; ProjectMetadata\n</code></pre> <p>Make sure there is at least one author.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef at_least_one_author(self) -&gt; ProjectMetadata:\n    \"\"\"Make sure there is at least one author.\"\"\"\n    if not self.people and not self.entities:\n        raise ValueError(\n            \"There have to be at least a person or an organization in the input\"\n        )\n    if not any(map(lambda p: p.author, self.people)) and not any(\n        map(lambda e: e.author, self.entities)\n    ):\n        raise ValueError(\"At least one person must be an author of this project.\")\n    return self\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.authors","title":"authors","text":"<pre><code>authors()\n</code></pre> <p>Return people and entities explicitly marked as authors.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def authors(self):\n    \"\"\"Return people and entities explicitly marked as authors.\"\"\"\n    authors = [p for p in self.people if p.author]\n    authors.extend([e for e in self.entities if e.author])\n    return authors\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.publication_authors","title":"publication_authors","text":"<pre><code>publication_authors()\n</code></pre> <p>Return people marked as publication authors.</p> <p>This always includes people marked as authors.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def publication_authors(self):\n    \"\"\"Return people marked as publication authors.\n\n    This always includes people marked as authors.\n    \"\"\"\n    # return an empty list if no publication authors are specified\n    if not any(map(lambda p: p.publication_author, self.people)) and not any(\n        map(lambda p: p.publication_author, self.entities)\n    ):\n        return []\n    publication_authors = [p for p in self.people if p.publication_author]\n    publication_authors.extend([e for e in self.entities if e.publication_author])\n    return publication_authors\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.maintainers","title":"maintainers","text":"<pre><code>maintainers()\n</code></pre> <p>Return people and entities marked as maintainers.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def maintainers(self):\n    \"\"\"Return people and entities marked as maintainers.\"\"\"\n    maintainers = [p for p in self.people if p.maintainer]\n    maintainers.extend([e for e in self.entities if e.maintainer])\n    return maintainers\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.ProjectMetadata.contributors","title":"contributors","text":"<pre><code>contributors()\n</code></pre> <p>Return only people and entities not marked as authors.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def contributors(self):\n    \"\"\"Return only people and entities not marked as authors.\"\"\"\n    contributors = [p for p in self.people if not p.author]\n    contributors.extend([e for e in self.entities if not e.author])\n    return contributors\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput","title":"SomesyInput","text":"<p>               Bases: <code>SomesyBaseModel</code></p> <p>The complete somesy input file (<code>somesy.toml</code>) or section (<code>pyproject.toml</code>).</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>class SomesyInput(SomesyBaseModel):\n    \"\"\"The complete somesy input file (`somesy.toml`) or section (`pyproject.toml`).\"\"\"\n\n    _origin: Optional[Path]\n\n    project: Annotated[\n        ProjectMetadata,\n        Field(description=\"Project metadata to be used and synchronized.\"),\n    ]\n    config: Annotated[\n        Optional[SomesyConfig],\n        Field(\n            description=\"somesy tool configuration (matches CLI flags).\",\n            default_factory=lambda: SomesyConfig(),\n        ),\n    ]\n\n    # if config.input_file is set, use it as origin\n    @model_validator(mode=\"after\")\n    def set_origin(self):\n        \"\"\"Set the origin of the input file.\"\"\"\n        if self.config and self.config.input_file:\n            self._origin = self.config.input_file\n\n    def is_somesy_file(self) -&gt; bool:\n        \"\"\"Return whether this somesy input is from a somesy config file.\n\n        That means, returns False if it is from pyproject.toml or package.json.\n        \"\"\"\n        return self.is_somesy_file_path(self._origin or Path(\".\"))\n\n    @classmethod\n    def is_somesy_file_path(cls, path: Path) -&gt; bool:\n        \"\"\"Return whether the path looks like a somesy config file.\n\n        That means, returns False if it is e.g. pyproject.toml or package.json.\n        \"\"\"\n        return str(path).endswith(\"somesy.toml\")\n\n    @classmethod\n    def from_input_file(cls, path: Path) -&gt; SomesyInput:\n        \"\"\"Load somesy input from given file.\"\"\"\n        content = get_input_content(path)\n        ret = SomesyInput(**content)\n        ret._origin = path\n        return ret\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.set_origin","title":"set_origin","text":"<pre><code>set_origin()\n</code></pre> <p>Set the origin of the input file.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef set_origin(self):\n    \"\"\"Set the origin of the input file.\"\"\"\n    if self.config and self.config.input_file:\n        self._origin = self.config.input_file\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.is_somesy_file","title":"is_somesy_file","text":"<pre><code>is_somesy_file() -&gt; bool\n</code></pre> <p>Return whether this somesy input is from a somesy config file.</p> <p>That means, returns False if it is from pyproject.toml or package.json.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>def is_somesy_file(self) -&gt; bool:\n    \"\"\"Return whether this somesy input is from a somesy config file.\n\n    That means, returns False if it is from pyproject.toml or package.json.\n    \"\"\"\n    return self.is_somesy_file_path(self._origin or Path(\".\"))\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.is_somesy_file_path","title":"is_somesy_file_path  <code>classmethod</code>","text":"<pre><code>is_somesy_file_path(path: Path) -&gt; bool\n</code></pre> <p>Return whether the path looks like a somesy config file.</p> <p>That means, returns False if it is e.g. pyproject.toml or package.json.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef is_somesy_file_path(cls, path: Path) -&gt; bool:\n    \"\"\"Return whether the path looks like a somesy config file.\n\n    That means, returns False if it is e.g. pyproject.toml or package.json.\n    \"\"\"\n    return str(path).endswith(\"somesy.toml\")\n</code></pre>"},{"location":"reference/somesy/core/models/#somesy.core.models.SomesyInput.from_input_file","title":"from_input_file  <code>classmethod</code>","text":"<pre><code>from_input_file(path: Path) -&gt; SomesyInput\n</code></pre> <p>Load somesy input from given file.</p> Source code in <code>src/somesy/core/models.py</code> <pre><code>@classmethod\ndef from_input_file(cls, path: Path) -&gt; SomesyInput:\n    \"\"\"Load somesy input from given file.\"\"\"\n    content = get_input_content(path)\n    ret = SomesyInput(**content)\n    ret._origin = path\n    return ret\n</code></pre>"},{"location":"reference/somesy/core/types/","title":"types","text":"<p>Types and enums used in the somesy models.</p>"},{"location":"reference/somesy/core/types/#somesy.core.types.MyEnum","title":"MyEnum","text":"<p>               Bases: <code>Enum</code></p> <p>Override string serialization of enum to work better with Jinja templates.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class MyEnum(Enum):\n    \"\"\"Override string serialization of enum to work better with Jinja templates.\"\"\"\n\n    def __str__(self):\n        \"\"\"Return string value of the enum object.\"\"\"\n        return self.value\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.MyEnum.__str__","title":"__str__","text":"<pre><code>__str__()\n</code></pre> <p>Return string value of the enum object.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>def __str__(self):\n    \"\"\"Return string value of the enum object.\"\"\"\n    return self.value\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.LicenseEnum","title":"LicenseEnum","text":"<p>               Bases: <code>MyEnum</code></p> <p>SPDX license identifiers.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class LicenseEnum(MyEnum):\n    \"\"\"SPDX license identifiers.\"\"\"\n\n    field_0BSD = \"0BSD\"\n    AAL = \"AAL\"\n    Abstyles = \"Abstyles\"\n    Adobe_2006 = \"Adobe-2006\"\n    Adobe_Glyph = \"Adobe-Glyph\"\n    ADSL = \"ADSL\"\n    AFL_1_1 = \"AFL-1.1\"\n    AFL_1_2 = \"AFL-1.2\"\n    AFL_2_0 = \"AFL-2.0\"\n    AFL_2_1 = \"AFL-2.1\"\n    AFL_3_0 = \"AFL-3.0\"\n    Afmparse = \"Afmparse\"\n    AGPL_1_0 = \"AGPL-1.0\"\n    AGPL_1_0_only = \"AGPL-1.0-only\"\n    AGPL_1_0_or_later = \"AGPL-1.0-or-later\"\n    AGPL_3_0 = \"AGPL-3.0\"\n    AGPL_3_0_only = \"AGPL-3.0-only\"\n    AGPL_3_0_or_later = \"AGPL-3.0-or-later\"\n    Aladdin = \"Aladdin\"\n    AMDPLPA = \"AMDPLPA\"\n    AML = \"AML\"\n    AMPAS = \"AMPAS\"\n    ANTLR_PD = \"ANTLR-PD\"\n    ANTLR_PD_fallback = \"ANTLR-PD-fallback\"\n    Apache_1_0 = \"Apache-1.0\"\n    Apache_1_1 = \"Apache-1.1\"\n    Apache_2_0 = \"Apache-2.0\"\n    APAFML = \"APAFML\"\n    APL_1_0 = \"APL-1.0\"\n    APSL_1_0 = \"APSL-1.0\"\n    APSL_1_1 = \"APSL-1.1\"\n    APSL_1_2 = \"APSL-1.2\"\n    APSL_2_0 = \"APSL-2.0\"\n    Artistic_1_0 = \"Artistic-1.0\"\n    Artistic_1_0_cl8 = \"Artistic-1.0-cl8\"\n    Artistic_1_0_Perl = \"Artistic-1.0-Perl\"\n    Artistic_2_0 = \"Artistic-2.0\"\n    Bahyph = \"Bahyph\"\n    Barr = \"Barr\"\n    Beerware = \"Beerware\"\n    BitTorrent_1_0 = \"BitTorrent-1.0\"\n    BitTorrent_1_1 = \"BitTorrent-1.1\"\n    blessing = \"blessing\"\n    BlueOak_1_0_0 = \"BlueOak-1.0.0\"\n    Borceux = \"Borceux\"\n    BSD_1_Clause = \"BSD-1-Clause\"\n    BSD_2_Clause = \"BSD-2-Clause\"\n    BSD_2_Clause_FreeBSD = \"BSD-2-Clause-FreeBSD\"\n    BSD_2_Clause_NetBSD = \"BSD-2-Clause-NetBSD\"\n    BSD_2_Clause_Patent = \"BSD-2-Clause-Patent\"\n    BSD_2_Clause_Views = \"BSD-2-Clause-Views\"\n    BSD_3_Clause = \"BSD-3-Clause\"\n    BSD_3_Clause_Attribution = \"BSD-3-Clause-Attribution\"\n    BSD_3_Clause_Clear = \"BSD-3-Clause-Clear\"\n    BSD_3_Clause_LBNL = \"BSD-3-Clause-LBNL\"\n    BSD_3_Clause_Modification = \"BSD-3-Clause-Modification\"\n    BSD_3_Clause_No_Nuclear_License = \"BSD-3-Clause-No-Nuclear-License\"\n    BSD_3_Clause_No_Nuclear_License_2014 = \"BSD-3-Clause-No-Nuclear-License-2014\"\n    BSD_3_Clause_No_Nuclear_Warranty = \"BSD-3-Clause-No-Nuclear-Warranty\"\n    BSD_3_Clause_Open_MPI = \"BSD-3-Clause-Open-MPI\"\n    BSD_4_Clause = \"BSD-4-Clause\"\n    BSD_4_Clause_Shortened = \"BSD-4-Clause-Shortened\"\n    BSD_4_Clause_UC = \"BSD-4-Clause-UC\"\n    BSD_Protection = \"BSD-Protection\"\n    BSD_Source_Code = \"BSD-Source-Code\"\n    BSL_1_0 = \"BSL-1.0\"\n    BUSL_1_1 = \"BUSL-1.1\"\n    bzip2_1_0_5 = \"bzip2-1.0.5\"\n    bzip2_1_0_6 = \"bzip2-1.0.6\"\n    C_UDA_1_0 = \"C-UDA-1.0\"\n    CAL_1_0 = \"CAL-1.0\"\n    CAL_1_0_Combined_Work_Exception = \"CAL-1.0-Combined-Work-Exception\"\n    Caldera = \"Caldera\"\n    CATOSL_1_1 = \"CATOSL-1.1\"\n    CC_BY_1_0 = \"CC-BY-1.0\"\n    CC_BY_2_0 = \"CC-BY-2.0\"\n    CC_BY_2_5 = \"CC-BY-2.5\"\n    CC_BY_3_0 = \"CC-BY-3.0\"\n    CC_BY_3_0_AT = \"CC-BY-3.0-AT\"\n    CC_BY_3_0_US = \"CC-BY-3.0-US\"\n    CC_BY_4_0 = \"CC-BY-4.0\"\n    CC_BY_NC_1_0 = \"CC-BY-NC-1.0\"\n    CC_BY_NC_2_0 = \"CC-BY-NC-2.0\"\n    CC_BY_NC_2_5 = \"CC-BY-NC-2.5\"\n    CC_BY_NC_3_0 = \"CC-BY-NC-3.0\"\n    CC_BY_NC_4_0 = \"CC-BY-NC-4.0\"\n    CC_BY_NC_ND_1_0 = \"CC-BY-NC-ND-1.0\"\n    CC_BY_NC_ND_2_0 = \"CC-BY-NC-ND-2.0\"\n    CC_BY_NC_ND_2_5 = \"CC-BY-NC-ND-2.5\"\n    CC_BY_NC_ND_3_0 = \"CC-BY-NC-ND-3.0\"\n    CC_BY_NC_ND_3_0_IGO = \"CC-BY-NC-ND-3.0-IGO\"\n    CC_BY_NC_ND_4_0 = \"CC-BY-NC-ND-4.0\"\n    CC_BY_NC_SA_1_0 = \"CC-BY-NC-SA-1.0\"\n    CC_BY_NC_SA_2_0 = \"CC-BY-NC-SA-2.0\"\n    CC_BY_NC_SA_2_5 = \"CC-BY-NC-SA-2.5\"\n    CC_BY_NC_SA_3_0 = \"CC-BY-NC-SA-3.0\"\n    CC_BY_NC_SA_4_0 = \"CC-BY-NC-SA-4.0\"\n    CC_BY_ND_1_0 = \"CC-BY-ND-1.0\"\n    CC_BY_ND_2_0 = \"CC-BY-ND-2.0\"\n    CC_BY_ND_2_5 = \"CC-BY-ND-2.5\"\n    CC_BY_ND_3_0 = \"CC-BY-ND-3.0\"\n    CC_BY_ND_4_0 = \"CC-BY-ND-4.0\"\n    CC_BY_SA_1_0 = \"CC-BY-SA-1.0\"\n    CC_BY_SA_2_0 = \"CC-BY-SA-2.0\"\n    CC_BY_SA_2_0_UK = \"CC-BY-SA-2.0-UK\"\n    CC_BY_SA_2_1_JP = \"CC-BY-SA-2.1-JP\"\n    CC_BY_SA_2_5 = \"CC-BY-SA-2.5\"\n    CC_BY_SA_3_0 = \"CC-BY-SA-3.0\"\n    CC_BY_SA_3_0_AT = \"CC-BY-SA-3.0-AT\"\n    CC_BY_SA_4_0 = \"CC-BY-SA-4.0\"\n    CC_PDDC = \"CC-PDDC\"\n    CC0_1_0 = \"CC0-1.0\"\n    CDDL_1_0 = \"CDDL-1.0\"\n    CDDL_1_1 = \"CDDL-1.1\"\n    CDL_1_0 = \"CDL-1.0\"\n    CDLA_Permissive_1_0 = \"CDLA-Permissive-1.0\"\n    CDLA_Sharing_1_0 = \"CDLA-Sharing-1.0\"\n    CECILL_1_0 = \"CECILL-1.0\"\n    CECILL_1_1 = \"CECILL-1.1\"\n    CECILL_2_0 = \"CECILL-2.0\"\n    CECILL_2_1 = \"CECILL-2.1\"\n    CECILL_B = \"CECILL-B\"\n    CECILL_C = \"CECILL-C\"\n    CERN_OHL_1_1 = \"CERN-OHL-1.1\"\n    CERN_OHL_1_2 = \"CERN-OHL-1.2\"\n    CERN_OHL_P_2_0 = \"CERN-OHL-P-2.0\"\n    CERN_OHL_S_2_0 = \"CERN-OHL-S-2.0\"\n    CERN_OHL_W_2_0 = \"CERN-OHL-W-2.0\"\n    ClArtistic = \"ClArtistic\"\n    CNRI_Jython = \"CNRI-Jython\"\n    CNRI_Python = \"CNRI-Python\"\n    CNRI_Python_GPL_Compatible = \"CNRI-Python-GPL-Compatible\"\n    Condor_1_1 = \"Condor-1.1\"\n    copyleft_next_0_3_0 = \"copyleft-next-0.3.0\"\n    copyleft_next_0_3_1 = \"copyleft-next-0.3.1\"\n    CPAL_1_0 = \"CPAL-1.0\"\n    CPL_1_0 = \"CPL-1.0\"\n    CPOL_1_02 = \"CPOL-1.02\"\n    Crossword = \"Crossword\"\n    CrystalStacker = \"CrystalStacker\"\n    CUA_OPL_1_0 = \"CUA-OPL-1.0\"\n    Cube = \"Cube\"\n    curl = \"curl\"\n    D_FSL_1_0 = \"D-FSL-1.0\"\n    diffmark = \"diffmark\"\n    DOC = \"DOC\"\n    Dotseqn = \"Dotseqn\"\n    DRL_1_0 = \"DRL-1.0\"\n    DSDP = \"DSDP\"\n    dvipdfm = \"dvipdfm\"\n    ECL_1_0 = \"ECL-1.0\"\n    ECL_2_0 = \"ECL-2.0\"\n    eCos_2_0 = \"eCos-2.0\"\n    EFL_1_0 = \"EFL-1.0\"\n    EFL_2_0 = \"EFL-2.0\"\n    eGenix = \"eGenix\"\n    Entessa = \"Entessa\"\n    EPICS = \"EPICS\"\n    EPL_1_0 = \"EPL-1.0\"\n    EPL_2_0 = \"EPL-2.0\"\n    ErlPL_1_1 = \"ErlPL-1.1\"\n    etalab_2_0 = \"etalab-2.0\"\n    EUDatagrid = \"EUDatagrid\"\n    EUPL_1_0 = \"EUPL-1.0\"\n    EUPL_1_1 = \"EUPL-1.1\"\n    EUPL_1_2 = \"EUPL-1.2\"\n    Eurosym = \"Eurosym\"\n    Fair = \"Fair\"\n    Frameworx_1_0 = \"Frameworx-1.0\"\n    FreeBSD_DOC = \"FreeBSD-DOC\"\n    FreeImage = \"FreeImage\"\n    FSFAP = \"FSFAP\"\n    FSFUL = \"FSFUL\"\n    FSFULLR = \"FSFULLR\"\n    FTL = \"FTL\"\n    GD = \"GD\"\n    GFDL_1_1 = \"GFDL-1.1\"\n    GFDL_1_1_invariants_only = \"GFDL-1.1-invariants-only\"\n    GFDL_1_1_invariants_or_later = \"GFDL-1.1-invariants-or-later\"\n    GFDL_1_1_no_invariants_only = \"GFDL-1.1-no-invariants-only\"\n    GFDL_1_1_no_invariants_or_later = \"GFDL-1.1-no-invariants-or-later\"\n    GFDL_1_1_only = \"GFDL-1.1-only\"\n    GFDL_1_1_or_later = \"GFDL-1.1-or-later\"\n    GFDL_1_2 = \"GFDL-1.2\"\n    GFDL_1_2_invariants_only = \"GFDL-1.2-invariants-only\"\n    GFDL_1_2_invariants_or_later = \"GFDL-1.2-invariants-or-later\"\n    GFDL_1_2_no_invariants_only = \"GFDL-1.2-no-invariants-only\"\n    GFDL_1_2_no_invariants_or_later = \"GFDL-1.2-no-invariants-or-later\"\n    GFDL_1_2_only = \"GFDL-1.2-only\"\n    GFDL_1_2_or_later = \"GFDL-1.2-or-later\"\n    GFDL_1_3 = \"GFDL-1.3\"\n    GFDL_1_3_invariants_only = \"GFDL-1.3-invariants-only\"\n    GFDL_1_3_invariants_or_later = \"GFDL-1.3-invariants-or-later\"\n    GFDL_1_3_no_invariants_only = \"GFDL-1.3-no-invariants-only\"\n    GFDL_1_3_no_invariants_or_later = \"GFDL-1.3-no-invariants-or-later\"\n    GFDL_1_3_only = \"GFDL-1.3-only\"\n    GFDL_1_3_or_later = \"GFDL-1.3-or-later\"\n    Giftware = \"Giftware\"\n    GL2PS = \"GL2PS\"\n    Glide = \"Glide\"\n    Glulxe = \"Glulxe\"\n    GLWTPL = \"GLWTPL\"\n    gnuplot = \"gnuplot\"\n    GPL_1_0 = \"GPL-1.0\"\n    GPL_1_0_only = \"GPL-1.0-only\"\n    GPL_1_0_or_later = \"GPL-1.0-or-later\"\n    GPL_1_0_ = \"GPL-1.0+\"\n    GPL_2_0 = \"GPL-2.0\"\n    GPL_2_0_only = \"GPL-2.0-only\"\n    GPL_2_0_or_later = \"GPL-2.0-or-later\"\n    GPL_2_0_with_autoconf_exception = \"GPL-2.0-with-autoconf-exception\"\n    GPL_2_0_with_bison_exception = \"GPL-2.0-with-bison-exception\"\n    GPL_2_0_with_classpath_exception = \"GPL-2.0-with-classpath-exception\"\n    GPL_2_0_with_font_exception = \"GPL-2.0-with-font-exception\"\n    GPL_2_0_with_GCC_exception = \"GPL-2.0-with-GCC-exception\"\n    GPL_2_0_ = \"GPL-2.0+\"\n    GPL_3_0 = \"GPL-3.0\"\n    GPL_3_0_only = \"GPL-3.0-only\"\n    GPL_3_0_or_later = \"GPL-3.0-or-later\"\n    GPL_3_0_with_autoconf_exception = \"GPL-3.0-with-autoconf-exception\"\n    GPL_3_0_with_GCC_exception = \"GPL-3.0-with-GCC-exception\"\n    GPL_3_0_ = \"GPL-3.0+\"\n    gSOAP_1_3b = \"gSOAP-1.3b\"\n    HaskellReport = \"HaskellReport\"\n    Hippocratic_2_1 = \"Hippocratic-2.1\"\n    HPND = \"HPND\"\n    HPND_sell_variant = \"HPND-sell-variant\"\n    HTMLTIDY = \"HTMLTIDY\"\n    IBM_pibs = \"IBM-pibs\"\n    ICU = \"ICU\"\n    IJG = \"IJG\"\n    ImageMagick = \"ImageMagick\"\n    iMatix = \"iMatix\"\n    Imlib2 = \"Imlib2\"\n    Info_ZIP = \"Info-ZIP\"\n    Intel = \"Intel\"\n    Intel_ACPI = \"Intel-ACPI\"\n    Interbase_1_0 = \"Interbase-1.0\"\n    IPA = \"IPA\"\n    IPL_1_0 = \"IPL-1.0\"\n    ISC = \"ISC\"\n    JasPer_2_0 = \"JasPer-2.0\"\n    JPNIC = \"JPNIC\"\n    JSON = \"JSON\"\n    LAL_1_2 = \"LAL-1.2\"\n    LAL_1_3 = \"LAL-1.3\"\n    Latex2e = \"Latex2e\"\n    Leptonica = \"Leptonica\"\n    LGPL_2_0 = \"LGPL-2.0\"\n    LGPL_2_0_only = \"LGPL-2.0-only\"\n    LGPL_2_0_or_later = \"LGPL-2.0-or-later\"\n    LGPL_2_0_ = \"LGPL-2.0+\"\n    LGPL_2_1 = \"LGPL-2.1\"\n    LGPL_2_1_only = \"LGPL-2.1-only\"\n    LGPL_2_1_or_later = \"LGPL-2.1-or-later\"\n    LGPL_2_1_ = \"LGPL-2.1+\"\n    LGPL_3_0 = \"LGPL-3.0\"\n    LGPL_3_0_only = \"LGPL-3.0-only\"\n    LGPL_3_0_or_later = \"LGPL-3.0-or-later\"\n    LGPL_3_0_ = \"LGPL-3.0+\"\n    LGPLLR = \"LGPLLR\"\n    Libpng = \"Libpng\"\n    libpng_2_0 = \"libpng-2.0\"\n    libselinux_1_0 = \"libselinux-1.0\"\n    libtiff = \"libtiff\"\n    LiLiQ_P_1_1 = \"LiLiQ-P-1.1\"\n    LiLiQ_R_1_1 = \"LiLiQ-R-1.1\"\n    LiLiQ_Rplus_1_1 = \"LiLiQ-Rplus-1.1\"\n    Linux_OpenIB = \"Linux-OpenIB\"\n    LPL_1_0 = \"LPL-1.0\"\n    LPL_1_02 = \"LPL-1.02\"\n    LPPL_1_0 = \"LPPL-1.0\"\n    LPPL_1_1 = \"LPPL-1.1\"\n    LPPL_1_2 = \"LPPL-1.2\"\n    LPPL_1_3a = \"LPPL-1.3a\"\n    LPPL_1_3c = \"LPPL-1.3c\"\n    MakeIndex = \"MakeIndex\"\n    MirOS = \"MirOS\"\n    MIT = \"MIT\"\n    MIT_0 = \"MIT-0\"\n    MIT_advertising = \"MIT-advertising\"\n    MIT_CMU = \"MIT-CMU\"\n    MIT_enna = \"MIT-enna\"\n    MIT_feh = \"MIT-feh\"\n    MIT_Modern_Variant = \"MIT-Modern-Variant\"\n    MIT_open_group = \"MIT-open-group\"\n    MITNFA = \"MITNFA\"\n    Motosoto = \"Motosoto\"\n    mpich2 = \"mpich2\"\n    MPL_1_0 = \"MPL-1.0\"\n    MPL_1_1 = \"MPL-1.1\"\n    MPL_2_0 = \"MPL-2.0\"\n    MPL_2_0_no_copyleft_exception = \"MPL-2.0-no-copyleft-exception\"\n    MS_PL = \"MS-PL\"\n    MS_RL = \"MS-RL\"\n    MTLL = \"MTLL\"\n    MulanPSL_1_0 = \"MulanPSL-1.0\"\n    MulanPSL_2_0 = \"MulanPSL-2.0\"\n    Multics = \"Multics\"\n    Mup = \"Mup\"\n    NAIST_2003 = \"NAIST-2003\"\n    NASA_1_3 = \"NASA-1.3\"\n    Naumen = \"Naumen\"\n    NBPL_1_0 = \"NBPL-1.0\"\n    NCGL_UK_2_0 = \"NCGL-UK-2.0\"\n    NCSA = \"NCSA\"\n    Net_SNMP = \"Net-SNMP\"\n    NetCDF = \"NetCDF\"\n    Newsletr = \"Newsletr\"\n    NGPL = \"NGPL\"\n    NIST_PD = \"NIST-PD\"\n    NIST_PD_fallback = \"NIST-PD-fallback\"\n    NLOD_1_0 = \"NLOD-1.0\"\n    NLPL = \"NLPL\"\n    Nokia = \"Nokia\"\n    NOSL = \"NOSL\"\n    Noweb = \"Noweb\"\n    NPL_1_0 = \"NPL-1.0\"\n    NPL_1_1 = \"NPL-1.1\"\n    NPOSL_3_0 = \"NPOSL-3.0\"\n    NRL = \"NRL\"\n    NTP = \"NTP\"\n    NTP_0 = \"NTP-0\"\n    Nunit = \"Nunit\"\n    O_UDA_1_0 = \"O-UDA-1.0\"\n    OCCT_PL = \"OCCT-PL\"\n    OCLC_2_0 = \"OCLC-2.0\"\n    ODbL_1_0 = \"ODbL-1.0\"\n    ODC_By_1_0 = \"ODC-By-1.0\"\n    OFL_1_0 = \"OFL-1.0\"\n    OFL_1_0_no_RFN = \"OFL-1.0-no-RFN\"\n    OFL_1_0_RFN = \"OFL-1.0-RFN\"\n    OFL_1_1 = \"OFL-1.1\"\n    OFL_1_1_no_RFN = \"OFL-1.1-no-RFN\"\n    OFL_1_1_RFN = \"OFL-1.1-RFN\"\n    OGC_1_0 = \"OGC-1.0\"\n    OGDL_Taiwan_1_0 = \"OGDL-Taiwan-1.0\"\n    OGL_Canada_2_0 = \"OGL-Canada-2.0\"\n    OGL_UK_1_0 = \"OGL-UK-1.0\"\n    OGL_UK_2_0 = \"OGL-UK-2.0\"\n    OGL_UK_3_0 = \"OGL-UK-3.0\"\n    OGTSL = \"OGTSL\"\n    OLDAP_1_1 = \"OLDAP-1.1\"\n    OLDAP_1_2 = \"OLDAP-1.2\"\n    OLDAP_1_3 = \"OLDAP-1.3\"\n    OLDAP_1_4 = \"OLDAP-1.4\"\n    OLDAP_2_0 = \"OLDAP-2.0\"\n    OLDAP_2_0_1 = \"OLDAP-2.0.1\"\n    OLDAP_2_1 = \"OLDAP-2.1\"\n    OLDAP_2_2 = \"OLDAP-2.2\"\n    OLDAP_2_2_1 = \"OLDAP-2.2.1\"\n    OLDAP_2_2_2 = \"OLDAP-2.2.2\"\n    OLDAP_2_3 = \"OLDAP-2.3\"\n    OLDAP_2_4 = \"OLDAP-2.4\"\n    OLDAP_2_5 = \"OLDAP-2.5\"\n    OLDAP_2_6 = \"OLDAP-2.6\"\n    OLDAP_2_7 = \"OLDAP-2.7\"\n    OLDAP_2_8 = \"OLDAP-2.8\"\n    OML = \"OML\"\n    OpenSSL = \"OpenSSL\"\n    OPL_1_0 = \"OPL-1.0\"\n    OSET_PL_2_1 = \"OSET-PL-2.1\"\n    OSL_1_0 = \"OSL-1.0\"\n    OSL_1_1 = \"OSL-1.1\"\n    OSL_2_0 = \"OSL-2.0\"\n    OSL_2_1 = \"OSL-2.1\"\n    OSL_3_0 = \"OSL-3.0\"\n    Parity_6_0_0 = \"Parity-6.0.0\"\n    Parity_7_0_0 = \"Parity-7.0.0\"\n    PDDL_1_0 = \"PDDL-1.0\"\n    PHP_3_0 = \"PHP-3.0\"\n    PHP_3_01 = \"PHP-3.01\"\n    Plexus = \"Plexus\"\n    PolyForm_Noncommercial_1_0_0 = \"PolyForm-Noncommercial-1.0.0\"\n    PolyForm_Small_Business_1_0_0 = \"PolyForm-Small-Business-1.0.0\"\n    PostgreSQL = \"PostgreSQL\"\n    PSF_2_0 = \"PSF-2.0\"\n    psfrag = \"psfrag\"\n    psutils = \"psutils\"\n    Python_2_0 = \"Python-2.0\"\n    Qhull = \"Qhull\"\n    QPL_1_0 = \"QPL-1.0\"\n    Rdisc = \"Rdisc\"\n    RHeCos_1_1 = \"RHeCos-1.1\"\n    RPL_1_1 = \"RPL-1.1\"\n    RPL_1_5 = \"RPL-1.5\"\n    RPSL_1_0 = \"RPSL-1.0\"\n    RSA_MD = \"RSA-MD\"\n    RSCPL = \"RSCPL\"\n    Ruby = \"Ruby\"\n    SAX_PD = \"SAX-PD\"\n    Saxpath = \"Saxpath\"\n    SCEA = \"SCEA\"\n    Sendmail = \"Sendmail\"\n    Sendmail_8_23 = \"Sendmail-8.23\"\n    SGI_B_1_0 = \"SGI-B-1.0\"\n    SGI_B_1_1 = \"SGI-B-1.1\"\n    SGI_B_2_0 = \"SGI-B-2.0\"\n    SHL_0_5 = \"SHL-0.5\"\n    SHL_0_51 = \"SHL-0.51\"\n    SimPL_2_0 = \"SimPL-2.0\"\n    SISSL = \"SISSL\"\n    SISSL_1_2 = \"SISSL-1.2\"\n    Sleepycat = \"Sleepycat\"\n    SMLNJ = \"SMLNJ\"\n    SMPPL = \"SMPPL\"\n    SNIA = \"SNIA\"\n    Spencer_86 = \"Spencer-86\"\n    Spencer_94 = \"Spencer-94\"\n    Spencer_99 = \"Spencer-99\"\n    SPL_1_0 = \"SPL-1.0\"\n    SSH_OpenSSH = \"SSH-OpenSSH\"\n    SSH_short = \"SSH-short\"\n    SSPL_1_0 = \"SSPL-1.0\"\n    StandardML_NJ = \"StandardML-NJ\"\n    SugarCRM_1_1_3 = \"SugarCRM-1.1.3\"\n    SWL = \"SWL\"\n    TAPR_OHL_1_0 = \"TAPR-OHL-1.0\"\n    TCL = \"TCL\"\n    TCP_wrappers = \"TCP-wrappers\"\n    TMate = \"TMate\"\n    TORQUE_1_1 = \"TORQUE-1.1\"\n    TOSL = \"TOSL\"\n    TU_Berlin_1_0 = \"TU-Berlin-1.0\"\n    TU_Berlin_2_0 = \"TU-Berlin-2.0\"\n    UCL_1_0 = \"UCL-1.0\"\n    Unicode_DFS_2015 = \"Unicode-DFS-2015\"\n    Unicode_DFS_2016 = \"Unicode-DFS-2016\"\n    Unicode_TOU = \"Unicode-TOU\"\n    Unlicense = \"Unlicense\"\n    UPL_1_0 = \"UPL-1.0\"\n    Vim = \"Vim\"\n    VOSTROM = \"VOSTROM\"\n    VSL_1_0 = \"VSL-1.0\"\n    W3C = \"W3C\"\n    W3C_19980720 = \"W3C-19980720\"\n    W3C_20150513 = \"W3C-20150513\"\n    Watcom_1_0 = \"Watcom-1.0\"\n    Wsuipa = \"Wsuipa\"\n    WTFPL = \"WTFPL\"\n    wxWindows = \"wxWindows\"\n    X11 = \"X11\"\n    Xerox = \"Xerox\"\n    XFree86_1_1 = \"XFree86-1.1\"\n    xinetd = \"xinetd\"\n    Xnet = \"Xnet\"\n    xpp = \"xpp\"\n    XSkat = \"XSkat\"\n    YPL_1_0 = \"YPL-1.0\"\n    YPL_1_1 = \"YPL-1.1\"\n    Zed = \"Zed\"\n    Zend_2_0 = \"Zend-2.0\"\n    Zimbra_1_3 = \"Zimbra-1.3\"\n    Zimbra_1_4 = \"Zimbra-1.4\"\n    Zlib = \"Zlib\"\n    zlib_acknowledgement = \"zlib-acknowledgement\"\n    ZPL_1_1 = \"ZPL-1.1\"\n    ZPL_2_0 = \"ZPL-2.0\"\n    ZPL_2_1 = \"ZPL-2.1\"\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.ContributionTypeEnum","title":"ContributionTypeEnum","text":"<p>               Bases: <code>MyEnum</code></p> <p>Contribution type using emojis from https://allcontributors.org/docs/en/emoji-key .</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class ContributionTypeEnum(MyEnum):\n    \"\"\"Contribution type using emojis from https://allcontributors.org/docs/en/emoji-key .\"\"\"\n\n    audio = \"audio\"\n    ally = \"ally\"\n    bug = \"bug\"\n    blog = \"blog\"\n    business = \"business\"\n    code = \"code\"\n    content = \"content\"\n    data = \"data\"\n    doc = \"doc\"\n    design = \"design\"\n    example = \"example\"\n    eventOrganizing = \"eventOrganizing\"\n    financial = \"financial\"\n    fundingFinding = \"fundingFinding\"\n    ideas = \"ideas\"\n    infra = \"infra\"\n    maintenance = \"maintenance\"\n    mentoring = \"mentoring\"\n    platform = \"platform\"\n    plugin = \"plugin\"\n    projectManagement = \"projectManagement\"\n    promotion = \"promotion\"\n    question = \"question\"\n    research = \"research\"\n    review = \"review\"\n    security = \"security\"\n    tool = \"tool\"\n    translation = \"translation\"\n    test = \"test\"\n    tutorial = \"tutorial\"\n    talk = \"talk\"\n    userTesting = \"userTesting\"\n    video = \"video\"\n</code></pre>"},{"location":"reference/somesy/core/types/#somesy.core.types.Country","title":"Country","text":"<p>               Bases: <code>MyEnum</code></p> <p>Country codes from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2.</p> <p>It is used for the country of a person in project metadata.</p> Source code in <code>src/somesy/core/types.py</code> <pre><code>class Country(MyEnum):\n    \"\"\"Country codes from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2.\n\n    It is used for the country of a person in project metadata.\n    \"\"\"\n\n    AD = \"AD\"\n    AE = \"AE\"\n    AF = \"AF\"\n    AG = \"AG\"\n    AI = \"AI\"\n    AL = \"AL\"\n    AM = \"AM\"\n    AO = \"AO\"\n    AQ = \"AQ\"\n    AR = \"AR\"\n    AS = \"AS\"\n    AT = \"AT\"\n    AU = \"AU\"\n    AW = \"AW\"\n    AX = \"AX\"\n    AZ = \"AZ\"\n    BA = \"BA\"\n    BB = \"BB\"\n    BD = \"BD\"\n    BE = \"BE\"\n    BF = \"BF\"\n    BG = \"BG\"\n    BH = \"BH\"\n    BI = \"BI\"\n    BJ = \"BJ\"\n    BL = \"BL\"\n    BM = \"BM\"\n    BN = \"BN\"\n    BO = \"BO\"\n    BQ = \"BQ\"\n    BR = \"BR\"\n    BS = \"BS\"\n    BT = \"BT\"\n    BV = \"BV\"\n    BW = \"BW\"\n    BY = \"BY\"\n    BZ = \"BZ\"\n    CA = \"CA\"\n    CC = \"CC\"\n    CD = \"CD\"\n    CF = \"CF\"\n    CG = \"CG\"\n    CH = \"CH\"\n    CI = \"CI\"\n    CK = \"CK\"\n    CL = \"CL\"\n    CM = \"CM\"\n    CN = \"CN\"\n    CO = \"CO\"\n    CR = \"CR\"\n    CU = \"CU\"\n    CV = \"CV\"\n    CW = \"CW\"\n    CX = \"CX\"\n    CY = \"CY\"\n    CZ = \"CZ\"\n    DE = \"DE\"\n    DJ = \"DJ\"\n    DK = \"DK\"\n    DM = \"DM\"\n    DO = \"DO\"\n    DZ = \"DZ\"\n    EC = \"EC\"\n    EE = \"EE\"\n    EG = \"EG\"\n    EH = \"EH\"\n    ER = \"ER\"\n    ES = \"ES\"\n    ET = \"ET\"\n    FI = \"FI\"\n    FJ = \"FJ\"\n    FK = \"FK\"\n    FM = \"FM\"\n    FO = \"FO\"\n    FR = \"FR\"\n    GA = \"GA\"\n    GB = \"GB\"\n    GD = \"GD\"\n    GE = \"GE\"\n    GF = \"GF\"\n    GG = \"GG\"\n    GH = \"GH\"\n    GI = \"GI\"\n    GL = \"GL\"\n    GM = \"GM\"\n    GN = \"GN\"\n    GP = \"GP\"\n    GQ = \"GQ\"\n    GR = \"GR\"\n    GS = \"GS\"\n    GT = \"GT\"\n    GU = \"GU\"\n    GW = \"GW\"\n    GY = \"GY\"\n    HK = \"HK\"\n    HM = \"HM\"\n    HN = \"HN\"\n    HR = \"HR\"\n    HT = \"HT\"\n    HU = \"HU\"\n    ID = \"ID\"\n    IE = \"IE\"\n    IL = \"IL\"\n    IM = \"IM\"\n    IN = \"IN\"\n    IO = \"IO\"\n    IQ = \"IQ\"\n    IR = \"IR\"\n    IS = \"IS\"\n    IT = \"IT\"\n    JE = \"JE\"\n    JM = \"JM\"\n    JO = \"JO\"\n    JP = \"JP\"\n    KE = \"KE\"\n    KG = \"KG\"\n    KH = \"KH\"\n    KI = \"KI\"\n    KM = \"KM\"\n    KN = \"KN\"\n    KP = \"KP\"\n    KR = \"KR\"\n    KW = \"KW\"\n    KY = \"KY\"\n    KZ = \"KZ\"\n    LA = \"LA\"\n    LB = \"LB\"\n    LC = \"LC\"\n    LI = \"LI\"\n    LK = \"LK\"\n    LR = \"LR\"\n    LS = \"LS\"\n    LT = \"LT\"\n    LU = \"LU\"\n    LV = \"LV\"\n    LY = \"LY\"\n    MA = \"MA\"\n    MC = \"MC\"\n    MD = \"MD\"\n    ME = \"ME\"\n    MF = \"MF\"\n    MG = \"MG\"\n    MH = \"MH\"\n    MK = \"MK\"\n    ML = \"ML\"\n    MM = \"MM\"\n    MN = \"MN\"\n    MO = \"MO\"\n    MP = \"MP\"\n    MQ = \"MQ\"\n    MR = \"MR\"\n    MS = \"MS\"\n    MT = \"MT\"\n    MU = \"MU\"\n    MV = \"MV\"\n    MW = \"MW\"\n    MX = \"MX\"\n    MY = \"MY\"\n    MZ = \"MZ\"\n    NA = \"NA\"\n    NC = \"NC\"\n    NE = \"NE\"\n    NF = \"NF\"\n    NG = \"NG\"\n    NI = \"NI\"\n    NL = \"NL\"\n    NO = \"NO\"\n    NP = \"NP\"\n    NR = \"NR\"\n    NU = \"NU\"\n    NZ = \"NZ\"\n    OM = \"OM\"\n    PA = \"PA\"\n    PE = \"PE\"\n    PF = \"PF\"\n    PG = \"PG\"\n    PH = \"PH\"\n    PK = \"PK\"\n    PL = \"PL\"\n    PM = \"PM\"\n    PN = \"PN\"\n    PR = \"PR\"\n    PS = \"PS\"\n    PT = \"PT\"\n    PW = \"PW\"\n    PY = \"PY\"\n    QA = \"QA\"\n    RE = \"RE\"\n    RO = \"RO\"\n    RS = \"RS\"\n    RU = \"RU\"\n    RW = \"RW\"\n    SA = \"SA\"\n    SB = \"SB\"\n    SC = \"SC\"\n    SD = \"SD\"\n    SE = \"SE\"\n    SG = \"SG\"\n    SH = \"SH\"\n    SI = \"SI\"\n    SJ = \"SJ\"\n    SK = \"SK\"\n    SL = \"SL\"\n    SM = \"SM\"\n    SN = \"SN\"\n    SO = \"SO\"\n    SR = \"SR\"\n    SS = \"SS\"\n    ST = \"ST\"\n    SV = \"SV\"\n    SX = \"SX\"\n    SY = \"SY\"\n    SZ = \"SZ\"\n    TC = \"TC\"\n    TD = \"TD\"\n    TF = \"TF\"\n    TG = \"TG\"\n    TH = \"TH\"\n    TJ = \"TJ\"\n    TK = \"TK\"\n    TL = \"TL\"\n    TM = \"TM\"\n    TN = \"TN\"\n    TO = \"TO\"\n    TR = \"TR\"\n    TT = \"TT\"\n    TV = \"TV\"\n    TW = \"TW\"\n    TZ = \"TZ\"\n    UA = \"UA\"\n    UG = \"UG\"\n    UM = \"UM\"\n    US = \"US\"\n    UY = \"UY\"\n    UZ = \"UZ\"\n    VA = \"VA\"\n    VC = \"VC\"\n    VE = \"VE\"\n    VG = \"VG\"\n    VI = \"VI\"\n    VN = \"VN\"\n    VU = \"VU\"\n    WF = \"WF\"\n    WS = \"WS\"\n    YE = \"YE\"\n    YT = \"YT\"\n    ZA = \"ZA\"\n    ZM = \"ZM\"\n    ZW = \"ZW\"\n</code></pre>"},{"location":"reference/somesy/core/writer/","title":"writer","text":"<p>Project metadata writer base-class.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.FieldKeyMapping","title":"FieldKeyMapping  <code>module-attribute</code>","text":"<pre><code>FieldKeyMapping = Dict[str, Union[List[str], IgnoreKey]]\n</code></pre> <p>Type to be used for the dict passed as <code>direct_mappings</code>.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.DictLike","title":"DictLike  <code>module-attribute</code>","text":"<pre><code>DictLike = Any\n</code></pre> <p>Dict-like that supports getitem, setitem, delitem, etc.</p> <p>NOTE: This should be probably turned into a proper protocol.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.IgnoreKey","title":"IgnoreKey","text":"<p>Special marker to be passed for dropping a key from serialization.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>class IgnoreKey:\n    \"\"\"Special marker to be passed for dropping a key from serialization.\"\"\"\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter","title":"ProjectMetadataWriter","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for Project Metadata Output Wrapper.</p> <p>All supported output formats are implemented as subclasses.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>class ProjectMetadataWriter(ABC):\n    \"\"\"Base class for Project Metadata Output Wrapper.\n\n    All supported output formats are implemented as subclasses.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        *,\n        create_if_not_exists: Optional[bool] = False,\n        direct_mappings: FieldKeyMapping = None,\n        merge: Optional[bool] = False,\n        pass_validation: Optional[bool] = False,\n    ) -&gt; None:\n        \"\"\"Initialize the Project Metadata Output Wrapper.\n\n        Use the `direct_mappings` dict to define\n        format-specific location for certain fields,\n        if no additional processing is needed that\n        requires a customized setter.\n\n        Args:\n            path: Path to target output file.\n            create_if_not_exists: Create an empty CFF file if not exists. Defaults to True.\n            direct_mappings: Dict with direct mappings of keys between somesy and target\n            merge: Merge the output file with an existing file. Defaults to False.\n            pass_validation: Pass validation for all output files. Defaults to False.\n\n        \"\"\"\n        self._data: DictLike = {}\n        self.path = path if isinstance(path, Path) else Path(path)\n        self.create_if_not_exists = create_if_not_exists\n        self.direct_mappings = direct_mappings or {}\n        self.merge = merge\n        self.pass_validation = pass_validation\n        if self.path.is_file():\n            self._load()\n            if not self.pass_validation:\n                self._validate()\n        else:\n            if self.create_if_not_exists:\n                self._init_new_file()\n                self._load()\n            else:\n                raise FileNotFoundError(f\"The file {self.path} does not exist.\")\n\n    def _init_new_file(self) -&gt; None:\n        \"\"\"Create an new suitable target file.\n\n        Override to initialize file with minimal contents, if needed.\n        Make sure to set `self._data` to match the contents.\n        \"\"\"\n        self.path.touch()\n\n    @abstractmethod\n    def _load(self):\n        \"\"\"Load the output file and validate it.\n\n        Implement this method so that it loads the file `self.path`\n        into the `self._data` dict.\n\n        The file is guaranteed to exist.\n        \"\"\"\n\n    @abstractmethod\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the target file data.\n\n        Implement this method so that it checks\n        the validity of the metadata (relevant to somesy)\n        in that file and raises exceptions on failure.\n        \"\"\"\n\n    @abstractmethod\n    def save(self, path: Optional[Path]) -&gt; None:\n        \"\"\"Save the output file to the given path.\n\n        Implement this in a way that will carefully\n        update the target file with new metadata\n        without destroying its other contents or structure.\n        \"\"\"\n\n    def _get_property(\n        self,\n        key: Union[str, List[str]],\n        *,\n        only_first: bool = False,\n        remove: bool = False,\n    ) -&gt; Optional[Any]:\n        \"\"\"Get a property from the data.\n\n        Override this to e.g. rewrite the retrieved key\n        (e.g. if everything relevant is in some subobject).\n\n        Args:\n            key: Name of the key or sequence of multiple keys to retrieve the value.\n            only_first: If True, returns only first entry if the value is a list.\n            remove: If True, will remove the retrieved value and clean up the dict.\n\n        \"\"\"\n        key_path = [key] if isinstance(key, str) else key\n\n        curr = self._data\n        seq = [curr]\n        for k in key_path:\n            curr = curr.get(k)\n            curr = curr[0] if isinstance(curr, list) and only_first else curr\n            seq.append(curr)\n            if curr is None:\n                return None\n\n        if remove:\n            seq.pop()\n            del seq[-1][key_path[-1]]  # remove leaf value\n            # clean up the tree\n            for key, dct in reversed(list(zip(key_path[:-1], seq[:-1]))):\n                if not dct.get(key):\n                    del dct[key]\n\n        if isinstance(curr, list) and only_first:\n            return curr[0]\n        return curr\n\n    def _set_property(self, key: Union[str, List[str], IgnoreKey], value: Any) -&gt; None:\n        \"\"\"Set a property in the data.\n\n        Note if there are lists along the path, they are cleared out.\n\n        Override this to e.g. rewrite the retrieved key\n        (e.g. if everything relevant is in some subobject).\n        \"\"\"\n        if isinstance(key, IgnoreKey):\n            return\n        key_path = [key] if isinstance(key, str) else key\n\n        if not value:  # remove value and clean up the sub-dict\n            self._get_property(key_path, remove=True)\n            return\n\n        # create path on the fly if needed\n        curr = self._data\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr[key] = {}\n            curr = curr[key]\n\n        curr[key_path[-1]] = value\n\n    # ----\n    # special handling for person metadata\n\n    def _merge_person_metadata(\n        self, old: List[Union[Person, Entity]], new: List[Union[Person, Entity]]\n    ) -&gt; List[Union[Person, Entity]]:\n        \"\"\"Update metadata of a list of persons.\n\n        Will identify people based on orcid, email or full name.\n\n        If old list has same person listed multiple times,\n        the resulting list will too (we cannot correctly merge for external formats.)\n        \"\"\"\n        new_people = []  # list for new people (e.g. added authors)\n        # flag, meaning \"person was not removed\"\n        still_exists = [False for i in range(len(old))]\n        # copies of old person data, to be modified\n        modified_people = [p.model_copy() for p in old]\n\n        # try to match new people to existing old ones\n        # (inefficient, but author list are not that long usually)\n        for person_meta in new:\n            person_update = person_meta.model_dump()\n            person_existed = False\n            for i in range(len(modified_people)):\n                person = modified_people[i]\n                if not person.same_person(person_meta):\n                    continue\n\n                # not new person (-&gt; will not append new record)\n                person_existed = True\n                # still exists (-&gt; will not be removed from list)\n                still_exists[i] = True\n\n                # if there were changes -&gt; update person\n                overlapping_fields = person.model_dump(\n                    include=set(person_update.keys())\n                )\n                if person_update != overlapping_fields:\n                    modified_people[i] = person.model_copy(update=person_update)\n\n                    # show effective update in debug log\n                    old_fmt = self._from_person(person)\n                    new_fmt = self._from_person(modified_people[i])\n                    if old_fmt != new_fmt:\n                        logger.debug(f\"Updating person\\n{old_fmt}\\nto\\n{new_fmt}\")\n\n            if not person_existed:\n                new_people.append(person_meta)\n\n        # show added and removed people in debug log\n        removed_people = [old[i] for i in range(len(old)) if not still_exists[i]]\n        for person in removed_people:\n            logger.debug(f\"Removing person\\n{self._from_person(person)}\")\n        for person in new_people:\n            logger.debug(f\"Adding person\\n{self._from_person(person)}\")\n\n        # return updated list of (still existing) people,\n        # and all new people coming after them.\n        existing_modified = [\n            modified_people[i] for i in range(len(old)) if still_exists[i]\n        ]\n        return existing_modified + new_people\n\n    def _sync_person_list(\n        self, old: List[Any], new: List[Union[Person, Entity]]\n    ) -&gt; List[Any]:\n        \"\"\"Sync a list of persons with new metadata.\n\n        Args:\n            old (List[Any]): list of persons in format-specific representation\n            new (List[Person]): list of persons in somesy representation\n\n        Returns:\n            List[Any]: updated list of persons in format-specific representation\n\n        \"\"\"\n        old_people: List[Union[Person, Entity]] = self._parse_people(old)\n        return self._merge_person_metadata(old_people, new)\n\n    def _sync_authors(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file authors with authors from metadata.\n\n        This method is existing for the publication_author special case\n        when synchronizing to CITATION.cff.\n        \"\"\"\n        self.authors = self._sync_person_list(self.authors, metadata.authors())\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file with other metadata files.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n\n        if metadata.version:\n            self.version = metadata.version\n\n        if metadata.keywords:\n            self.keywords = metadata.keywords\n\n        self._sync_authors(metadata)\n        self.maintainers = self._sync_person_list(\n            self.maintainers, metadata.maintainers()\n        )\n\n        self.license = metadata.license.value\n\n        self.homepage = str(metadata.homepage) if metadata.homepage else None\n        self.repository = str(metadata.repository) if metadata.repository else None\n        self.documentation = (\n            str(metadata.documentation) if metadata.documentation else None\n        )\n\n    @staticmethod\n    @abstractmethod\n    def _from_person(person: Union[Person, Entity]) -&gt; Any:\n        \"\"\"Convert a `Person` or `Entity` object into suitable target format.\"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def _to_person(person_obj: Any) -&gt; Union[Person, Entity]:\n        \"\"\"Convert an object representing a person into a `Person` or `Entity` object.\"\"\"\n\n    @classmethod\n    def _parse_people(cls, people: Optional[List[Any]]) -&gt; List[Union[Person, Entity]]:\n        \"\"\"Return a list of Persons and Entities parsed from list of format-specific people representations.\"\"\"\n        # remove None values\n        people = [p for p in people if p is not None]\n\n        people = list(map(cls._to_person, people or []))\n        return people\n\n    # ----\n    # individual magic getters and setters\n\n    def _get_key(self, key):\n        \"\"\"Get a key itself.\"\"\"\n        return self.direct_mappings.get(key) or key\n\n    @property\n    def name(self):\n        \"\"\"Return the name of the project.\"\"\"\n        return self._get_property(self._get_key(\"name\"))\n\n    @name.setter\n    def name(self, name: str) -&gt; None:\n        \"\"\"Set the name of the project.\"\"\"\n        self._set_property(self._get_key(\"name\"), name)\n\n    @property\n    def version(self) -&gt; Optional[str]:\n        \"\"\"Return the version of the project.\"\"\"\n        return self._get_property(self._get_key(\"version\"))\n\n    @version.setter\n    def version(self, version: str) -&gt; None:\n        \"\"\"Set the version of the project.\"\"\"\n        self._set_property(self._get_key(\"version\"), version)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        \"\"\"Return the description of the project.\"\"\"\n        return self._get_property(self._get_key(\"description\"))\n\n    @description.setter\n    def description(self, description: str) -&gt; None:\n        \"\"\"Set the description of the project.\"\"\"\n        self._set_property(self._get_key(\"description\"), description)\n\n    @property\n    def authors(self):\n        \"\"\"Return the authors of the project.\"\"\"\n        authors = self._get_property(self._get_key(\"authors\"))\n        if authors is None:\n            return []\n\n        # only return authors that can be converted to Person\n        authors_validated = [\n            author for author in authors if self._to_person(author) is not None\n        ]\n        return authors_validated\n\n    @authors.setter\n    def authors(self, authors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors = [self._from_person(c) for c in authors]\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @property\n    def maintainers(self):\n        \"\"\"Return the maintainers of the project.\"\"\"\n        maintainers = self._get_property(self._get_key(\"maintainers\"))\n        if maintainers is None:\n            return []\n\n        # only return maintainers that can be converted to Person\n        maintainers_validated = [\n            maintainer\n            for maintainer in maintainers\n            if self._to_person(maintainer) is not None\n        ]\n        return maintainers_validated\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        maintainers = [self._from_person(c) for c in maintainers]\n        self._set_property(self._get_key(\"maintainers\"), maintainers)\n\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the project.\"\"\"\n        return self._get_property(self._get_key(\"contributors\"))\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contributors = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors)\n\n    @property\n    def keywords(self) -&gt; Optional[List[str]]:\n        \"\"\"Return the keywords of the project.\"\"\"\n        return self._get_property(self._get_key(\"keywords\"))\n\n    @keywords.setter\n    def keywords(self, keywords: List[str]) -&gt; None:\n        \"\"\"Set the keywords of the project.\"\"\"\n        self._set_property(self._get_key(\"keywords\"), keywords)\n\n    @property\n    def license(self) -&gt; Optional[str]:\n        \"\"\"Return the license of the project.\"\"\"\n        return self._get_property(self._get_key(\"license\"))\n\n    @license.setter\n    def license(self, license: Optional[str]) -&gt; None:\n        \"\"\"Set the license of the project.\"\"\"\n        self._set_property(self._get_key(\"license\"), license)\n\n    @property\n    def homepage(self) -&gt; Optional[str]:\n        \"\"\"Return the homepage url of the project.\"\"\"\n        return self._get_property(self._get_key(\"homepage\"))\n\n    @homepage.setter\n    def homepage(self, value: Optional[str]) -&gt; None:\n        \"\"\"Set the homepage url of the project.\"\"\"\n        self._set_property(self._get_key(\"homepage\"), value)\n\n    @property\n    def repository(self) -&gt; Optional[Union[str, dict]]:\n        \"\"\"Return the repository url of the project.\"\"\"\n        return self._get_property(self._get_key(\"repository\"))\n\n    @repository.setter\n    def repository(self, value: Optional[Union[str, dict]]) -&gt; None:\n        \"\"\"Set the repository url of the project.\"\"\"\n        self._set_property(self._get_key(\"repository\"), value)\n\n    @property\n    def documentation(self) -&gt; Optional[Union[str, dict]]:\n        \"\"\"Return the documentation url of the project.\"\"\"\n        return self._get_property(self._get_key(\"documentation\"))\n\n    @documentation.setter\n    def documentation(self, value: Optional[Union[str, dict]]) -&gt; None:\n        \"\"\"Set the documentation url of the project.\"\"\"\n        self._set_property(self._get_key(\"documentation\"), value)\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name\n</code></pre> <p>Return the name of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.version","title":"version  <code>property</code> <code>writable</code>","text":"<pre><code>version: Optional[str]\n</code></pre> <p>Return the version of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.description","title":"description  <code>property</code> <code>writable</code>","text":"<pre><code>description: Optional[str]\n</code></pre> <p>Return the description of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the authors of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the maintainers of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.keywords","title":"keywords  <code>property</code> <code>writable</code>","text":"<pre><code>keywords: Optional[List[str]]\n</code></pre> <p>Return the keywords of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.license","title":"license  <code>property</code> <code>writable</code>","text":"<pre><code>license: Optional[str]\n</code></pre> <p>Return the license of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.homepage","title":"homepage  <code>property</code> <code>writable</code>","text":"<pre><code>homepage: Optional[str]\n</code></pre> <p>Return the homepage url of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.repository","title":"repository  <code>property</code> <code>writable</code>","text":"<pre><code>repository: Optional[Union[str, dict]]\n</code></pre> <p>Return the repository url of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.documentation","title":"documentation  <code>property</code> <code>writable</code>","text":"<pre><code>documentation: Optional[Union[str, dict]]\n</code></pre> <p>Return the documentation url of the project.</p>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    *,\n    create_if_not_exists: Optional[bool] = False,\n    direct_mappings: FieldKeyMapping = None,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False\n) -&gt; None\n</code></pre> <p>Initialize the Project Metadata Output Wrapper.</p> <p>Use the <code>direct_mappings</code> dict to define format-specific location for certain fields, if no additional processing is needed that requires a customized setter.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to target output file.</p> required <code>create_if_not_exists</code> <code>Optional[bool]</code> <p>Create an empty CFF file if not exists. Defaults to True.</p> <code>False</code> <code>direct_mappings</code> <code>FieldKeyMapping</code> <p>Dict with direct mappings of keys between somesy and target</p> <code>None</code> <code>merge</code> <code>Optional[bool]</code> <p>Merge the output file with an existing file. Defaults to False.</p> <code>False</code> <code>pass_validation</code> <code>Optional[bool]</code> <p>Pass validation for all output files. Defaults to False.</p> <code>False</code> Source code in <code>src/somesy/core/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    *,\n    create_if_not_exists: Optional[bool] = False,\n    direct_mappings: FieldKeyMapping = None,\n    merge: Optional[bool] = False,\n    pass_validation: Optional[bool] = False,\n) -&gt; None:\n    \"\"\"Initialize the Project Metadata Output Wrapper.\n\n    Use the `direct_mappings` dict to define\n    format-specific location for certain fields,\n    if no additional processing is needed that\n    requires a customized setter.\n\n    Args:\n        path: Path to target output file.\n        create_if_not_exists: Create an empty CFF file if not exists. Defaults to True.\n        direct_mappings: Dict with direct mappings of keys between somesy and target\n        merge: Merge the output file with an existing file. Defaults to False.\n        pass_validation: Pass validation for all output files. Defaults to False.\n\n    \"\"\"\n    self._data: DictLike = {}\n    self.path = path if isinstance(path, Path) else Path(path)\n    self.create_if_not_exists = create_if_not_exists\n    self.direct_mappings = direct_mappings or {}\n    self.merge = merge\n    self.pass_validation = pass_validation\n    if self.path.is_file():\n        self._load()\n        if not self.pass_validation:\n            self._validate()\n    else:\n        if self.create_if_not_exists:\n            self._init_new_file()\n            self._load()\n        else:\n            raise FileNotFoundError(f\"The file {self.path} does not exist.\")\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.save","title":"save  <code>abstractmethod</code>","text":"<pre><code>save(path: Optional[Path]) -&gt; None\n</code></pre> <p>Save the output file to the given path.</p> <p>Implement this in a way that will carefully update the target file with new metadata without destroying its other contents or structure.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>@abstractmethod\ndef save(self, path: Optional[Path]) -&gt; None:\n    \"\"\"Save the output file to the given path.\n\n    Implement this in a way that will carefully\n    update the target file with new metadata\n    without destroying its other contents or structure.\n    \"\"\"\n</code></pre>"},{"location":"reference/somesy/core/writer/#somesy.core.writer.ProjectMetadataWriter.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/core/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync output file with other metadata files.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n\n    if metadata.version:\n        self.version = metadata.version\n\n    if metadata.keywords:\n        self.keywords = metadata.keywords\n\n    self._sync_authors(metadata)\n    self.maintainers = self._sync_person_list(\n        self.maintainers, metadata.maintainers()\n    )\n\n    self.license = metadata.license.value\n\n    self.homepage = str(metadata.homepage) if metadata.homepage else None\n    self.repository = str(metadata.repository) if metadata.repository else None\n    self.documentation = (\n        str(metadata.documentation) if metadata.documentation else None\n    )\n</code></pre>"},{"location":"reference/somesy/fortran/","title":"fortran","text":"<p>Fortran module.</p>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran","title":"Fortran","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Fortran config file handler parsed from fpm.toml.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>class Fortran(ProjectMetadataWriter):\n    \"\"\"Fortran config file handler parsed from fpm.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Fortran config file handler parsed from fpm.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings: FieldKeyMapping = {\n            \"authors\": [\"author\"],\n            \"maintainers\": [\"maintainer\"],\n            \"documentation\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the fpm.toml file as list.\"\"\"\n        authors = []\n        try:\n            self._to_person(self._get_property(self._get_key(\"authors\")))\n            authors = [self._get_property(self._get_key(\"authors\"))]\n        except ValueError:\n            logger.warning(\"Cannot convert authors to Person object.\")\n        return authors\n\n    @authors.setter\n    def authors(self, authors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        self._set_property(self._get_key(\"authors\"), self._from_person(authors[0]))\n\n    @property\n    def maintainers(self):\n        \"\"\"Return the only author of the fpm.toml file as list.\"\"\"\n        maintainers = self._get_property(self._get_key(\"maintainers\"))\n        if maintainers:\n            return [self._get_property(self._get_key(\"maintainers\"))]\n        return []\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        maintainers = self._from_person(maintainers[0])\n        self._set_property(self._get_key(\"maintainers\"), maintainers)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load fpm.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {FortranConfig.__name__}: {pretty_repr(config)}\"\n        )\n        FortranConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the fpm file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person/entity object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file with other metadata files.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n\n        if metadata.version:\n            self.version = metadata.version\n\n        if metadata.keywords:\n            self.keywords = metadata.keywords\n\n        self.authors = metadata.authors()\n        maintainers = metadata.maintainers()\n\n        # set if not empty\n        if maintainers:\n            # only one maintainer is allowed\n            self.maintainers = maintainers\n\n        self.license = metadata.license.value\n\n        self.homepage = str(metadata.homepage) if metadata.homepage else None\n</code></pre>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the fpm.toml file as list.</p>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the only author of the fpm.toml file as list.</p>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Fortran config file handler parsed from fpm.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Fortran config file handler parsed from fpm.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings: FieldKeyMapping = {\n        \"authors\": [\"author\"],\n        \"maintainers\": [\"maintainer\"],\n        \"documentation\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the fpm file.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the fpm file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/fortran/#somesy.fortran.Fortran.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync output file with other metadata files.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n\n    if metadata.version:\n        self.version = metadata.version\n\n    if metadata.keywords:\n        self.keywords = metadata.keywords\n\n    self.authors = metadata.authors()\n    maintainers = metadata.maintainers()\n\n    # set if not empty\n    if maintainers:\n        # only one maintainer is allowed\n        self.maintainers = maintainers\n\n    self.license = metadata.license.value\n\n    self.homepage = str(metadata.homepage) if metadata.homepage else None\n</code></pre>"},{"location":"reference/somesy/fortran/models/","title":"models","text":"<p>Pyproject models.</p>"},{"location":"reference/somesy/fortran/models/#somesy.fortran.models.FortranConfig","title":"FortranConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Fortran configuration model.</p> Source code in <code>src/somesy/fortran/models.py</code> <pre><code>class FortranConfig(BaseModel):\n    \"\"\"Fortran configuration model.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    name: Annotated[\n        str,\n        Field(pattern=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\", description=\"Package name\"),\n    ]\n    version: Annotated[\n        Optional[str],\n        Field(\n            pattern=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\",\n            description=\"Package version\",\n        ),\n    ] = None\n    description: Annotated[Optional[str], Field(description=\"Package description\")] = (\n        None\n    )\n    license: Annotated[\n        Optional[str],\n        Field(description=\"SPDX license identifier(s).\"),\n    ] = None\n    author: Annotated[\n        Optional[str], Field(description=\"Package author information\")\n    ] = None\n    maintainer: Annotated[\n        Optional[str], Field(description=\"Package maintainer information\")\n    ] = None\n    copyright: Annotated[Optional[str], Field(description=\"Package copyright text\")] = (\n        None\n    )\n    homepage: Annotated[Optional[HttpUrlStr], Field(description=\"Package homepage\")] = (\n        None\n    )\n    keywords: Annotated[\n        Optional[Set[str]], Field(description=\"Keywords that describe the package\")\n    ] = None\n    categories: Annotated[\n        Optional[Set[str]], Field(description=\"Categories that package falls into\")\n    ] = None\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid version\") from err\n        return v\n</code></pre>"},{"location":"reference/somesy/fortran/models/#somesy.fortran.models.FortranConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/fortran/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid version\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/fortran/writer/","title":"writer","text":"<p>Fortran writer.</p>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran","title":"Fortran","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Fortran config file handler parsed from fpm.toml.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>class Fortran(ProjectMetadataWriter):\n    \"\"\"Fortran config file handler parsed from fpm.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Fortran config file handler parsed from fpm.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings: FieldKeyMapping = {\n            \"authors\": [\"author\"],\n            \"maintainers\": [\"maintainer\"],\n            \"documentation\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the fpm.toml file as list.\"\"\"\n        authors = []\n        try:\n            self._to_person(self._get_property(self._get_key(\"authors\")))\n            authors = [self._get_property(self._get_key(\"authors\"))]\n        except ValueError:\n            logger.warning(\"Cannot convert authors to Person object.\")\n        return authors\n\n    @authors.setter\n    def authors(self, authors: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        self._set_property(self._get_key(\"authors\"), self._from_person(authors[0]))\n\n    @property\n    def maintainers(self):\n        \"\"\"Return the only author of the fpm.toml file as list.\"\"\"\n        maintainers = self._get_property(self._get_key(\"maintainers\"))\n        if maintainers:\n            return [self._get_property(self._get_key(\"maintainers\"))]\n        return []\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Union[Person, Entity]]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        maintainers = self._from_person(maintainers[0])\n        self._set_property(self._get_key(\"maintainers\"), maintainers)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load fpm.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {FortranConfig.__name__}: {pretty_repr(config)}\"\n        )\n        FortranConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the fpm file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person/entity object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file with other metadata files.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n\n        if metadata.version:\n            self.version = metadata.version\n\n        if metadata.keywords:\n            self.keywords = metadata.keywords\n\n        self.authors = metadata.authors()\n        maintainers = metadata.maintainers()\n\n        # set if not empty\n        if maintainers:\n            # only one maintainer is allowed\n            self.maintainers = maintainers\n\n        self.license = metadata.license.value\n\n        self.homepage = str(metadata.homepage) if metadata.homepage else None\n</code></pre>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the fpm.toml file as list.</p>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the only author of the fpm.toml file as list.</p>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Fortran config file handler parsed from fpm.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Fortran config file handler parsed from fpm.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings: FieldKeyMapping = {\n        \"authors\": [\"author\"],\n        \"maintainers\": [\"maintainer\"],\n        \"documentation\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the fpm file.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the fpm file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/fortran/writer/#somesy.fortran.writer.Fortran.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/fortran/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync output file with other metadata files.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n\n    if metadata.version:\n        self.version = metadata.version\n\n    if metadata.keywords:\n        self.keywords = metadata.keywords\n\n    self.authors = metadata.authors()\n    maintainers = metadata.maintainers()\n\n    # set if not empty\n    if maintainers:\n        # only one maintainer is allowed\n        self.maintainers = maintainers\n\n    self.license = metadata.license.value\n\n    self.homepage = str(metadata.homepage) if metadata.homepage else None\n</code></pre>"},{"location":"reference/somesy/julia/","title":"julia","text":"<p>Julia module.</p>"},{"location":"reference/somesy/julia/#somesy.julia.Julia","title":"Julia","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Julia config file handler parsed from Project.toml.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>class Julia(ProjectMetadataWriter):\n    \"\"\"Julia config file handler parsed from Project.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Julia config file handler parsed from Project.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self) -&gt; None:\n        \"\"\"Load Project.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {JuliaConfig.__name__}: {pretty_repr(config)}\"\n        )\n        JuliaConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the julia file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to a name+email string.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Person]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file with other metadata files.\"\"\"\n        # overridden to not sync fields that are not present in the Project.toml file\n        self.name = metadata.name\n        self.version = metadata.version\n\n        self._sync_authors(metadata)\n</code></pre>"},{"location":"reference/somesy/julia/#somesy.julia.Julia.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Julia config file handler parsed from Project.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Julia config file handler parsed from Project.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/julia/#somesy.julia.Julia.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the julia file.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the julia file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/julia/#somesy.julia.Julia.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync output file with other metadata files.\"\"\"\n    # overridden to not sync fields that are not present in the Project.toml file\n    self.name = metadata.name\n    self.version = metadata.version\n\n    self._sync_authors(metadata)\n</code></pre>"},{"location":"reference/somesy/julia/models/","title":"models","text":"<p>Julia model.</p>"},{"location":"reference/somesy/julia/models/#somesy.julia.models.JuliaConfig","title":"JuliaConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Julia configuration model.</p> Source code in <code>src/somesy/julia/models.py</code> <pre><code>class JuliaConfig(BaseModel):\n    \"\"\"Julia configuration model.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    name: Annotated[\n        str,\n        Field(description=\"Package name\"),\n    ]\n    version: Annotated[\n        str,\n        Field(\n            pattern=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\",\n            description=\"Package version\",\n        ),\n    ]\n    uuid: Annotated[str, Field(description=\"Package UUID\")]\n    authors: Annotated[Optional[Set[str]], Field(description=\"Package authors\")] = None\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid version\") from err\n        return v\n\n    @field_validator(\"authors\")\n    @classmethod\n    def validate_email_format(cls, v):\n        \"\"\"Validate person format, omit person that is not in correct format, don't raise an error.\"\"\"\n        if v is None:\n            return []\n        validated = []\n        for author in v:\n            try:\n                if not (\n                    not isinstance(author, str)\n                    or \" \" not in author\n                    or not EMailAddress.validate_python(author.split(\" \")[-1][1:-1])\n                ):\n                    validated.append(author)\n                else:\n                    logger.warning(\n                        f\"Invalid email format for author {author}, omitting.\"\n                    )\n            except ValidationError:\n                logger.warning(f\"Invalid format for author {author}, omitting.\")\n        return validated\n\n    @field_validator(\"uuid\")\n    @classmethod\n    def validate_uuid(cls, v):\n        \"\"\"Validate uuid field.\"\"\"\n        try:\n            _ = uuid.UUID(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid UUID\") from err\n        return v\n</code></pre>"},{"location":"reference/somesy/julia/models/#somesy.julia.models.JuliaConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/julia/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid version\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/julia/models/#somesy.julia.models.JuliaConfig.validate_email_format","title":"validate_email_format  <code>classmethod</code>","text":"<pre><code>validate_email_format(v)\n</code></pre> <p>Validate person format, omit person that is not in correct format, don't raise an error.</p> Source code in <code>src/somesy/julia/models.py</code> <pre><code>@field_validator(\"authors\")\n@classmethod\ndef validate_email_format(cls, v):\n    \"\"\"Validate person format, omit person that is not in correct format, don't raise an error.\"\"\"\n    if v is None:\n        return []\n    validated = []\n    for author in v:\n        try:\n            if not (\n                not isinstance(author, str)\n                or \" \" not in author\n                or not EMailAddress.validate_python(author.split(\" \")[-1][1:-1])\n            ):\n                validated.append(author)\n            else:\n                logger.warning(\n                    f\"Invalid email format for author {author}, omitting.\"\n                )\n        except ValidationError:\n            logger.warning(f\"Invalid format for author {author}, omitting.\")\n    return validated\n</code></pre>"},{"location":"reference/somesy/julia/models/#somesy.julia.models.JuliaConfig.validate_uuid","title":"validate_uuid  <code>classmethod</code>","text":"<pre><code>validate_uuid(v)\n</code></pre> <p>Validate uuid field.</p> Source code in <code>src/somesy/julia/models.py</code> <pre><code>@field_validator(\"uuid\")\n@classmethod\ndef validate_uuid(cls, v):\n    \"\"\"Validate uuid field.\"\"\"\n    try:\n        _ = uuid.UUID(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid UUID\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/julia/writer/","title":"writer","text":"<p>Julia writer.</p>"},{"location":"reference/somesy/julia/writer/#somesy.julia.writer.Julia","title":"Julia","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Julia config file handler parsed from Project.toml.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>class Julia(ProjectMetadataWriter):\n    \"\"\"Julia config file handler parsed from Project.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Julia config file handler parsed from Project.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self) -&gt; None:\n        \"\"\"Load Project.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {JuliaConfig.__name__}: {pretty_repr(config)}\"\n        )\n        JuliaConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the julia file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to a name+email string.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Person]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync output file with other metadata files.\"\"\"\n        # overridden to not sync fields that are not present in the Project.toml file\n        self.name = metadata.name\n        self.version = metadata.version\n\n        self._sync_authors(metadata)\n</code></pre>"},{"location":"reference/somesy/julia/writer/#somesy.julia.writer.Julia.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Julia config file handler parsed from Project.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Julia config file handler parsed from Project.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/julia/writer/#somesy.julia.writer.Julia.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the julia file.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the julia file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/julia/writer/#somesy.julia.writer.Julia.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync output file with other metadata files.</p> Source code in <code>src/somesy/julia/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync output file with other metadata files.\"\"\"\n    # overridden to not sync fields that are not present in the Project.toml file\n    self.name = metadata.name\n    self.version = metadata.version\n\n    self._sync_authors(metadata)\n</code></pre>"},{"location":"reference/somesy/mkdocs/","title":"mkdocs","text":"<p>MkDocs module.</p>"},{"location":"reference/somesy/mkdocs/#somesy.mkdocs.MkDocs","title":"MkDocs","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Project documentation with Markdown (MkDocs) parser and saver.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>class MkDocs(ProjectMetadataWriter):\n    \"\"\"Project documentation with Markdown (MkDocs) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = False,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Project documentation with Markdown (MkDocs) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings: FieldKeyMapping = {\n            \"name\": [\"site_name\"],\n            \"description\": [\"site_description\"],\n            \"homepage\": [\"site_url\"],\n            \"repository\": [\"repo_url\"],\n            \"authors\": [\"site_author\"],\n            \"documentation\": IgnoreKey(),\n            \"version\": IgnoreKey(),\n            \"maintainers\": IgnoreKey(),\n            \"license\": IgnoreKey(),\n            \"keywords\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=create_if_not_exists,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self):\n        \"\"\"Load the MkDocs file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the MkDocs file.\"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {MkDocsConfig.__name__}: {pretty_repr(config)}\"\n        )\n        MkDocsConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the MkDocs object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author from the source file as list.\"\"\"\n        authors = self._get_property(self._get_key(\"authors\"))\n        if authors is None or self._to_person(authors) is None:\n            return []\n        else:\n            return [authors]\n\n    @authors.setter\n    def authors(self, authors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @staticmethod\n    def _from_person(person: Union[Entity, Person]):\n        \"\"\"MkDocs Person is a string with full name.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Entity, Person]]:\n        \"\"\"MkDocs Person is a string with full name.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync the MkDocs object with the ProjectMetadata object.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n        # no author merge since it is a free text field\n        self.authors = metadata.authors()\n        if metadata.homepage:\n            self.homepage = str(metadata.homepage)\n        if metadata.repository:\n            self.repository = str(metadata.repository)\n            self.repo_name = metadata.repository.path\n</code></pre>"},{"location":"reference/somesy/mkdocs/#somesy.mkdocs.MkDocs.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author from the source file as list.</p>"},{"location":"reference/somesy/mkdocs/#somesy.mkdocs.MkDocs.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    create_if_not_exists: bool = False,\n    pass_validation: Optional[bool] = False,\n)\n</code></pre> <p>Project documentation with Markdown (MkDocs) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = False,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Project documentation with Markdown (MkDocs) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings: FieldKeyMapping = {\n        \"name\": [\"site_name\"],\n        \"description\": [\"site_description\"],\n        \"homepage\": [\"site_url\"],\n        \"repository\": [\"repo_url\"],\n        \"authors\": [\"site_author\"],\n        \"documentation\": IgnoreKey(),\n        \"version\": IgnoreKey(),\n        \"maintainers\": IgnoreKey(),\n        \"license\": IgnoreKey(),\n        \"keywords\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=create_if_not_exists,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/mkdocs/#somesy.mkdocs.MkDocs.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the MkDocs object to a file.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the MkDocs object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/mkdocs/#somesy.mkdocs.MkDocs.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync the MkDocs object with the ProjectMetadata object.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync the MkDocs object with the ProjectMetadata object.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n    # no author merge since it is a free text field\n    self.authors = metadata.authors()\n    if metadata.homepage:\n        self.homepage = str(metadata.homepage)\n    if metadata.repository:\n        self.repository = str(metadata.repository)\n        self.repo_name = metadata.repository.path\n</code></pre>"},{"location":"reference/somesy/mkdocs/models/","title":"models","text":"<p>Pyproject models.</p>"},{"location":"reference/somesy/mkdocs/models/#somesy.mkdocs.models.MkDocsConfig","title":"MkDocsConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>MkDocs configuration model.</p> Source code in <code>src/somesy/mkdocs/models.py</code> <pre><code>class MkDocsConfig(BaseModel):\n    \"\"\"MkDocs configuration model.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    site_name: Annotated[\n        str,\n        Field(pattern=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\", description=\"Site name\"),\n    ]\n    site_description: Annotated[\n        Optional[str], Field(description=\"Site description\")\n    ] = None\n    site_author: Annotated[Optional[str], Field(description=\"Site authors\")] = None\n    site_url: Annotated[Optional[HttpUrlStr], Field(description=\"Site homepage\")] = None\n    repo_url: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Package repository\")\n    ] = None\n    repo_name: Annotated[Optional[str], Field(description=\"Repository name\")] = None\n</code></pre>"},{"location":"reference/somesy/mkdocs/writer/","title":"writer","text":"<p>Project documentation with Markdown (MkDocs) parser and saver.</p>"},{"location":"reference/somesy/mkdocs/writer/#somesy.mkdocs.writer.MkDocs","title":"MkDocs","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Project documentation with Markdown (MkDocs) parser and saver.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>class MkDocs(ProjectMetadataWriter):\n    \"\"\"Project documentation with Markdown (MkDocs) parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = False,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Project documentation with Markdown (MkDocs) parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._yaml = YAML()\n        self._yaml.preserve_quotes = True\n\n        mappings: FieldKeyMapping = {\n            \"name\": [\"site_name\"],\n            \"description\": [\"site_description\"],\n            \"homepage\": [\"site_url\"],\n            \"repository\": [\"repo_url\"],\n            \"authors\": [\"site_author\"],\n            \"documentation\": IgnoreKey(),\n            \"version\": IgnoreKey(),\n            \"maintainers\": IgnoreKey(),\n            \"license\": IgnoreKey(),\n            \"keywords\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=create_if_not_exists,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self):\n        \"\"\"Load the MkDocs file.\"\"\"\n        with open(self.path) as f:\n            self._data = self._yaml.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the MkDocs file.\"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {MkDocsConfig.__name__}: {pretty_repr(config)}\"\n        )\n        MkDocsConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the MkDocs object to a file.\"\"\"\n        path = path or self.path\n        self._yaml.dump(self._data, path)\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author from the source file as list.\"\"\"\n        authors = self._get_property(self._get_key(\"authors\"))\n        if authors is None or self._to_person(authors) is None:\n            return []\n        else:\n            return [authors]\n\n    @authors.setter\n    def authors(self, authors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    @staticmethod\n    def _from_person(person: Union[Entity, Person]):\n        \"\"\"MkDocs Person is a string with full name.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Entity, Person]]:\n        \"\"\"MkDocs Person is a string with full name.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync the MkDocs object with the ProjectMetadata object.\"\"\"\n        self.name = metadata.name\n        self.description = metadata.description\n        # no author merge since it is a free text field\n        self.authors = metadata.authors()\n        if metadata.homepage:\n            self.homepage = str(metadata.homepage)\n        if metadata.repository:\n            self.repository = str(metadata.repository)\n            self.repo_name = metadata.repository.path\n</code></pre>"},{"location":"reference/somesy/mkdocs/writer/#somesy.mkdocs.writer.MkDocs.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author from the source file as list.</p>"},{"location":"reference/somesy/mkdocs/writer/#somesy.mkdocs.writer.MkDocs.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    create_if_not_exists: bool = False,\n    pass_validation: Optional[bool] = False,\n)\n</code></pre> <p>Project documentation with Markdown (MkDocs) parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = False,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Project documentation with Markdown (MkDocs) parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._yaml = YAML()\n    self._yaml.preserve_quotes = True\n\n    mappings: FieldKeyMapping = {\n        \"name\": [\"site_name\"],\n        \"description\": [\"site_description\"],\n        \"homepage\": [\"site_url\"],\n        \"repository\": [\"repo_url\"],\n        \"authors\": [\"site_author\"],\n        \"documentation\": IgnoreKey(),\n        \"version\": IgnoreKey(),\n        \"maintainers\": IgnoreKey(),\n        \"license\": IgnoreKey(),\n        \"keywords\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=create_if_not_exists,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/mkdocs/writer/#somesy.mkdocs.writer.MkDocs.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the MkDocs object to a file.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the MkDocs object to a file.\"\"\"\n    path = path or self.path\n    self._yaml.dump(self._data, path)\n</code></pre>"},{"location":"reference/somesy/mkdocs/writer/#somesy.mkdocs.writer.MkDocs.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync the MkDocs object with the ProjectMetadata object.</p> Source code in <code>src/somesy/mkdocs/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync the MkDocs object with the ProjectMetadata object.\"\"\"\n    self.name = metadata.name\n    self.description = metadata.description\n    # no author merge since it is a free text field\n    self.authors = metadata.authors()\n    if metadata.homepage:\n        self.homepage = str(metadata.homepage)\n    if metadata.repository:\n        self.repository = str(metadata.repository)\n        self.repo_name = metadata.repository.path\n</code></pre>"},{"location":"reference/somesy/package_json/","title":"package_json","text":"<p>PackageJSON module.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON","title":"PackageJSON","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>package.json parser and saver.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>class PackageJSON(ProjectMetadataWriter):\n    \"\"\"package.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"package.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings: FieldKeyMapping = {\n            \"authors\": [\"author\"],\n            \"documentation\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the package.json file as list.\"\"\"\n        # check if the author has the correct format\n        if isinstance(author := self._get_property(self._get_key(\"authors\")), str):\n            author = PackageJsonConfig.convert_author(author)\n            if author is None:\n                return []\n\n        return [self._get_property(self._get_key(\"authors\"))]\n\n    @authors.setter\n    def authors(self, authors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors_dict = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors_dict)\n\n    @property\n    def maintainers(self):\n        \"\"\"Return the maintainers of the package.json file.\"\"\"\n        # check if the maintainer has the correct format\n        maintainers = self._get_property(self._get_key(\"maintainers\"))\n        # return empty list if maintainers is None\n        if maintainers is None:\n            return []\n\n        maintainers_valid = []\n\n        for maintainer in maintainers:\n            if isinstance(maintainer, str):\n                maintainer = PackageJsonConfig.convert_author(maintainer)\n                if maintainer is None:\n                    continue\n            maintainers_valid.append(maintainer)\n        return maintainers_valid\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        maintainers_dict = [self._from_person(m) for m in maintainers]\n        self._set_property(self._get_key(\"maintainers\"), maintainers_dict)\n\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the package.json file.\"\"\"\n        # check if the contributor has the correct format\n        contributors = self._get_property(self._get_key(\"contributors\"))\n        # return empty list if contributors is None\n        if contributors is None:\n            return []\n\n        contributors_valid = []\n\n        for contributor in contributors:\n            if isinstance(contributor, str):\n                contributor = PackageJsonConfig.convert_author(contributor)\n                if contributor is None:\n                    continue\n            contributors_valid.append(contributor)\n        return contributors_valid\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contributors_dict = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors_dict)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load package.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate package.json content using pydantic class.\"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {PackageJsonConfig.__name__}: {pretty_repr(config)}\"\n        )\n        PackageJsonConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the package.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving package.json to {path}\")\n\n        with path.open(\"w\") as f:\n            # package.json indentation is 2 spaces\n            json.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Entity, Person]) -&gt; dict:\n        \"\"\"Convert project metadata person/entity object to package.json dict for person format.\"\"\"\n        response = {}\n        if isinstance(person, Person):\n            response[\"name\"] = person.full_name\n            if person.orcid:\n                response[\"url\"] = str(person.orcid)\n        else:\n            response[\"name\"] = person.name\n            if person.website:\n                response[\"url\"] = person.website\n\n        if person.email:\n            response[\"email\"] = person.email\n\n        return response\n\n    @staticmethod\n    def _to_person(\n        person: Union[str, Dict[str, Any], PackageAuthor],\n    ) -&gt; Union[Entity, Person]:\n        \"\"\"Convert package.json dict or str for person format to project metadata person object.\"\"\"\n        if isinstance(person, str):\n            # parse from package.json format\n            person = PackageJsonConfig.convert_author(person)\n\n        if isinstance(person, PackageAuthor):\n            person = person.model_dump(exclude_none=True)\n\n        person_dict: dict[str, Any] = person  # type: ignore\n\n        if \"name\" in person_dict and \" \" in person_dict[\"name\"]:\n            names = list(map(lambda s: s.strip(), person_dict[\"name\"].split()))\n            person_obj = {\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n            }\n            if \"email\" in person_dict:\n                person_obj[\"email\"] = person_dict[\"email\"].strip()\n            if \"url\" in person_dict:\n                person_obj[\"orcid\"] = person_dict[\"url\"].strip()\n            return Person(**person_obj)\n        else:\n            entity_obj = {\"name\": person_dict[\"name\"]}\n            if \"email\" in person_dict:\n                entity_obj[\"email\"] = person_dict[\"email\"].strip()\n            if \"url\" in person_dict:\n                entity_obj[\"orcid\"] = person_dict[\"url\"].strip()\n            return Entity(**entity_obj)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync package.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = self._sync_person_list(self.contributors, metadata.people)\n\n    @property\n    def repository(self) -&gt; Optional[Union[str, Dict]]:\n        \"\"\"Return the repository url of the project.\"\"\"\n        if repo := super().repository:\n            if isinstance(repo, str):\n                return repo\n            else:\n                return repo.get(\"url\")\n        else:\n            return None\n\n    @repository.setter\n    def repository(self, value: Optional[Union[str, Dict]]) -&gt; None:\n        \"\"\"Set the repository url of the project.\"\"\"\n        if value is None:\n            self._set_property(self._get_key(\"repository\"), None)\n        else:\n            self._set_property(self._get_key(\"repository\"), dict(type=\"git\", url=value))\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the package.json file as list.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the maintainers of the package.json file.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the package.json file.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.repository","title":"repository  <code>property</code> <code>writable</code>","text":"<pre><code>repository: Optional[Union[str, Dict]]\n</code></pre> <p>Return the repository url of the project.</p>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>package.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"package.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings: FieldKeyMapping = {\n        \"authors\": [\"author\"],\n        \"documentation\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the package.json file.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the package.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving package.json to {path}\")\n\n    with path.open(\"w\") as f:\n        # package.json indentation is 2 spaces\n        json.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/package_json/#somesy.package_json.PackageJSON.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync package.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync package.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = self._sync_person_list(self.contributors, metadata.people)\n</code></pre>"},{"location":"reference/somesy/package_json/models/","title":"models","text":"<p>package.json validation models.</p>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageAuthor","title":"PackageAuthor","text":"<p>               Bases: <code>BaseModel</code></p> <p>Package author model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageAuthor(BaseModel):\n    \"\"\"Package author model.\"\"\"\n\n    name: Annotated[Optional[str], Field(description=\"Author name\")]\n    email: Annotated[Optional[EmailStr], Field(description=\"Author email\")] = None\n    url: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Author website or orcid page\")\n    ] = None\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageRepository","title":"PackageRepository","text":"<p>               Bases: <code>BaseModel</code></p> <p>Package repository model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageRepository(BaseModel):\n    \"\"\"Package repository model.\"\"\"\n\n    type: Annotated[Optional[str], Field(description=\"Repository type\")] = None\n    url: Annotated[str, Field(description=\"Repository url\")]\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageLicense","title":"PackageLicense","text":"<p>               Bases: <code>BaseModel</code></p> <p>Package license model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageLicense(BaseModel):\n    \"\"\"Package license model.\"\"\"\n\n    type: Annotated[Optional[str], Field(description=\"License type\")] = None\n    url: Annotated[str, Field(description=\"License url\")]\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig","title":"PackageJsonConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Package.json config model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>class PackageJsonConfig(BaseModel):\n    \"\"\"Package.json config model.\"\"\"\n\n    model_config = dict(populate_by_name=True)\n\n    name: Annotated[str, Field(description=\"Package name\")]\n    version: Annotated[str, Field(description=\"Package version\")]\n    description: Annotated[Optional[str], Field(description=\"Package description\")] = (\n        None\n    )\n    author: Annotated[\n        Optional[Union[str, PackageAuthor]], Field(description=\"Package author\")\n    ] = None\n    maintainers: Annotated[\n        Optional[List[Union[str, PackageAuthor]]],\n        Field(description=\"Package maintainers\"),\n    ] = None\n    contributors: Annotated[\n        Optional[List[Union[str, PackageAuthor]]],\n        Field(description=\"Package contributors\"),\n    ] = None\n    license: Annotated[\n        Optional[Union[str, PackageLicense]], Field(description=\"Package license\")\n    ] = None\n    repository: Annotated[\n        Optional[Union[PackageRepository, str]], Field(description=\"Package repository\")\n    ] = None\n    homepage: Annotated[Optional[HttpUrlStr], Field(description=\"Package homepage\")] = (\n        None\n    )\n    keywords: Annotated[\n        Optional[List[str]], Field(description=\"Keywords that describe the package\")\n    ] = None\n\n    # convert package author to dict if it is a string\n    @classmethod\n    def convert_author(cls, author: str) -&gt; PackageAuthor:\n        \"\"\"Convert author string to PackageAuthor model.\"\"\"\n        # parse author string to \"name &lt;email&gt; (url)\" format with regex\n        author_match = re.match(NPM_PKG_AUTHOR, author)\n        if not author_match:\n            raise ValueError(f\"Invalid author format: {author}\")\n        author_name = author_match[1]\n        author_email = author_match[2]\n        author_url = author_match[3]\n\n        return PackageAuthor(name=author_name, email=author_email, url=author_url)\n\n    @field_validator(\"name\")\n    @classmethod\n    def validate_name(cls, v):\n        \"\"\"Validate package name.\"\"\"\n        if re.match(NPM_PKG_NAME, v) is None:\n            raise ValueError(\"Invalid name\")\n\n        return v\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate package version.\"\"\"\n        if re.match(NPM_PKG_VERSION, v) is None:\n            raise ValueError(\"Invalid version\")\n        return v\n\n    @field_validator(\"author\")\n    @classmethod\n    def validate_author(cls, v):\n        \"\"\"Validate package author.\"\"\"\n        return cls.convert_author(v) if isinstance(v, str) else v\n\n    @field_validator(\"maintainers\", \"contributors\")\n    @classmethod\n    def validate_people(cls, v):\n        \"\"\"Validate package maintainers and contributors.\"\"\"\n        people = []\n        for p in v:\n            if isinstance(p, str):\n                author = cls.convert_author(p)\n                if author is not None:\n                    people.append(cls.convert_author(p))\n                else:\n                    logger.warning(\n                        f\"Invalid email format for maintainer/contributor {p}, omitting.\"\n                    )\n            elif p.email is not None:\n                people.append(p)\n            else:\n                logger.warning(\n                    f\"Invalid email format for maintainer/contributor {p}, omitting.\"\n                )\n        return people\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.convert_author","title":"convert_author  <code>classmethod</code>","text":"<pre><code>convert_author(author: str) -&gt; PackageAuthor\n</code></pre> <p>Convert author string to PackageAuthor model.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@classmethod\ndef convert_author(cls, author: str) -&gt; PackageAuthor:\n    \"\"\"Convert author string to PackageAuthor model.\"\"\"\n    # parse author string to \"name &lt;email&gt; (url)\" format with regex\n    author_match = re.match(NPM_PKG_AUTHOR, author)\n    if not author_match:\n        raise ValueError(f\"Invalid author format: {author}\")\n    author_name = author_match[1]\n    author_email = author_match[2]\n    author_url = author_match[3]\n\n    return PackageAuthor(name=author_name, email=author_email, url=author_url)\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_name","title":"validate_name  <code>classmethod</code>","text":"<pre><code>validate_name(v)\n</code></pre> <p>Validate package name.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, v):\n    \"\"\"Validate package name.\"\"\"\n    if re.match(NPM_PKG_NAME, v) is None:\n        raise ValueError(\"Invalid name\")\n\n    return v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate package version.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate package version.\"\"\"\n    if re.match(NPM_PKG_VERSION, v) is None:\n        raise ValueError(\"Invalid version\")\n    return v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_author","title":"validate_author  <code>classmethod</code>","text":"<pre><code>validate_author(v)\n</code></pre> <p>Validate package author.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@field_validator(\"author\")\n@classmethod\ndef validate_author(cls, v):\n    \"\"\"Validate package author.\"\"\"\n    return cls.convert_author(v) if isinstance(v, str) else v\n</code></pre>"},{"location":"reference/somesy/package_json/models/#somesy.package_json.models.PackageJsonConfig.validate_people","title":"validate_people  <code>classmethod</code>","text":"<pre><code>validate_people(v)\n</code></pre> <p>Validate package maintainers and contributors.</p> Source code in <code>src/somesy/package_json/models.py</code> <pre><code>@field_validator(\"maintainers\", \"contributors\")\n@classmethod\ndef validate_people(cls, v):\n    \"\"\"Validate package maintainers and contributors.\"\"\"\n    people = []\n    for p in v:\n        if isinstance(p, str):\n            author = cls.convert_author(p)\n            if author is not None:\n                people.append(cls.convert_author(p))\n            else:\n                logger.warning(\n                    f\"Invalid email format for maintainer/contributor {p}, omitting.\"\n                )\n        elif p.email is not None:\n            people.append(p)\n        else:\n            logger.warning(\n                f\"Invalid email format for maintainer/contributor {p}, omitting.\"\n            )\n    return people\n</code></pre>"},{"location":"reference/somesy/package_json/writer/","title":"writer","text":"<p>package.json parser and saver.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON","title":"PackageJSON","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>package.json parser and saver.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>class PackageJSON(ProjectMetadataWriter):\n    \"\"\"package.json parser and saver.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"package.json parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings: FieldKeyMapping = {\n            \"authors\": [\"author\"],\n            \"documentation\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    @property\n    def authors(self):\n        \"\"\"Return the only author of the package.json file as list.\"\"\"\n        # check if the author has the correct format\n        if isinstance(author := self._get_property(self._get_key(\"authors\")), str):\n            author = PackageJsonConfig.convert_author(author)\n            if author is None:\n                return []\n\n        return [self._get_property(self._get_key(\"authors\"))]\n\n    @authors.setter\n    def authors(self, authors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors_dict = self._from_person(authors[0])\n        self._set_property(self._get_key(\"authors\"), authors_dict)\n\n    @property\n    def maintainers(self):\n        \"\"\"Return the maintainers of the package.json file.\"\"\"\n        # check if the maintainer has the correct format\n        maintainers = self._get_property(self._get_key(\"maintainers\"))\n        # return empty list if maintainers is None\n        if maintainers is None:\n            return []\n\n        maintainers_valid = []\n\n        for maintainer in maintainers:\n            if isinstance(maintainer, str):\n                maintainer = PackageJsonConfig.convert_author(maintainer)\n                if maintainer is None:\n                    continue\n            maintainers_valid.append(maintainer)\n        return maintainers_valid\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        maintainers_dict = [self._from_person(m) for m in maintainers]\n        self._set_property(self._get_key(\"maintainers\"), maintainers_dict)\n\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the package.json file.\"\"\"\n        # check if the contributor has the correct format\n        contributors = self._get_property(self._get_key(\"contributors\"))\n        # return empty list if contributors is None\n        if contributors is None:\n            return []\n\n        contributors_valid = []\n\n        for contributor in contributors:\n            if isinstance(contributor, str):\n                contributor = PackageJsonConfig.convert_author(contributor)\n                if contributor is None:\n                    continue\n            contributors_valid.append(contributor)\n        return contributors_valid\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contributors_dict = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contributors_dict)\n\n    def _load(self) -&gt; None:\n        \"\"\"Load package.json file.\"\"\"\n        with self.path.open() as f:\n            self._data = json.load(f, object_pairs_hook=OrderedDict)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate package.json content using pydantic class.\"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {PackageJsonConfig.__name__}: {pretty_repr(config)}\"\n        )\n        PackageJsonConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the package.json file.\"\"\"\n        path = path or self.path\n        logger.debug(f\"Saving package.json to {path}\")\n\n        with path.open(\"w\") as f:\n            # package.json indentation is 2 spaces\n            json.dump(self._data, f)\n\n    @staticmethod\n    def _from_person(person: Union[Entity, Person]) -&gt; dict:\n        \"\"\"Convert project metadata person/entity object to package.json dict for person format.\"\"\"\n        response = {}\n        if isinstance(person, Person):\n            response[\"name\"] = person.full_name\n            if person.orcid:\n                response[\"url\"] = str(person.orcid)\n        else:\n            response[\"name\"] = person.name\n            if person.website:\n                response[\"url\"] = person.website\n\n        if person.email:\n            response[\"email\"] = person.email\n\n        return response\n\n    @staticmethod\n    def _to_person(\n        person: Union[str, Dict[str, Any], PackageAuthor],\n    ) -&gt; Union[Entity, Person]:\n        \"\"\"Convert package.json dict or str for person format to project metadata person object.\"\"\"\n        if isinstance(person, str):\n            # parse from package.json format\n            person = PackageJsonConfig.convert_author(person)\n\n        if isinstance(person, PackageAuthor):\n            person = person.model_dump(exclude_none=True)\n\n        person_dict: dict[str, Any] = person  # type: ignore\n\n        if \"name\" in person_dict and \" \" in person_dict[\"name\"]:\n            names = list(map(lambda s: s.strip(), person_dict[\"name\"].split()))\n            person_obj = {\n                \"given-names\": \" \".join(names[:-1]),\n                \"family-names\": names[-1],\n            }\n            if \"email\" in person_dict:\n                person_obj[\"email\"] = person_dict[\"email\"].strip()\n            if \"url\" in person_dict:\n                person_obj[\"orcid\"] = person_dict[\"url\"].strip()\n            return Person(**person_obj)\n        else:\n            entity_obj = {\"name\": person_dict[\"name\"]}\n            if \"email\" in person_dict:\n                entity_obj[\"email\"] = person_dict[\"email\"].strip()\n            if \"url\" in person_dict:\n                entity_obj[\"orcid\"] = person_dict[\"url\"].strip()\n            return Entity(**entity_obj)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync package.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = self._sync_person_list(self.contributors, metadata.people)\n\n    @property\n    def repository(self) -&gt; Optional[Union[str, Dict]]:\n        \"\"\"Return the repository url of the project.\"\"\"\n        if repo := super().repository:\n            if isinstance(repo, str):\n                return repo\n            else:\n                return repo.get(\"url\")\n        else:\n            return None\n\n    @repository.setter\n    def repository(self, value: Optional[Union[str, Dict]]) -&gt; None:\n        \"\"\"Set the repository url of the project.\"\"\"\n        if value is None:\n            self._set_property(self._get_key(\"repository\"), None)\n        else:\n            self._set_property(self._get_key(\"repository\"), dict(type=\"git\", url=value))\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the only author of the package.json file as list.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the maintainers of the package.json file.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the package.json file.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.repository","title":"repository  <code>property</code> <code>writable</code>","text":"<pre><code>repository: Optional[Union[str, Dict]]\n</code></pre> <p>Return the repository url of the project.</p>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>package.json parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"package.json parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings: FieldKeyMapping = {\n        \"authors\": [\"author\"],\n        \"documentation\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the package.json file.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the package.json file.\"\"\"\n    path = path or self.path\n    logger.debug(f\"Saving package.json to {path}\")\n\n    with path.open(\"w\") as f:\n        # package.json indentation is 2 spaces\n        json.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/package_json/writer/#somesy.package_json.writer.PackageJSON.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync package.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/package_json/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync package.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = self._sync_person_list(self.contributors, metadata.people)\n</code></pre>"},{"location":"reference/somesy/pom_xml/","title":"pom_xml","text":"<p>Somesy implementation for Java Maven pom.xml.</p>"},{"location":"reference/somesy/pom_xml/writer/","title":"writer","text":"<p>Writer adapter for pom.xml files.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM","title":"POM","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Java Maven pom.xml parser and saver.</p> Source code in <code>src/somesy/pom_xml/writer.py</code> <pre><code>class POM(ProjectMetadataWriter):\n    \"\"\"Java Maven pom.xml parser and saver.\"\"\"\n\n    # TODO: write a wrapper for ElementTree that behaves like a dict\n    # TODO: set up correct field name mappings\n\n    def __init__(\n        self,\n        path: Path,\n        create_if_not_exists: bool = True,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Java Maven pom.xml parser.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        mappings: FieldKeyMapping = {\n            # \"year\": [\"inceptionYear\"],  # not supported by somesy + does not really change\n            # \"project_slug\": [\"artifactId\"],  # not supported by somesy for sync\n            \"license\": [\"licenses\", \"license\"],\n            \"homepage\": [\"url\"],\n            \"repository\": [\"scm\"],\n            \"documentation\": [\"distributionManagement\", \"site\"],\n            \"authors\": [\"developers\", \"developer\"],\n            \"contributors\": [\"contributors\", \"contributor\"],\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=create_if_not_exists,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _init_new_file(self):\n        \"\"\"Initialize new pom.xml file.\"\"\"\n        pom = XMLProxy(ET.Element(\"project\", POM_ROOT_ATRS))\n        pom[\"properties\"] = {\"info.versionScheme\": \"semver-spec\"}\n        pom.write(self.path)\n\n    def _load(self):\n        \"\"\"Load the POM file.\"\"\"\n        ET.register_namespace(\"\", POM_URL)  # register POM as default xml namespace\n        self._data = XMLProxy.parse(self.path, default_namespace=POM_URL)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate the POM file.\"\"\"\n        logger.info(\"Cannot validate POM file, skipping validation.\")\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the POM DOM to a file.\"\"\"\n        self._data.write(path or self.path, default_namespace=None)\n\n    def _get_property(\n        self,\n        key: Union[str, List[str]],\n        *,\n        only_first: bool = False,\n        remove: bool = False,\n    ) -&gt; Optional[Any]:\n        \"\"\"Get (a) property by key.\"\"\"\n        elem = super()._get_property(key, only_first=only_first, remove=remove)\n        if elem is not None:\n            if isinstance(elem, list):\n                return [e.to_jsonlike() for e in elem]\n            else:\n                return elem.to_jsonlike()\n        return None\n\n    @staticmethod\n    def _from_person(person: Union[Entity, Person]):\n        \"\"\"Convert person object to dict for POM XML person format.\"\"\"\n        ret: Dict[str, Any] = {}\n        if isinstance(person, Person):\n            person_id = person.to_name_email_string()\n            if person.orcid:\n                person_id = str(person.orcid)\n                ret[\"url\"] = str(person.orcid)\n        else:\n            person_id = person.to_name_email_string()\n            if person.website:\n                person_id = str(person.website)\n                ret[\"url\"] = person.website\n        ret[\"id\"] = person_id\n        ret[\"name\"] = person.full_name\n        if person.email:\n            ret[\"email\"] = person.email\n        if person.contribution_types:\n            ret[\"roles\"] = dict(role=[c.value for c in person.contribution_types])\n        return ret\n\n    @staticmethod\n    def _to_person(person_obj: dict) -&gt; Union[Entity, Person]:\n        \"\"\"Parse POM XML person to a somesy Person.\"\"\"\n        if \" \" in person_obj[\"name\"]:\n            names = person_obj[\"name\"].split()\n            gnames = \" \".join(names[:-1])\n            fname = names[-1]\n            email = person_obj[\"email\"]\n            url = person_obj.get(\"url\")\n            maybe_orcid = url if url.find(\"orcid.org\") &gt;= 0 else None\n            if roles := person_obj.get(\"roles\"):\n                contr = roles[\"role\"]\n            else:\n                contr = None\n\n            return Person(\n                given_names=gnames,\n                family_names=fname,\n                email=email,\n                orcid=maybe_orcid,\n                contribution_types=contr,\n            )\n        else:\n            name = person_obj[\"name\"]\n            email = person_obj.get(\"email\")\n            url = person_obj.get(\"url\")\n            if roles := person_obj.get(\"roles\"):\n                contr = roles[\"role\"]\n            else:\n                contr = None\n\n            return Entity(\n                name=name,\n                email=email,\n                website=url,\n                contribution_types=contr,\n            )\n\n    # no search keywords supported in POM\n    @property\n    def keywords(self) -&gt; Optional[List[str]]:\n        \"\"\"Return the keywords of the project.\"\"\"\n        pass\n\n    @keywords.setter\n    def keywords(self, keywords: List[str]) -&gt; None:\n        \"\"\"Set the keywords of the project.\"\"\"\n        pass\n\n    # authors must be a list\n    @property\n    def authors(self):\n        \"\"\"Return the authors of the project.\"\"\"\n        authors = self._get_property(self._get_key(\"authors\"))\n        return authors if isinstance(authors, list) else [authors]\n\n    @authors.setter\n    def authors(self, authors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the authors of the project.\"\"\"\n        authors = [self._from_person(c) for c in authors]\n        self._set_property(self._get_key(\"authors\"), authors)\n\n    # contributors must be a list\n    @property\n    def contributors(self):\n        \"\"\"Return the contributors of the project.\"\"\"\n        contr = self._get_property(self._get_key(\"contributors\"))\n        if contr is None:\n            return []\n        return contr if isinstance(contr, list) else [contr]\n\n    @contributors.setter\n    def contributors(self, contributors: List[Union[Entity, Person]]) -&gt; None:\n        \"\"\"Set the contributors of the project.\"\"\"\n        contr = [self._from_person(c) for c in contributors]\n        self._set_property(self._get_key(\"contributors\"), contr)\n\n    # no maintainers supported im POM, only developers and contributors\n    @property\n    def maintainers(self):\n        \"\"\"Return the maintainers of the project.\"\"\"\n        return []\n\n    @maintainers.setter\n    def maintainers(self, maintainers: List[Person]) -&gt; None:\n        \"\"\"Set the maintainers of the project.\"\"\"\n        pass\n\n    # only one project license supported in somesy (POM can have many)\n    @property\n    def license(self) -&gt; Optional[str]:\n        \"\"\"Return the license of the project.\"\"\"\n        lic = self._get_property(self._get_key(\"license\"), only_first=True)\n        return lic.get(\"name\") if lic is not None else None\n\n    @license.setter\n    def license(self, license: Optional[str]) -&gt; None:\n        \"\"\"Set the license of the project.\"\"\"\n        self._set_property(\n            self._get_key(\"license\"), dict(name=license, distribution=\"repo\")\n        )\n\n    @property\n    def repository(self) -&gt; Optional[Union[str, dict]]:\n        \"\"\"Return the repository url of the project.\"\"\"\n        repo = super().repository\n        if isinstance(repo, str):\n            return repo\n        return repo.get(\"url\") if repo is not None else None\n\n    @repository.setter\n    def repository(self, value: Optional[Union[str, dict]]) -&gt; None:\n        \"\"\"Set the repository url of the project.\"\"\"\n        self._set_property(\n            self._get_key(\"repository\"), dict(name=\"git repository\", url=value)\n        )\n\n    @property\n    def documentation(self) -&gt; Optional[Union[str, dict]]:\n        \"\"\"Return the documentation url of the project.\"\"\"\n        docs = super().documentation\n        if isinstance(docs, str):\n            return docs\n        return docs.get(\"url\") if docs is not None else None\n\n    @documentation.setter\n    def documentation(self, value: Optional[Union[str, dict]]) -&gt; None:\n        \"\"\"Set the documentation url of the project.\"\"\"\n        self._set_property(\n            self._get_key(\"documentation\"), dict(name=\"documentation site\", url=value)\n        )\n\n    def sync(self, metadata) -&gt; None:\n        \"\"\"Sync codemeta.json with project metadata.\n\n        Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n        \"\"\"\n        super().sync(metadata)\n        self.contributors = self._sync_person_list(self.contributors, metadata.people)\n</code></pre>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.keywords","title":"keywords  <code>property</code> <code>writable</code>","text":"<pre><code>keywords: Optional[List[str]]\n</code></pre> <p>Return the keywords of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.authors","title":"authors  <code>property</code> <code>writable</code>","text":"<pre><code>authors\n</code></pre> <p>Return the authors of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.contributors","title":"contributors  <code>property</code> <code>writable</code>","text":"<pre><code>contributors\n</code></pre> <p>Return the contributors of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.maintainers","title":"maintainers  <code>property</code> <code>writable</code>","text":"<pre><code>maintainers\n</code></pre> <p>Return the maintainers of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.license","title":"license  <code>property</code> <code>writable</code>","text":"<pre><code>license: Optional[str]\n</code></pre> <p>Return the license of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.repository","title":"repository  <code>property</code> <code>writable</code>","text":"<pre><code>repository: Optional[Union[str, dict]]\n</code></pre> <p>Return the repository url of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.documentation","title":"documentation  <code>property</code> <code>writable</code>","text":"<pre><code>documentation: Optional[Union[str, dict]]\n</code></pre> <p>Return the documentation url of the project.</p>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: Optional[bool] = False,\n)\n</code></pre> <p>Java Maven pom.xml parser.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pom_xml/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    create_if_not_exists: bool = True,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Java Maven pom.xml parser.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    mappings: FieldKeyMapping = {\n        # \"year\": [\"inceptionYear\"],  # not supported by somesy + does not really change\n        # \"project_slug\": [\"artifactId\"],  # not supported by somesy for sync\n        \"license\": [\"licenses\", \"license\"],\n        \"homepage\": [\"url\"],\n        \"repository\": [\"scm\"],\n        \"documentation\": [\"distributionManagement\", \"site\"],\n        \"authors\": [\"developers\", \"developer\"],\n        \"contributors\": [\"contributors\", \"contributor\"],\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=create_if_not_exists,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the POM DOM to a file.</p> Source code in <code>src/somesy/pom_xml/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the POM DOM to a file.\"\"\"\n    self._data.write(path or self.path, default_namespace=None)\n</code></pre>"},{"location":"reference/somesy/pom_xml/writer/#somesy.pom_xml.writer.POM.sync","title":"sync","text":"<pre><code>sync(metadata) -&gt; None\n</code></pre> <p>Sync codemeta.json with project metadata.</p> <p>Use existing sync function from ProjectMetadataWriter but update repository and contributors.</p> Source code in <code>src/somesy/pom_xml/writer.py</code> <pre><code>def sync(self, metadata) -&gt; None:\n    \"\"\"Sync codemeta.json with project metadata.\n\n    Use existing sync function from ProjectMetadataWriter but update repository and contributors.\n    \"\"\"\n    super().sync(metadata)\n    self.contributors = self._sync_person_list(self.contributors, metadata.people)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/","title":"xmlproxy","text":"<p>Wrapper to provide dict-like access to XML via ElementTree.</p>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy","title":"XMLProxy","text":"<p>Class providing dict-like access to edit XML via ElementTree.</p> <p>Note that this wrapper facade is limited to a restricted (but useful) subset of XML: * XML attributes are not supported * DTDs are ignored (arbitrary keys can be queried and added) * each tag is assumed to EITHER contain text OR more nested tags * lists are treated atomically (no way to add/remove element from a collection)</p> <p>The semantics is implemented as follows:</p> <ul> <li>If there are multiple tags with the same name, a list of XMLProxy nodes is returned</li> <li>If a unique tag does have no nested tags, its <code>text</code> string value is returned</li> <li>Otherwise, the node is returned</li> </ul> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>class XMLProxy:\n    \"\"\"Class providing dict-like access to edit XML via ElementTree.\n\n    Note that this wrapper facade is limited to a restricted (but useful) subset of XML:\n    * XML attributes are not supported\n    * DTDs are ignored (arbitrary keys can be queried and added)\n    * each tag is assumed to EITHER contain text OR more nested tags\n    * lists are treated atomically (no way to add/remove element from a collection)\n\n    The semantics is implemented as follows:\n\n    * If there are multiple tags with the same name, a list of XMLProxy nodes is returned\n    * If a unique tag does have no nested tags, its `text` string value is returned\n    * Otherwise, the node is returned\n    \"\"\"\n\n    def _wrap(self, el: ET.Element) -&gt; XMLProxy:\n        \"\"\"Wrap a different element, inheriting the same namespace.\"\"\"\n        return XMLProxy(el, default_namespace=self._def_ns)\n\n    def _dump(self):\n        \"\"\"Dump XML to stdout (for debugging).\"\"\"\n        ET.dump(self._node)\n\n    def _qualified_key(self, key: str):\n        \"\"\"If passed key is not qualified, prepends the default namespace (if set).\"\"\"\n        if key[0] == \"{\" or not self._def_ns:\n            return key\n        return \"{\" + self._def_ns + \"}\" + key\n\n    def _shortened_key(self, key: str):\n        \"\"\"Inverse of `_qualified_key` (strips default namespace from element name).\"\"\"\n        if key[0] != \"{\" or not self._def_ns or key.find(self._def_ns) &lt; 0:\n            return key\n        return key[key.find(\"}\") + 1 :]\n\n    # ----\n\n    def __init__(self, el: ET.Element, *, default_namespace: Optional[str] = None):\n        \"\"\"Wrap an existing XML ElementTree Element.\"\"\"\n        self._node: ET.Element = el\n        self._def_ns = default_namespace\n\n    @classmethod\n    def parse(cls, path: Union[str, Path], **kwargs) -&gt; XMLProxy:\n        \"\"\"Parse an XML file into a wrapped ElementTree, preserving comments.\"\"\"\n        path = path if isinstance(path, Path) else Path(path)\n        return cls(load_xml(path).getroot(), **kwargs)\n\n    def write(self, path: Union[str, Path], *, header: bool = True, **kwargs):\n        \"\"\"Write the XML DOM to an UTF-8 encoded file.\"\"\"\n        path = path if isinstance(path, Path) else Path(path)\n        et = ET.ElementTree(self._node)\n        if self._def_ns and \"default_namespace\" not in kwargs:\n            kwargs[\"default_namespace\"] = self._def_ns\n        indent(et.getroot())\n        et.write(path, encoding=\"UTF-8\", xml_declaration=header, **kwargs)\n\n    def __repr__(self):\n        \"\"\"See `object.__repr__`.\"\"\"\n        return str(self._node)\n\n    def __len__(self):\n        \"\"\"Return number of inner tags inside current XML element.\n\n        Note that bool(node) thus checks whether an XML node is a leaf in the element tree.\n        \"\"\"\n        return len(self._node)\n\n    def __iter__(self):\n        \"\"\"Iterate the nested elements in-order.\"\"\"\n        return map(self._wrap, iter(self._node))\n\n    @property\n    def namespace(self) -&gt; Optional[str]:\n        \"\"\"Default namespace of this node.\"\"\"\n        return self._def_ns\n\n    @property\n    def is_comment(self):\n        \"\"\"Return whether the current element node is an XML comment.\"\"\"\n        return not isinstance(self._node.tag, str)\n\n    @property\n    def tag(self) -&gt; Optional[str]:\n        \"\"\"Return tag name of this element (unless it is a comment).\"\"\"\n        if self.is_comment:\n            return None\n        return self._shortened_key(self._node.tag)\n\n    @tag.setter\n    def tag(self, val: str):\n        \"\"\"Set the tag of this element.\"\"\"\n        if self.is_comment:\n            raise ValueError(\"Cannot set tag name for comment element!\")\n        self._node.tag = self._qualified_key(val)\n\n    # ---- helpers ----\n\n    def to_jsonlike(\n        self,\n        *,\n        strip_default_ns: bool = True,\n        keep_root: bool = False,\n    ) -&gt; JSONLike:\n        \"\"\"Convert XML node to a JSON-like primitive, array or dict (ignoring attributes).\n\n        Note that all leaf values are strings (i.e. not parsed to bool/int/float etc.).\n\n        Args:\n            strip_default_ns: Do not qualify keys from the default namespace\n            keep_root: If true, the root tag name will be preserved (`{\"root_tag\": {...}}`)\n\n        \"\"\"\n        if not len(self):  # leaf -&gt; assume it's a primitive value\n            return self._node.text or \"\"\n\n        dct = {}\n        ccnt = 0\n        for elem in iter(self):\n            raw = elem._node\n            if not isinstance(raw.tag, str):\n                ccnt += 1\n                key = f\"__comment_{ccnt}__\"\n            else:\n                key = raw.tag if not strip_default_ns else self._shortened_key(raw.tag)\n\n            curr_val = elem.to_jsonlike(strip_default_ns=strip_default_ns)\n            if key not in dct:\n                dct[key] = curr_val\n                continue\n            val = dct[key]\n            if not isinstance(val, list):\n                dct[key] = [dct[key]]\n            dct[key].append(curr_val)\n\n        return dct if not keep_root else {self._shortened_key(self._node.tag): dct}\n\n    @classmethod\n    def _from_jsonlike_primitive(\n        cls, val, *, elem_name: Optional[str] = None, **kwargs\n    ) -&gt; Union[str, XMLProxy]:\n        \"\"\"Convert a leaf node into a string value (i.e. return inner text).\n\n        Returns a string (or an XML element, if elem_name is passed).\n        \"\"\"\n        if val is None:\n            ret = \"\"  # turn None into empty string\n        elif isinstance(val, str):\n            ret = val\n        elif isinstance(val, bool):\n            ret = str(val).lower()  # True -&gt; true / False -&gt; false\n        elif isinstance(val, (int, float)):\n            ret = str(val)\n        else:\n            raise TypeError(\n                f\"Value of type {type(val)} is not JSON-like primitive: {val}\"\n            )\n\n        if not elem_name:\n            return ret\n        else:  # return the value wrapped as an element (needed in from_jsonlike)\n            elem = ET.Element(elem_name)\n            elem.text = ret\n            return cls(elem, **kwargs)\n\n    @classmethod\n    def from_jsonlike(\n        cls, val: JSONLike, *, root_name: Optional[str] = None, **kwargs: Any\n    ):\n        \"\"\"Convert a JSON-like primitive, array or dict into an XML element.\n\n        Note that booleans are serialized as `true`/`false` and None as `null`.\n\n        Args:\n            val: Value to convert into an XML element.\n            root_name: If `val` is a dict, defines the tag name for the root element.\n            kwargs: Additional arguments for XML element instantiation.\n\n        \"\"\"\n        if isinstance(val, list):\n            return list(\n                map(lambda x: cls.from_jsonlike(x, root_name=root_name, **kwargs), val)\n            )\n        if not isinstance(val, dict):  # primitive val\n            return cls._from_jsonlike_primitive(val, elem_name=root_name, **kwargs)\n\n        # now the dict case remains\n        elem = ET.Element(root_name or \"root\")\n        for k, v in val.items():\n            if k.startswith(\n                \"__comment_\"\n            ):  # special key names are mapped to XML comments\n                elem.append(ET.Comment(v if isinstance(v, str) else str(v)))\n\n            elif isinstance(v, list):\n                for vv in XMLProxy.from_jsonlike(v, root_name=k, **kwargs):\n                    elem.append(vv._node)\n            elif not isinstance(v, dict):  # primitive val\n                # FIXME: use better case-splitting for type of function to avoid cast\n                tmp = cast(\n                    XMLProxy,\n                    XMLProxy._from_jsonlike_primitive(v, elem_name=k, **kwargs),\n                )\n                elem.append(tmp._node)\n            else:  # dict\n                elem.append(XMLProxy.from_jsonlike(v, root_name=k)._node)\n\n        return cls(elem, **kwargs)\n\n    # ---- dict-like access ----\n\n    def get(self, key: str, *, as_nodes: bool = False, deep: bool = False):\n        \"\"\"Get sub-structure(s) of value(s) matching desired XML tag name.\n\n        * If there are multiple matching elements, will return them all as a list.\n        * If there is a single matching element, will return that element without a list.\n\n        Args:\n            key: tag name to retrieve\n            as_nodes: If true, will *always* return a list of (zero or more) XML nodes\n            deep: Expand nested XML elements instead of returning them as XML nodes\n\n        \"\"\"\n        # NOTE: could allow to retrieve comments when using empty string/none as key?\n\n        if as_nodes and deep:\n            raise ValueError(\"as_nodes and deep are mutually exclusive!\")\n        if not key:\n            raise ValueError(\"Key must not be an empty string!\")\n        key = self._qualified_key(key)\n\n        # if not fully qualified + default NS is given, use it for query\n        lst = self._node.findall(key)\n        ns: List[XMLProxy] = list(map(self._wrap, lst))\n        if as_nodes:  # return it as a list of xml nodes\n            return ns\n        if not ns:  # no element\n            return None\n\n        ret = ns if not deep else [x.to_jsonlike() for x in ns]\n        if len(ret) == 1:\n            return ret[0]  # single element\n        else:\n            return ret\n\n    def __getitem__(self, key: str):\n        \"\"\"Acts like `dict.__getitem__`, implemented with `get`.\"\"\"\n        val = self.get(key)\n        if val is not None:\n            return val\n        else:\n            raise KeyError(key)\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Acts like `dict.__contains__`, implemented with `get`.\"\"\"\n        return self.get(key) is not None\n\n    def __delitem__(self, key: Union[str, XMLProxy]):\n        \"\"\"Delete a nested XML element with matching key name.\n\n        Note that **all** XML elements with the given tag name are removed!\n\n        To prevent this behavior, instead of a string tag name you can provide the\n        exact element to be removed, i.e. if a node `node_a` represents the following XML:\n\n        ```\n        &lt;a&gt;\n          &lt;b&gt;1&lt;/b&gt;\n          &lt;c&gt;2&lt;/c&gt;\n          &lt;b&gt;3&lt;/b&gt;\n        &lt;/a&gt;\n        ```\n\n        Then we have that:\n\n        * `del node_a[\"b\"]` removes **both** tags, leaving just the `c` tag.\n        * `del node_a[node_a[\"a\"][1]]` removes just the second tag with the `3`.\n        \"\"\"\n        if isinstance(key, str):\n            nodes = self.get(key, as_nodes=True)\n        else:\n            nodes = [key] if key._node in self._node else []\n\n        if not nodes:\n            raise KeyError(key)\n\n        if self._node.text is not None:\n            self._node.text = \"\"\n        for child in nodes:\n            self._node.remove(child._node)\n\n    def _clear(self):\n        \"\"\"Remove contents of this XML element (e.g. for overwriting in-place).\"\"\"\n        self._node.text = \"\"\n        children = list(iter(self._node))  # need to store, removal invalidates iterator\n        for child in children:\n            self._node.remove(child)\n\n    def __setitem__(self, key: Union[str, XMLProxy], val: Union[JSONLike, XMLProxy]):\n        \"\"\"Add or overwrite an inner XML tag.\n\n        If there is exactly one matching tag, the value is substituted in-place.\n        If the passed value is a list, all list entries are added in their own element.\n\n        If there are multiple existing matches or target values, then\n        **all** existing elements are removed and the new value(s) are added in\n        new element(s) (i.e. coming after other unrelated existing elements)!\n\n        To prevent this behavior, instead of a string tag name you can provide the\n        exact element to be overwritten, i.e. if a node `node_a` represents the following XML:\n\n        ```\n        &lt;a&gt;\n          &lt;b&gt;1&lt;/b&gt;\n          &lt;c&gt;2&lt;/c&gt;\n          &lt;b&gt;3&lt;/b&gt;\n        &lt;/a&gt;\n        ```\n\n        Then we have that:\n\n        * `node_a[\"b\"] = 5` removes both existing tags and creates a new tag with the passed value(s).\n        * `node_a[node_a[\"b\"][1]] = 5` replaces the `3` in the second tag with the `5`.\n\n        Note that the passed value must be either an XML element already, or be a pure JSON-like object.\n        \"\"\"\n        if isinstance(key, str):\n            nodes = self.get(key, as_nodes=True)\n            # delete all existing elements if multiple exist or are passed\n            if len(nodes) &gt; 1 or (len(nodes) and isinstance(val, list)):\n                del self[key]\n                nodes = []\n            # now we can assume there's zero or one suitable target elements\n            if nodes:  # if it is one, clear it out\n                nodes[0]._clear()\n        else:  # an XMLProxy object was passed as key -&gt; try to use that\n            if isinstance(val, list):\n                raise ValueError(\n                    \"Cannot overwrite a single element with a list of values!\"\n                )\n            # ensure the target node is cleared out and use it as target\n            key._clear()\n            nodes = [key]\n            key = key.tag\n\n        # ensure key string is qualified with a namespace\n        key_name: str = self._qualified_key(key)\n\n        # normalize passed value(s) to be list (general case)\n        vals = val if isinstance(val, list) else [val]\n\n        # ensure there is the required number of target element nodes\n        for _ in range(len(vals) - len(nodes)):\n            nodes.append(self._wrap(ET.SubElement(self._node, key_name)))\n\n        # normalize values no XML element nodes\n        nvals = []\n        for val in vals:\n            # ensure value is represented as an XML node\n            if isinstance(val, XMLProxy):\n                obj = self._wrap(ET.Element(\"dummy\"))\n                obj._node.append(val._node)\n            else:\n                obj = self.from_jsonlike(val, root_name=key_name)\n\n            nvals.append(obj)\n\n        for node, val in zip(nodes, nvals):\n            # transplant node contents into existing element (so it is inserted in-place)\n            node._node.text = val._node.text\n            for child in iter(val):\n                node._node.append(child._node)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.namespace","title":"namespace  <code>property</code>","text":"<pre><code>namespace: Optional[str]\n</code></pre> <p>Default namespace of this node.</p>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.is_comment","title":"is_comment  <code>property</code>","text":"<pre><code>is_comment\n</code></pre> <p>Return whether the current element node is an XML comment.</p>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.tag","title":"tag  <code>property</code> <code>writable</code>","text":"<pre><code>tag: Optional[str]\n</code></pre> <p>Return tag name of this element (unless it is a comment).</p>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__init__","title":"__init__","text":"<pre><code>__init__(\n    el: ET.Element,\n    *,\n    default_namespace: Optional[str] = None\n)\n</code></pre> <p>Wrap an existing XML ElementTree Element.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __init__(self, el: ET.Element, *, default_namespace: Optional[str] = None):\n    \"\"\"Wrap an existing XML ElementTree Element.\"\"\"\n    self._node: ET.Element = el\n    self._def_ns = default_namespace\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(path: Union[str, Path], **kwargs) -&gt; XMLProxy\n</code></pre> <p>Parse an XML file into a wrapped ElementTree, preserving comments.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>@classmethod\ndef parse(cls, path: Union[str, Path], **kwargs) -&gt; XMLProxy:\n    \"\"\"Parse an XML file into a wrapped ElementTree, preserving comments.\"\"\"\n    path = path if isinstance(path, Path) else Path(path)\n    return cls(load_xml(path).getroot(), **kwargs)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.write","title":"write","text":"<pre><code>write(\n    path: Union[str, Path], *, header: bool = True, **kwargs\n)\n</code></pre> <p>Write the XML DOM to an UTF-8 encoded file.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def write(self, path: Union[str, Path], *, header: bool = True, **kwargs):\n    \"\"\"Write the XML DOM to an UTF-8 encoded file.\"\"\"\n    path = path if isinstance(path, Path) else Path(path)\n    et = ET.ElementTree(self._node)\n    if self._def_ns and \"default_namespace\" not in kwargs:\n        kwargs[\"default_namespace\"] = self._def_ns\n    indent(et.getroot())\n    et.write(path, encoding=\"UTF-8\", xml_declaration=header, **kwargs)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>See <code>object.__repr__</code>.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __repr__(self):\n    \"\"\"See `object.__repr__`.\"\"\"\n    return str(self._node)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__len__","title":"__len__","text":"<pre><code>__len__()\n</code></pre> <p>Return number of inner tags inside current XML element.</p> <p>Note that bool(node) thus checks whether an XML node is a leaf in the element tree.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __len__(self):\n    \"\"\"Return number of inner tags inside current XML element.\n\n    Note that bool(node) thus checks whether an XML node is a leaf in the element tree.\n    \"\"\"\n    return len(self._node)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate the nested elements in-order.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterate the nested elements in-order.\"\"\"\n    return map(self._wrap, iter(self._node))\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.to_jsonlike","title":"to_jsonlike","text":"<pre><code>to_jsonlike(\n    *,\n    strip_default_ns: bool = True,\n    keep_root: bool = False\n) -&gt; JSONLike\n</code></pre> <p>Convert XML node to a JSON-like primitive, array or dict (ignoring attributes).</p> <p>Note that all leaf values are strings (i.e. not parsed to bool/int/float etc.).</p> <p>Parameters:</p> Name Type Description Default <code>strip_default_ns</code> <code>bool</code> <p>Do not qualify keys from the default namespace</p> <code>True</code> <code>keep_root</code> <code>bool</code> <p>If true, the root tag name will be preserved (<code>{\"root_tag\": {...}}</code>)</p> <code>False</code> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def to_jsonlike(\n    self,\n    *,\n    strip_default_ns: bool = True,\n    keep_root: bool = False,\n) -&gt; JSONLike:\n    \"\"\"Convert XML node to a JSON-like primitive, array or dict (ignoring attributes).\n\n    Note that all leaf values are strings (i.e. not parsed to bool/int/float etc.).\n\n    Args:\n        strip_default_ns: Do not qualify keys from the default namespace\n        keep_root: If true, the root tag name will be preserved (`{\"root_tag\": {...}}`)\n\n    \"\"\"\n    if not len(self):  # leaf -&gt; assume it's a primitive value\n        return self._node.text or \"\"\n\n    dct = {}\n    ccnt = 0\n    for elem in iter(self):\n        raw = elem._node\n        if not isinstance(raw.tag, str):\n            ccnt += 1\n            key = f\"__comment_{ccnt}__\"\n        else:\n            key = raw.tag if not strip_default_ns else self._shortened_key(raw.tag)\n\n        curr_val = elem.to_jsonlike(strip_default_ns=strip_default_ns)\n        if key not in dct:\n            dct[key] = curr_val\n            continue\n        val = dct[key]\n        if not isinstance(val, list):\n            dct[key] = [dct[key]]\n        dct[key].append(curr_val)\n\n    return dct if not keep_root else {self._shortened_key(self._node.tag): dct}\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.from_jsonlike","title":"from_jsonlike  <code>classmethod</code>","text":"<pre><code>from_jsonlike(\n    val: JSONLike,\n    *,\n    root_name: Optional[str] = None,\n    **kwargs: Any\n)\n</code></pre> <p>Convert a JSON-like primitive, array or dict into an XML element.</p> <p>Note that booleans are serialized as <code>true</code>/<code>false</code> and None as <code>null</code>.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>JSONLike</code> <p>Value to convert into an XML element.</p> required <code>root_name</code> <code>Optional[str]</code> <p>If <code>val</code> is a dict, defines the tag name for the root element.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional arguments for XML element instantiation.</p> <code>{}</code> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>@classmethod\ndef from_jsonlike(\n    cls, val: JSONLike, *, root_name: Optional[str] = None, **kwargs: Any\n):\n    \"\"\"Convert a JSON-like primitive, array or dict into an XML element.\n\n    Note that booleans are serialized as `true`/`false` and None as `null`.\n\n    Args:\n        val: Value to convert into an XML element.\n        root_name: If `val` is a dict, defines the tag name for the root element.\n        kwargs: Additional arguments for XML element instantiation.\n\n    \"\"\"\n    if isinstance(val, list):\n        return list(\n            map(lambda x: cls.from_jsonlike(x, root_name=root_name, **kwargs), val)\n        )\n    if not isinstance(val, dict):  # primitive val\n        return cls._from_jsonlike_primitive(val, elem_name=root_name, **kwargs)\n\n    # now the dict case remains\n    elem = ET.Element(root_name or \"root\")\n    for k, v in val.items():\n        if k.startswith(\n            \"__comment_\"\n        ):  # special key names are mapped to XML comments\n            elem.append(ET.Comment(v if isinstance(v, str) else str(v)))\n\n        elif isinstance(v, list):\n            for vv in XMLProxy.from_jsonlike(v, root_name=k, **kwargs):\n                elem.append(vv._node)\n        elif not isinstance(v, dict):  # primitive val\n            # FIXME: use better case-splitting for type of function to avoid cast\n            tmp = cast(\n                XMLProxy,\n                XMLProxy._from_jsonlike_primitive(v, elem_name=k, **kwargs),\n            )\n            elem.append(tmp._node)\n        else:  # dict\n            elem.append(XMLProxy.from_jsonlike(v, root_name=k)._node)\n\n    return cls(elem, **kwargs)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.get","title":"get","text":"<pre><code>get(\n    key: str, *, as_nodes: bool = False, deep: bool = False\n)\n</code></pre> <p>Get sub-structure(s) of value(s) matching desired XML tag name.</p> <ul> <li>If there are multiple matching elements, will return them all as a list.</li> <li>If there is a single matching element, will return that element without a list.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>tag name to retrieve</p> required <code>as_nodes</code> <code>bool</code> <p>If true, will always return a list of (zero or more) XML nodes</p> <code>False</code> <code>deep</code> <code>bool</code> <p>Expand nested XML elements instead of returning them as XML nodes</p> <code>False</code> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def get(self, key: str, *, as_nodes: bool = False, deep: bool = False):\n    \"\"\"Get sub-structure(s) of value(s) matching desired XML tag name.\n\n    * If there are multiple matching elements, will return them all as a list.\n    * If there is a single matching element, will return that element without a list.\n\n    Args:\n        key: tag name to retrieve\n        as_nodes: If true, will *always* return a list of (zero or more) XML nodes\n        deep: Expand nested XML elements instead of returning them as XML nodes\n\n    \"\"\"\n    # NOTE: could allow to retrieve comments when using empty string/none as key?\n\n    if as_nodes and deep:\n        raise ValueError(\"as_nodes and deep are mutually exclusive!\")\n    if not key:\n        raise ValueError(\"Key must not be an empty string!\")\n    key = self._qualified_key(key)\n\n    # if not fully qualified + default NS is given, use it for query\n    lst = self._node.findall(key)\n    ns: List[XMLProxy] = list(map(self._wrap, lst))\n    if as_nodes:  # return it as a list of xml nodes\n        return ns\n    if not ns:  # no element\n        return None\n\n    ret = ns if not deep else [x.to_jsonlike() for x in ns]\n    if len(ret) == 1:\n        return ret[0]  # single element\n    else:\n        return ret\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str)\n</code></pre> <p>Acts like <code>dict.__getitem__</code>, implemented with <code>get</code>.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __getitem__(self, key: str):\n    \"\"\"Acts like `dict.__getitem__`, implemented with `get`.\"\"\"\n    val = self.get(key)\n    if val is not None:\n        return val\n    else:\n        raise KeyError(key)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__contains__","title":"__contains__","text":"<pre><code>__contains__(key: str) -&gt; bool\n</code></pre> <p>Acts like <code>dict.__contains__</code>, implemented with <code>get</code>.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Acts like `dict.__contains__`, implemented with `get`.\"\"\"\n    return self.get(key) is not None\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: Union[str, XMLProxy])\n</code></pre> <p>Delete a nested XML element with matching key name.</p> <p>Note that all XML elements with the given tag name are removed!</p> <p>To prevent this behavior, instead of a string tag name you can provide the exact element to be removed, i.e. if a node <code>node_a</code> represents the following XML:</p> <pre><code>&lt;a&gt;\n  &lt;b&gt;1&lt;/b&gt;\n  &lt;c&gt;2&lt;/c&gt;\n  &lt;b&gt;3&lt;/b&gt;\n&lt;/a&gt;\n</code></pre> <p>Then we have that:</p> <ul> <li><code>del node_a[\"b\"]</code> removes both tags, leaving just the <code>c</code> tag.</li> <li><code>del node_a[node_a[\"a\"][1]]</code> removes just the second tag with the <code>3</code>.</li> </ul> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __delitem__(self, key: Union[str, XMLProxy]):\n    \"\"\"Delete a nested XML element with matching key name.\n\n    Note that **all** XML elements with the given tag name are removed!\n\n    To prevent this behavior, instead of a string tag name you can provide the\n    exact element to be removed, i.e. if a node `node_a` represents the following XML:\n\n    ```\n    &lt;a&gt;\n      &lt;b&gt;1&lt;/b&gt;\n      &lt;c&gt;2&lt;/c&gt;\n      &lt;b&gt;3&lt;/b&gt;\n    &lt;/a&gt;\n    ```\n\n    Then we have that:\n\n    * `del node_a[\"b\"]` removes **both** tags, leaving just the `c` tag.\n    * `del node_a[node_a[\"a\"][1]]` removes just the second tag with the `3`.\n    \"\"\"\n    if isinstance(key, str):\n        nodes = self.get(key, as_nodes=True)\n    else:\n        nodes = [key] if key._node in self._node else []\n\n    if not nodes:\n        raise KeyError(key)\n\n    if self._node.text is not None:\n        self._node.text = \"\"\n    for child in nodes:\n        self._node.remove(child._node)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.XMLProxy.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: Union[str, XMLProxy],\n    val: Union[JSONLike, XMLProxy],\n)\n</code></pre> <p>Add or overwrite an inner XML tag.</p> <p>If there is exactly one matching tag, the value is substituted in-place. If the passed value is a list, all list entries are added in their own element.</p> <p>If there are multiple existing matches or target values, then all existing elements are removed and the new value(s) are added in new element(s) (i.e. coming after other unrelated existing elements)!</p> <p>To prevent this behavior, instead of a string tag name you can provide the exact element to be overwritten, i.e. if a node <code>node_a</code> represents the following XML:</p> <pre><code>&lt;a&gt;\n  &lt;b&gt;1&lt;/b&gt;\n  &lt;c&gt;2&lt;/c&gt;\n  &lt;b&gt;3&lt;/b&gt;\n&lt;/a&gt;\n</code></pre> <p>Then we have that:</p> <ul> <li><code>node_a[\"b\"] = 5</code> removes both existing tags and creates a new tag with the passed value(s).</li> <li><code>node_a[node_a[\"b\"][1]] = 5</code> replaces the <code>3</code> in the second tag with the <code>5</code>.</li> </ul> <p>Note that the passed value must be either an XML element already, or be a pure JSON-like object.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def __setitem__(self, key: Union[str, XMLProxy], val: Union[JSONLike, XMLProxy]):\n    \"\"\"Add or overwrite an inner XML tag.\n\n    If there is exactly one matching tag, the value is substituted in-place.\n    If the passed value is a list, all list entries are added in their own element.\n\n    If there are multiple existing matches or target values, then\n    **all** existing elements are removed and the new value(s) are added in\n    new element(s) (i.e. coming after other unrelated existing elements)!\n\n    To prevent this behavior, instead of a string tag name you can provide the\n    exact element to be overwritten, i.e. if a node `node_a` represents the following XML:\n\n    ```\n    &lt;a&gt;\n      &lt;b&gt;1&lt;/b&gt;\n      &lt;c&gt;2&lt;/c&gt;\n      &lt;b&gt;3&lt;/b&gt;\n    &lt;/a&gt;\n    ```\n\n    Then we have that:\n\n    * `node_a[\"b\"] = 5` removes both existing tags and creates a new tag with the passed value(s).\n    * `node_a[node_a[\"b\"][1]] = 5` replaces the `3` in the second tag with the `5`.\n\n    Note that the passed value must be either an XML element already, or be a pure JSON-like object.\n    \"\"\"\n    if isinstance(key, str):\n        nodes = self.get(key, as_nodes=True)\n        # delete all existing elements if multiple exist or are passed\n        if len(nodes) &gt; 1 or (len(nodes) and isinstance(val, list)):\n            del self[key]\n            nodes = []\n        # now we can assume there's zero or one suitable target elements\n        if nodes:  # if it is one, clear it out\n            nodes[0]._clear()\n    else:  # an XMLProxy object was passed as key -&gt; try to use that\n        if isinstance(val, list):\n            raise ValueError(\n                \"Cannot overwrite a single element with a list of values!\"\n            )\n        # ensure the target node is cleared out and use it as target\n        key._clear()\n        nodes = [key]\n        key = key.tag\n\n    # ensure key string is qualified with a namespace\n    key_name: str = self._qualified_key(key)\n\n    # normalize passed value(s) to be list (general case)\n    vals = val if isinstance(val, list) else [val]\n\n    # ensure there is the required number of target element nodes\n    for _ in range(len(vals) - len(nodes)):\n        nodes.append(self._wrap(ET.SubElement(self._node, key_name)))\n\n    # normalize values no XML element nodes\n    nvals = []\n    for val in vals:\n        # ensure value is represented as an XML node\n        if isinstance(val, XMLProxy):\n            obj = self._wrap(ET.Element(\"dummy\"))\n            obj._node.append(val._node)\n        else:\n            obj = self.from_jsonlike(val, root_name=key_name)\n\n        nvals.append(obj)\n\n    for node, val in zip(nodes, nvals):\n        # transplant node contents into existing element (so it is inserted in-place)\n        node._node.text = val._node.text\n        for child in iter(val):\n            node._node.append(child._node)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.load_xml","title":"load_xml","text":"<pre><code>load_xml(path: Path) -&gt; ET.ElementTree\n</code></pre> <p>Parse an XML file into an ElementTree, preserving comments.</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def load_xml(path: Path) -&gt; ET.ElementTree:\n    \"\"\"Parse an XML file into an ElementTree, preserving comments.\"\"\"\n    path = path if isinstance(path, Path) else Path(path)\n    parser = DET.XMLParser(target=ET.TreeBuilder(insert_comments=True))\n    return DET.parse(path, parser=parser)\n</code></pre>"},{"location":"reference/somesy/pom_xml/xmlproxy/#somesy.pom_xml.xmlproxy.indent","title":"indent","text":"<pre><code>indent(elem, level=0)\n</code></pre> <p>Indent the elements of this XML node (i.e. pretty print).</p> Source code in <code>src/somesy/pom_xml/xmlproxy.py</code> <pre><code>def indent(elem, level=0):\n    \"\"\"Indent the elements of this XML node (i.e. pretty print).\"\"\"\n    i = \"\\n\" + level * \"  \"\n    if len(elem):\n        if not elem.text or not elem.text.strip():\n            elem.text = i + \"  \"\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n        for el in elem:\n            indent(el, level + 1)\n        if not el.tail or not el.tail.strip():\n            el.tail = i\n    else:\n        if level and (not elem.tail or not elem.tail.strip()):\n            elem.tail = i\n</code></pre>"},{"location":"reference/somesy/pyproject/","title":"pyproject","text":"<p>Pyproject module.</p>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Poetry","title":"Poetry","text":"<p>               Bases: <code>PyprojectCommon</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Poetry(PyprojectCommon):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(\n            path,\n            section=[\"tool\", \"poetry\"],\n            model_cls=PoetryConfig,\n            pass_validation=pass_validation,\n        )\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Poetry.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(\n        path,\n        section=[\"tool\", \"poetry\"],\n        model_cls=PoetryConfig,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Pyproject","title":"Pyproject","text":"<p>               Bases: <code>ObjectProxy</code></p> <p>Class for syncing pyproject file with other metadata files.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Pyproject(wrapt.ObjectProxy):\n    \"\"\"Class for syncing pyproject file with other metadata files.\"\"\"\n\n    __wrapped__: Union[SetupTools, Poetry]\n\n    def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n        \"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n        Args:\n            path (Path): Path to pyproject.toml file.\n            pass_validation (bool, optional): Whether to pass validation. Defaults to False.\n\n        Raises:\n            FileNotFoundError: Raised when pyproject.toml file is not found.\n            ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n\n        \"\"\"\n        data = None\n        if not path.is_file():\n            raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n        with open(path, \"r\") as f:\n            data = load(f)\n\n        # inspect file to pick suitable project metadata writer\n        if \"project\" in data:\n            logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n            self.__wrapped__ = SetupTools(path, pass_validation=pass_validation)\n        elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n            logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n            self.__wrapped__ = Poetry(path, pass_validation=pass_validation)\n        else:\n            msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n            raise ValueError(msg)\n\n        super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.Pyproject.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Pyproject wrapper class. Wraps either setuptools or poetry.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to pyproject.toml file.</p> required <code>pass_validation</code> <code>bool</code> <p>Whether to pass validation. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised when pyproject.toml file is not found.</p> <code>ValueError</code> <p>Neither project nor tool.poetry object is found in pyproject.toml file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n    \"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n    Args:\n        path (Path): Path to pyproject.toml file.\n        pass_validation (bool, optional): Whether to pass validation. Defaults to False.\n\n    Raises:\n        FileNotFoundError: Raised when pyproject.toml file is not found.\n        ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n\n    \"\"\"\n    data = None\n    if not path.is_file():\n        raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n    with open(path, \"r\") as f:\n        data = load(f)\n\n    # inspect file to pick suitable project metadata writer\n    if \"project\" in data:\n        logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n        self.__wrapped__ = SetupTools(path, pass_validation=pass_validation)\n    elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n        logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n        self.__wrapped__ = Poetry(path, pass_validation=pass_validation)\n    else:\n        msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n        raise ValueError(msg)\n\n    super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.SetupTools","title":"SetupTools","text":"<p>               Bases: <code>PyprojectCommon</code></p> <p>Setuptools config file handler parsed from setup.cfg.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class SetupTools(PyprojectCommon):\n    \"\"\"Setuptools config file handler parsed from setup.cfg.\"\"\"\n\n    def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n        \"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        section = [\"project\"]\n        mappings = {\n            \"homepage\": [\"urls\", \"homepage\"],\n            \"repository\": [\"urls\", \"repository\"],\n            \"documentation\": [\"urls\", \"documentation\"],\n            \"license\": [\"license\", \"text\"],\n        }\n        super().__init__(\n            path,\n            section=section,\n            direct_mappings=mappings,\n            model_cls=SetuptoolsConfig,\n            pass_validation=pass_validation,\n        )\n\n    @staticmethod\n    def _from_person(person: Person):\n        \"\"\"Convert project metadata person object to setuptools dict for person format.\"\"\"\n        response = {\"name\": person.full_name}\n        if person.email:\n            response[\"email\"] = person.email\n        return response\n\n    @staticmethod\n    def _to_person(person: Union[str, dict]) -&gt; Optional[Union[Entity, Person]]:\n        \"\"\"Parse setuptools person string to a Person/Entity.\"\"\"\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        if isinstance(person, dict):\n            temp = str(person[\"name\"])\n            if \"email\" in person:\n                temp = f\"{temp} &lt;{person['email']}&gt;\"\n            person = temp\n\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync metadata with pyproject.toml file and fix license field.\"\"\"\n        super().sync(metadata)\n\n        # if license field has both text and file, remove file\n        if (\n            self._get_property([\"license\", \"file\"]) is not None\n            and self._get_property([\"license\", \"text\"]) is not None\n        ):\n            # delete license file property\n            self._data[\"project\"][\"license\"].pop(\"file\")\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.SetupTools.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Setuptools config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n    \"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    section = [\"project\"]\n    mappings = {\n        \"homepage\": [\"urls\", \"homepage\"],\n        \"repository\": [\"urls\", \"repository\"],\n        \"documentation\": [\"urls\", \"documentation\"],\n        \"license\": [\"license\", \"text\"],\n    }\n    super().__init__(\n        path,\n        section=section,\n        direct_mappings=mappings,\n        model_cls=SetuptoolsConfig,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/#somesy.pyproject.SetupTools.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync metadata with pyproject.toml file and fix license field.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync metadata with pyproject.toml file and fix license field.\"\"\"\n    super().sync(metadata)\n\n    # if license field has both text and file, remove file\n    if (\n        self._get_property([\"license\", \"file\"]) is not None\n        and self._get_property([\"license\", \"text\"]) is not None\n    ):\n        # delete license file property\n        self._data[\"project\"][\"license\"].pop(\"file\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/","title":"models","text":"<p>Pyproject models.</p>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig","title":"PoetryConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Poetry configuration model.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class PoetryConfig(BaseModel):\n    \"\"\"Poetry configuration model.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    name: Annotated[\n        str,\n        Field(pattern=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\", description=\"Package name\"),\n    ]\n    version: Annotated[\n        str,\n        Field(\n            pattern=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\",\n            description=\"Package version\",\n        ),\n    ]\n    description: Annotated[str, Field(description=\"Package description\")]\n    license: Annotated[\n        Optional[Union[LicenseEnum, List[LicenseEnum]]],\n        Field(description=\"An SPDX license identifier.\"),\n    ]\n    authors: Annotated[Set[str], Field(description=\"Package authors\")]\n    maintainers: Annotated[\n        Optional[Set[str]], Field(description=\"Package maintainers\")\n    ] = None\n    readme: Annotated[\n        Optional[Union[Path, List[Path]]], Field(description=\"Package readme file(s)\")\n    ] = None\n    homepage: Annotated[Optional[HttpUrlStr], Field(description=\"Package homepage\")] = (\n        None\n    )\n    repository: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Package repository\")\n    ] = None\n    documentation: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Package documentation page\")\n    ] = None\n    keywords: Annotated[\n        Optional[Set[str]], Field(description=\"Keywords that describe the package\")\n    ] = None\n    classifiers: Annotated[\n        Optional[List[str]], Field(description=\"pypi classifiers\")\n    ] = None\n    urls: Annotated[\n        Optional[Dict[str, HttpUrlStr]], Field(description=\"Package URLs\")\n    ] = None\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid version\") from err\n        return v\n\n    @field_validator(\"authors\", \"maintainers\")\n    @classmethod\n    def validate_email_format(cls, v):\n        \"\"\"Validate person format, omit person that is not in correct format, don't raise an error.\"\"\"\n        if v is None:\n            return []\n        validated = []\n        for author in v:\n            try:\n                if not (\n                    not isinstance(author, str)\n                    or \" \" not in author\n                    or not EMailAddress.validate_python(author.split(\" \")[-1][1:-1])\n                ):\n                    validated.append(author)\n                else:\n                    logger.warning(\n                        f\"Invalid email format for author/maintainer {author}, omitting.\"\n                    )\n            except ValidationError:\n                logger.warning(\n                    f\"Invalid email format for author/maintainer {author}, omitting.\"\n                )\n        return validated\n\n    @field_validator(\"readme\")\n    @classmethod\n    def validate_readme(cls, v):\n        \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n        if isinstance(v, list):\n            if any(not e.is_file() for e in v):\n                logger.warning(\"Some readme file(s) do not exist\")\n        else:\n            if not v.is_file():\n                logger.warning(\"Readme file does not exist\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid version\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_email_format","title":"validate_email_format  <code>classmethod</code>","text":"<pre><code>validate_email_format(v)\n</code></pre> <p>Validate person format, omit person that is not in correct format, don't raise an error.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"authors\", \"maintainers\")\n@classmethod\ndef validate_email_format(cls, v):\n    \"\"\"Validate person format, omit person that is not in correct format, don't raise an error.\"\"\"\n    if v is None:\n        return []\n    validated = []\n    for author in v:\n        try:\n            if not (\n                not isinstance(author, str)\n                or \" \" not in author\n                or not EMailAddress.validate_python(author.split(\" \")[-1][1:-1])\n            ):\n                validated.append(author)\n            else:\n                logger.warning(\n                    f\"Invalid email format for author/maintainer {author}, omitting.\"\n                )\n        except ValidationError:\n            logger.warning(\n                f\"Invalid email format for author/maintainer {author}, omitting.\"\n            )\n    return validated\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.PoetryConfig.validate_readme","title":"validate_readme  <code>classmethod</code>","text":"<pre><code>validate_readme(v)\n</code></pre> <p>Validate readme file(s) by checking whether files exist.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"readme\")\n@classmethod\ndef validate_readme(cls, v):\n    \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n    if isinstance(v, list):\n        if any(not e.is_file() for e in v):\n            logger.warning(\"Some readme file(s) do not exist\")\n    else:\n        if not v.is_file():\n            logger.warning(\"Readme file does not exist\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.ContentTypeEnum","title":"ContentTypeEnum","text":"<p>               Bases: <code>Enum</code></p> <p>Content type enum for setuptools field file.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class ContentTypeEnum(Enum):\n    \"\"\"Content type enum for setuptools field file.\"\"\"\n\n    plain = \"text/plain\"\n    rst = \"text/x-rst\"\n    markdown = \"text/markdown\"\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.File","title":"File","text":"<p>               Bases: <code>BaseModel</code></p> <p>File model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class File(BaseModel):\n    \"\"\"File model for setuptools.\"\"\"\n\n    file: Path\n    content_type: Optional[ContentTypeEnum] = Field(alias=\"content-type\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.License","title":"License","text":"<p>               Bases: <code>BaseModel</code></p> <p>License model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class License(BaseModel):\n    \"\"\"License model for setuptools.\"\"\"\n\n    model_config = dict(validate_assignment=True)\n\n    file: Optional[Path] = None\n    text: Optional[LicenseEnum] = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def validate_xor(cls, values):\n        \"\"\"Validate that only one of file or text is set.\"\"\"\n        if sum([bool(v) for v in values.values()]) != 1:\n            raise ValueError(\"Either file or text must be set.\")\n        return values\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.License.validate_xor","title":"validate_xor  <code>classmethod</code>","text":"<pre><code>validate_xor(values)\n</code></pre> <p>Validate that only one of file or text is set.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef validate_xor(cls, values):\n    \"\"\"Validate that only one of file or text is set.\"\"\"\n    if sum([bool(v) for v in values.values()]) != 1:\n        raise ValueError(\"Either file or text must be set.\")\n    return values\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.STPerson","title":"STPerson","text":"<p>               Bases: <code>BaseModel</code></p> <p>Person model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class STPerson(BaseModel):\n    \"\"\"Person model for setuptools.\"\"\"\n\n    name: Annotated[str, Field(min_length=1)]\n    email: Annotated[Optional[str], Field(min_length=1)] = None\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.URLs","title":"URLs","text":"<p>               Bases: <code>BaseModel</code></p> <p>URLs model for setuptools.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class URLs(BaseModel):\n    \"\"\"URLs model for setuptools.\"\"\"\n\n    homepage: Optional[HttpUrlStr] = None\n    repository: Optional[HttpUrlStr] = None\n    documentation: Optional[HttpUrlStr] = None\n    changelog: Optional[HttpUrlStr] = None\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig","title":"SetuptoolsConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Setuptools input model. Required fields are name, version, description, and requires_python.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>class SetuptoolsConfig(BaseModel):\n    \"\"\"Setuptools input model. Required fields are name, version, description, and requires_python.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    name: Annotated[str, Field(pattern=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\")]\n    version: Annotated[\n        str, Field(pattern=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\")\n    ]\n    description: str\n    readme: Optional[Union[Path, List[Path], File]] = None\n    license: Optional[License] = Field(None, description=\"An SPDX license identifier.\")\n    authors: Optional[List[STPerson]] = None\n    maintainers: Optional[List[STPerson]] = None\n    keywords: Optional[Set[str]] = None\n    classifiers: Optional[List[str]] = None\n    urls: Optional[URLs] = None\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid version\") from err\n        return v\n\n    @field_validator(\"readme\")\n    @classmethod\n    def validate_readme(cls, v):\n        \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n        if isinstance(v, list):\n            if any(not e.is_file() for e in v):\n                raise ValueError(\"Some file(s) do not exist\")\n        elif type(v) is File:\n            if not Path(v.file).is_file():\n                raise ValueError(\"File does not exist\")\n        else:\n            if not v.is_file():\n                raise ValueError(\"File does not exist\")\n\n    @field_validator(\"authors\", \"maintainers\")\n    @classmethod\n    def validate_email_format(cls, v):\n        \"\"\"Validate email format.\"\"\"\n        for person in v:\n            if person.email:\n                if not EMailAddress.validate_python(person.email):\n                    raise ValueError(\"Invalid email format\")\n        return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid version\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_readme","title":"validate_readme  <code>classmethod</code>","text":"<pre><code>validate_readme(v)\n</code></pre> <p>Validate readme file(s) by checking whether files exist.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"readme\")\n@classmethod\ndef validate_readme(cls, v):\n    \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n    if isinstance(v, list):\n        if any(not e.is_file() for e in v):\n            raise ValueError(\"Some file(s) do not exist\")\n    elif type(v) is File:\n        if not Path(v.file).is_file():\n            raise ValueError(\"File does not exist\")\n    else:\n        if not v.is_file():\n            raise ValueError(\"File does not exist\")\n</code></pre>"},{"location":"reference/somesy/pyproject/models/#somesy.pyproject.models.SetuptoolsConfig.validate_email_format","title":"validate_email_format  <code>classmethod</code>","text":"<pre><code>validate_email_format(v)\n</code></pre> <p>Validate email format.</p> Source code in <code>src/somesy/pyproject/models.py</code> <pre><code>@field_validator(\"authors\", \"maintainers\")\n@classmethod\ndef validate_email_format(cls, v):\n    \"\"\"Validate email format.\"\"\"\n    for person in v:\n        if person.email:\n            if not EMailAddress.validate_python(person.email):\n                raise ValueError(\"Invalid email format\")\n    return v\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/","title":"writer","text":"<p>Pyproject writers for setuptools and poetry.</p>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon","title":"PyprojectCommon","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class PyprojectCommon(ProjectMetadataWriter):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        *,\n        section: List[str],\n        model_cls,\n        direct_mappings=None,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._model_cls = model_cls\n        self._section = section\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=direct_mappings or {},\n            pass_validation=pass_validation,\n        )\n\n    def _load(self) -&gt; None:\n        \"\"\"Load pyproject.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = tomlkit.load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate poetry config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {self._model_cls.__name__}: {pretty_repr(config)}\"\n        )\n        self._model_cls(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the pyproject file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            tomlkit.dump(self._data, f)\n\n    def _get_property(\n        self, key: Union[str, List[str]], *, remove: bool = False, **kwargs\n    ) -&gt; Optional[Any]:\n        \"\"\"Get a property from the pyproject.toml file.\"\"\"\n        key_path = [key] if isinstance(key, str) else key\n        full_path = self._section + key_path\n        return super()._get_property(full_path, remove=remove, **kwargs)\n\n    def _set_property(self, key: Union[str, List[str], IgnoreKey], value: Any) -&gt; None:\n        \"\"\"Set a property in the pyproject.toml file.\"\"\"\n        if isinstance(key, IgnoreKey):\n            return\n        key_path = [key] if isinstance(key, str) else key\n\n        if not value:  # remove value and clean up the sub-dict\n            self._get_property(key_path, remove=True)\n            return\n\n        # get the tomlkit object of the section\n        dat = self._get_property([])\n\n        # dig down, create missing nested objects on the fly\n        curr = dat\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr.add(key, tomlkit.table())\n            curr = curr[key]\n        curr[key_path[-1]] = value\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path,\n    *,\n    section: List[str],\n    model_cls,\n    direct_mappings=None,\n    pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    *,\n    section: List[str],\n    model_cls,\n    direct_mappings=None,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._model_cls = model_cls\n    self._section = section\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=direct_mappings or {},\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.PyprojectCommon.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the pyproject file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the pyproject file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        tomlkit.dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Poetry","title":"Poetry","text":"<p>               Bases: <code>PyprojectCommon</code></p> <p>Poetry config file handler parsed from pyproject.toml.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Poetry(PyprojectCommon):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        super().__init__(\n            path,\n            section=[\"tool\", \"poetry\"],\n            model_cls=PoetryConfig,\n            pass_validation=pass_validation,\n        )\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to poetry string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Convert from free string to person or entity object.\"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Poetry.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Poetry config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Poetry config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    super().__init__(\n        path,\n        section=[\"tool\", \"poetry\"],\n        model_cls=PoetryConfig,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.SetupTools","title":"SetupTools","text":"<p>               Bases: <code>PyprojectCommon</code></p> <p>Setuptools config file handler parsed from setup.cfg.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class SetupTools(PyprojectCommon):\n    \"\"\"Setuptools config file handler parsed from setup.cfg.\"\"\"\n\n    def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n        \"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        section = [\"project\"]\n        mappings = {\n            \"homepage\": [\"urls\", \"homepage\"],\n            \"repository\": [\"urls\", \"repository\"],\n            \"documentation\": [\"urls\", \"documentation\"],\n            \"license\": [\"license\", \"text\"],\n        }\n        super().__init__(\n            path,\n            section=section,\n            direct_mappings=mappings,\n            model_cls=SetuptoolsConfig,\n            pass_validation=pass_validation,\n        )\n\n    @staticmethod\n    def _from_person(person: Person):\n        \"\"\"Convert project metadata person object to setuptools dict for person format.\"\"\"\n        response = {\"name\": person.full_name}\n        if person.email:\n            response[\"email\"] = person.email\n        return response\n\n    @staticmethod\n    def _to_person(person: Union[str, dict]) -&gt; Optional[Union[Entity, Person]]:\n        \"\"\"Parse setuptools person string to a Person/Entity.\"\"\"\n        # NOTE: for our purposes, does not matter what are given or family names,\n        # we only compare on full_name anyway.\n        if isinstance(person, dict):\n            temp = str(person[\"name\"])\n            if \"email\" in person:\n                temp = f\"{temp} &lt;{person['email']}&gt;\"\n            person = temp\n\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync metadata with pyproject.toml file and fix license field.\"\"\"\n        super().sync(metadata)\n\n        # if license field has both text and file, remove file\n        if (\n            self._get_property([\"license\", \"file\"]) is not None\n            and self._get_property([\"license\", \"text\"]) is not None\n        ):\n            # delete license file property\n            self._data[\"project\"][\"license\"].pop(\"file\")\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.SetupTools.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Setuptools config file handler parsed from pyproject.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n    \"\"\"Setuptools config file handler parsed from pyproject.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    section = [\"project\"]\n    mappings = {\n        \"homepage\": [\"urls\", \"homepage\"],\n        \"repository\": [\"urls\", \"repository\"],\n        \"documentation\": [\"urls\", \"documentation\"],\n        \"license\": [\"license\", \"text\"],\n    }\n    super().__init__(\n        path,\n        section=section,\n        direct_mappings=mappings,\n        model_cls=SetuptoolsConfig,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.SetupTools.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync metadata with pyproject.toml file and fix license field.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync metadata with pyproject.toml file and fix license field.\"\"\"\n    super().sync(metadata)\n\n    # if license field has both text and file, remove file\n    if (\n        self._get_property([\"license\", \"file\"]) is not None\n        and self._get_property([\"license\", \"text\"]) is not None\n    ):\n        # delete license file property\n        self._data[\"project\"][\"license\"].pop(\"file\")\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Pyproject","title":"Pyproject","text":"<p>               Bases: <code>ObjectProxy</code></p> <p>Class for syncing pyproject file with other metadata files.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>class Pyproject(wrapt.ObjectProxy):\n    \"\"\"Class for syncing pyproject file with other metadata files.\"\"\"\n\n    __wrapped__: Union[SetupTools, Poetry]\n\n    def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n        \"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n        Args:\n            path (Path): Path to pyproject.toml file.\n            pass_validation (bool, optional): Whether to pass validation. Defaults to False.\n\n        Raises:\n            FileNotFoundError: Raised when pyproject.toml file is not found.\n            ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n\n        \"\"\"\n        data = None\n        if not path.is_file():\n            raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n        with open(path, \"r\") as f:\n            data = load(f)\n\n        # inspect file to pick suitable project metadata writer\n        if \"project\" in data:\n            logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n            self.__wrapped__ = SetupTools(path, pass_validation=pass_validation)\n        elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n            logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n            self.__wrapped__ = Poetry(path, pass_validation=pass_validation)\n        else:\n            msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n            raise ValueError(msg)\n\n        super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/pyproject/writer/#somesy.pyproject.writer.Pyproject.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Pyproject wrapper class. Wraps either setuptools or poetry.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to pyproject.toml file.</p> required <code>pass_validation</code> <code>bool</code> <p>Whether to pass validation. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raised when pyproject.toml file is not found.</p> <code>ValueError</code> <p>Neither project nor tool.poetry object is found in pyproject.toml file.</p> Source code in <code>src/somesy/pyproject/writer.py</code> <pre><code>def __init__(self, path: Path, pass_validation: Optional[bool] = False):\n    \"\"\"Pyproject wrapper class. Wraps either setuptools or poetry.\n\n    Args:\n        path (Path): Path to pyproject.toml file.\n        pass_validation (bool, optional): Whether to pass validation. Defaults to False.\n\n    Raises:\n        FileNotFoundError: Raised when pyproject.toml file is not found.\n        ValueError: Neither project nor tool.poetry object is found in pyproject.toml file.\n\n    \"\"\"\n    data = None\n    if not path.is_file():\n        raise FileNotFoundError(f\"pyproject file {path} not found\")\n\n    with open(path, \"r\") as f:\n        data = load(f)\n\n    # inspect file to pick suitable project metadata writer\n    if \"project\" in data:\n        logger.verbose(\"Found setuptools-based metadata in pyproject.toml\")\n        self.__wrapped__ = SetupTools(path, pass_validation=pass_validation)\n    elif \"tool\" in data and \"poetry\" in data[\"tool\"]:\n        logger.verbose(\"Found poetry-based metadata in pyproject.toml\")\n        self.__wrapped__ = Poetry(path, pass_validation=pass_validation)\n    else:\n        msg = \"The pyproject.toml file is ambiguous, either add a [project] or [tool.poetry] section\"\n        raise ValueError(msg)\n\n    super().__init__(self.__wrapped__)\n</code></pre>"},{"location":"reference/somesy/rust/","title":"rust","text":"<p>Rust module.</p>"},{"location":"reference/somesy/rust/#somesy.rust.Rust","title":"Rust","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Rust config file handler parsed from Cargo.toml.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>class Rust(ProjectMetadataWriter):\n    \"\"\"Rust config file handler parsed from Cargo.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Rust config file handler parsed from Cargo.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._section = [\"package\"]\n        mappings: FieldKeyMapping = {\n            \"maintainers\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self) -&gt; None:\n        \"\"\"Load Cargo.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate rust config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {RustConfig.__name__}: {pretty_repr(config)}\"\n        )\n        RustConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the Cargo.toml file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            dump(self._data, f)\n\n    def _get_property(\n        self, key: Union[str, List[str], IgnoreKey], *, remove: bool = False, **kwargs\n    ) -&gt; Optional[Any]:\n        \"\"\"Get a property from the Cargo.toml file.\"\"\"\n        if isinstance(key, IgnoreKey):\n            return None\n        key_path = [key] if isinstance(key, str) else key\n        full_path = self._section + key_path\n        return super()._get_property(full_path, remove=remove, **kwargs)\n\n    def _set_property(self, key: Union[str, List[str], IgnoreKey], value: Any) -&gt; None:\n        \"\"\"Set a property in the Cargo.toml file.\"\"\"\n        if isinstance(key, IgnoreKey):\n            return\n        key_path = [key] if isinstance(key, str) else key\n\n        if not value:  # remove value and clean up the sub-dict\n            self._get_property(key_path, remove=True)\n            return\n\n        # get the tomlkit object of the section\n        dat = self._get_property([])\n\n        # dig down, create missing nested objects on the fly\n        curr = dat\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr.add(key, table())\n            curr = curr[key]\n        curr[key_path[-1]] = value\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to rust string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Parse rust person string to a Person. It has format \"full name &lt;email&gt;.\" but email is optional.\n\n        Since there is no way to know whether this entry is a person or an entity, we will directly convert to Person.\n        \"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    @classmethod\n    def _parse_people(cls, people: Optional[List[Any]]) -&gt; List[Person]:\n        \"\"\"Return a list of Persons parsed from list of format-specific people representations. to_person can return None, so filter out None values.\"\"\"\n        return list(filter(None, map(cls._to_person, people or [])))\n\n    @property\n    def keywords(self) -&gt; Optional[List[str]]:\n        \"\"\"Return the keywords of the project.\"\"\"\n        return self._get_property(self._get_key(\"keywords\"))\n\n    @keywords.setter\n    def keywords(self, keywords: List[str]) -&gt; None:\n        \"\"\"Set the keywords of the project.\"\"\"\n        validated_keywords = []\n        for keyword in keywords:\n            try:\n                check_keyword(keyword)\n                validated_keywords.append(keyword)\n            except ValueError as e:\n                logger.debug(f\"Invalid keyword {keyword}: {e}\")\n\n        # keyword count should max 5, so delete the rest\n        if len(validated_keywords) &gt; 5:\n            validated_keywords = validated_keywords[:5]\n        self._set_property(self._get_key(\"keywords\"), validated_keywords)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync the rust config with the project metadata.\"\"\"\n        super().sync(metadata)\n\n        # if there is a license file, remove the license field\n        if self._get_key(\"license_file\"):\n            self.license = None\n</code></pre>"},{"location":"reference/somesy/rust/#somesy.rust.Rust.keywords","title":"keywords  <code>property</code> <code>writable</code>","text":"<pre><code>keywords: Optional[List[str]]\n</code></pre> <p>Return the keywords of the project.</p>"},{"location":"reference/somesy/rust/#somesy.rust.Rust.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Rust config file handler parsed from Cargo.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Rust config file handler parsed from Cargo.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._section = [\"package\"]\n    mappings: FieldKeyMapping = {\n        \"maintainers\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/rust/#somesy.rust.Rust.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the Cargo.toml file.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the Cargo.toml file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/rust/#somesy.rust.Rust.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync the rust config with the project metadata.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync the rust config with the project metadata.\"\"\"\n    super().sync(metadata)\n\n    # if there is a license file, remove the license field\n    if self._get_key(\"license_file\"):\n        self.license = None\n</code></pre>"},{"location":"reference/somesy/rust/models/","title":"models","text":"<p>Pyproject models.</p>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.RustConfig","title":"RustConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Rust configuration model.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>class RustConfig(BaseModel):\n    \"\"\"Rust configuration model.\"\"\"\n\n    model_config = dict(use_enum_values=True)\n\n    name: Annotated[\n        str,\n        Field(\n            pattern=r\"^[A-Za-z0-9]+([_-][A-Za-z0-9]+)*$\",\n            max_length=64,\n            description=\"Package name\",\n        ),\n    ]\n    version: Annotated[\n        str,\n        Field(\n            pattern=r\"^\\d+(\\.\\d+)*((a|b|rc)\\d+)?(post\\d+)?(dev\\d+)?$\",\n            description=\"Package version\",\n        ),\n    ]\n    description: Annotated[Optional[str], Field(description=\"Package description\")] = (\n        None\n    )\n    license: Annotated[\n        Optional[str],\n        Field(\n            description=\"A combination SPDX license identifiers with AND, OR and so on.\"\n        ),\n    ] = None\n    authors: Annotated[Set[str], Field(description=\"Package authors\")]\n    maintainers: Annotated[\n        Optional[Set[str]], Field(description=\"Package maintainers\")\n    ] = None\n    readme: Annotated[\n        Optional[Union[Path, List[Path]]], Field(description=\"Package readme file(s)\")\n    ] = None\n    license_file: Annotated[\n        Optional[Path], Field(description=\"Package license file\")\n    ] = None\n    homepage: Annotated[Optional[HttpUrlStr], Field(description=\"Package homepage\")] = (\n        None\n    )\n    repository: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Package repository\")\n    ] = None\n    documentation: Annotated[\n        Optional[HttpUrlStr], Field(description=\"Package documentation page\")\n    ] = None\n    keywords: Annotated[\n        Optional[Set[str]], Field(description=\"Keywords that describe the package\")\n    ] = None\n    classifiers: Annotated[\n        Optional[List[str]], Field(description=\"pypi classifiers\")\n    ] = None\n    urls: Annotated[\n        Optional[Dict[str, HttpUrlStr]], Field(description=\"Package URLs\")\n    ] = None\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def license_or_file(cls, values):\n        \"\"\"License and license file are mutually exclusive.\"\"\"\n        if \"license\" in values and \"license_file\" in values:\n            raise ValueError(\"license and license_file are mutually exclusive\")\n        return values\n\n    @field_validator(\"version\")\n    @classmethod\n    def validate_version(cls, v):\n        \"\"\"Validate version using PEP 440.\"\"\"\n        try:\n            _ = parse_version(v)\n        except ValueError as err:\n            raise ValueError(\"Invalid version\") from err\n        return v\n\n    @field_validator(\"readme\", \"license_file\")\n    @classmethod\n    def validate_readme(cls, v):\n        \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n        if isinstance(v, list):\n            if any(not e.is_file() for e in v):\n                raise ValueError(\"Some file(s) do not exist\")\n        else:\n            if not v.is_file():\n                raise ValueError(\"File does not exist\")\n\n    @field_validator(\"keywords\")\n    @classmethod\n    def check_keywords_field(cls, v):\n        \"\"\"Check the keywords field.\"\"\"\n        if v is None:\n            return v\n\n        # Check if number of keywords is at most 5\n        if v is not None and len(v) &gt; 5:\n            raise ValueError(\"A maximum of 5 keywords is allowed\")\n\n        for keyword in v:\n            check_keyword(keyword)\n\n        return v\n</code></pre>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.RustConfig.license_or_file","title":"license_or_file  <code>classmethod</code>","text":"<pre><code>license_or_file(values)\n</code></pre> <p>License and license file are mutually exclusive.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>@model_validator(mode=\"before\")\n@classmethod\ndef license_or_file(cls, values):\n    \"\"\"License and license file are mutually exclusive.\"\"\"\n    if \"license\" in values and \"license_file\" in values:\n        raise ValueError(\"license and license_file are mutually exclusive\")\n    return values\n</code></pre>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.RustConfig.validate_version","title":"validate_version  <code>classmethod</code>","text":"<pre><code>validate_version(v)\n</code></pre> <p>Validate version using PEP 440.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>@field_validator(\"version\")\n@classmethod\ndef validate_version(cls, v):\n    \"\"\"Validate version using PEP 440.\"\"\"\n    try:\n        _ = parse_version(v)\n    except ValueError as err:\n        raise ValueError(\"Invalid version\") from err\n    return v\n</code></pre>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.RustConfig.validate_readme","title":"validate_readme  <code>classmethod</code>","text":"<pre><code>validate_readme(v)\n</code></pre> <p>Validate readme file(s) by checking whether files exist.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>@field_validator(\"readme\", \"license_file\")\n@classmethod\ndef validate_readme(cls, v):\n    \"\"\"Validate readme file(s) by checking whether files exist.\"\"\"\n    if isinstance(v, list):\n        if any(not e.is_file() for e in v):\n            raise ValueError(\"Some file(s) do not exist\")\n    else:\n        if not v.is_file():\n            raise ValueError(\"File does not exist\")\n</code></pre>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.RustConfig.check_keywords_field","title":"check_keywords_field  <code>classmethod</code>","text":"<pre><code>check_keywords_field(v)\n</code></pre> <p>Check the keywords field.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>@field_validator(\"keywords\")\n@classmethod\ndef check_keywords_field(cls, v):\n    \"\"\"Check the keywords field.\"\"\"\n    if v is None:\n        return v\n\n    # Check if number of keywords is at most 5\n    if v is not None and len(v) &gt; 5:\n        raise ValueError(\"A maximum of 5 keywords is allowed\")\n\n    for keyword in v:\n        check_keyword(keyword)\n\n    return v\n</code></pre>"},{"location":"reference/somesy/rust/models/#somesy.rust.models.check_keyword","title":"check_keyword","text":"<pre><code>check_keyword(keyword: str)\n</code></pre> <p>Check if keyword is valid.</p> Source code in <code>src/somesy/rust/models.py</code> <pre><code>def check_keyword(keyword: str):\n    \"\"\"Check if keyword is valid.\"\"\"\n    # Check if keyword is ASCII and has at most 20 characters\n    if not keyword.isascii() or len(keyword) &gt; 20:\n        raise ValueError(\n            \"Each keyword must be ASCII text and have at most 20 characters\"\n        )\n\n    # Check if keyword starts with an alphanumeric character\n    if not re.match(r\"^[a-zA-Z0-9]\", keyword):\n        raise ValueError(\"Each keyword must start with an alphanumeric character\")\n\n    # Check if keyword contains only allowed characters\n    if not re.match(r\"^[a-zA-Z0-9_\\-+]+$\", keyword):\n        raise ValueError(\"Keywords can only contain letters, numbers, _, -, or +\")\n</code></pre>"},{"location":"reference/somesy/rust/writer/","title":"writer","text":"<p>Pyproject writers for setuptools and rust.</p>"},{"location":"reference/somesy/rust/writer/#somesy.rust.writer.Rust","title":"Rust","text":"<p>               Bases: <code>ProjectMetadataWriter</code></p> <p>Rust config file handler parsed from Cargo.toml.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>class Rust(ProjectMetadataWriter):\n    \"\"\"Rust config file handler parsed from Cargo.toml.\"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        pass_validation: Optional[bool] = False,\n    ):\n        \"\"\"Rust config file handler parsed from Cargo.toml.\n\n        See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n        \"\"\"\n        self._section = [\"package\"]\n        mappings: FieldKeyMapping = {\n            \"maintainers\": IgnoreKey(),\n        }\n        super().__init__(\n            path,\n            create_if_not_exists=False,\n            direct_mappings=mappings,\n            pass_validation=pass_validation,\n        )\n\n    def _load(self) -&gt; None:\n        \"\"\"Load Cargo.toml file.\"\"\"\n        with open(self.path) as f:\n            self._data = load(f)\n\n    def _validate(self) -&gt; None:\n        \"\"\"Validate rust config using pydantic class.\n\n        In order to preserve toml comments and structure, tomlkit library is used.\n        Pydantic class only used for validation.\n        \"\"\"\n        if self.pass_validation:\n            return\n        config = dict(self._get_property([]))\n        logger.debug(\n            f\"Validating config using {RustConfig.__name__}: {pretty_repr(config)}\"\n        )\n        RustConfig(**config)\n\n    def save(self, path: Optional[Path] = None) -&gt; None:\n        \"\"\"Save the Cargo.toml file.\"\"\"\n        path = path or self.path\n        with open(path, \"w\") as f:\n            dump(self._data, f)\n\n    def _get_property(\n        self, key: Union[str, List[str], IgnoreKey], *, remove: bool = False, **kwargs\n    ) -&gt; Optional[Any]:\n        \"\"\"Get a property from the Cargo.toml file.\"\"\"\n        if isinstance(key, IgnoreKey):\n            return None\n        key_path = [key] if isinstance(key, str) else key\n        full_path = self._section + key_path\n        return super()._get_property(full_path, remove=remove, **kwargs)\n\n    def _set_property(self, key: Union[str, List[str], IgnoreKey], value: Any) -&gt; None:\n        \"\"\"Set a property in the Cargo.toml file.\"\"\"\n        if isinstance(key, IgnoreKey):\n            return\n        key_path = [key] if isinstance(key, str) else key\n\n        if not value:  # remove value and clean up the sub-dict\n            self._get_property(key_path, remove=True)\n            return\n\n        # get the tomlkit object of the section\n        dat = self._get_property([])\n\n        # dig down, create missing nested objects on the fly\n        curr = dat\n        for key in key_path[:-1]:\n            if key not in curr:\n                curr.add(key, table())\n            curr = curr[key]\n        curr[key_path[-1]] = value\n\n    @staticmethod\n    def _from_person(person: Union[Person, Entity]):\n        \"\"\"Convert project metadata person object to rust string for person format \"full name &lt;email&gt;.\"\"\"\n        return person.to_name_email_string()\n\n    @staticmethod\n    def _to_person(person: str) -&gt; Optional[Union[Person, Entity]]:\n        \"\"\"Parse rust person string to a Person. It has format \"full name &lt;email&gt;.\" but email is optional.\n\n        Since there is no way to know whether this entry is a person or an entity, we will directly convert to Person.\n        \"\"\"\n        try:\n            return Person.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.info(f\"Cannot convert {person} to Person object, trying Entity.\")\n\n        try:\n            return Entity.from_name_email_string(person)\n        except (ValueError, AttributeError):\n            logger.warning(f\"Cannot convert {person} to Entity.\")\n            return None\n\n    @classmethod\n    def _parse_people(cls, people: Optional[List[Any]]) -&gt; List[Person]:\n        \"\"\"Return a list of Persons parsed from list of format-specific people representations. to_person can return None, so filter out None values.\"\"\"\n        return list(filter(None, map(cls._to_person, people or [])))\n\n    @property\n    def keywords(self) -&gt; Optional[List[str]]:\n        \"\"\"Return the keywords of the project.\"\"\"\n        return self._get_property(self._get_key(\"keywords\"))\n\n    @keywords.setter\n    def keywords(self, keywords: List[str]) -&gt; None:\n        \"\"\"Set the keywords of the project.\"\"\"\n        validated_keywords = []\n        for keyword in keywords:\n            try:\n                check_keyword(keyword)\n                validated_keywords.append(keyword)\n            except ValueError as e:\n                logger.debug(f\"Invalid keyword {keyword}: {e}\")\n\n        # keyword count should max 5, so delete the rest\n        if len(validated_keywords) &gt; 5:\n            validated_keywords = validated_keywords[:5]\n        self._set_property(self._get_key(\"keywords\"), validated_keywords)\n\n    def sync(self, metadata: ProjectMetadata) -&gt; None:\n        \"\"\"Sync the rust config with the project metadata.\"\"\"\n        super().sync(metadata)\n\n        # if there is a license file, remove the license field\n        if self._get_key(\"license_file\"):\n            self.license = None\n</code></pre>"},{"location":"reference/somesy/rust/writer/#somesy.rust.writer.Rust.keywords","title":"keywords  <code>property</code> <code>writable</code>","text":"<pre><code>keywords: Optional[List[str]]\n</code></pre> <p>Return the keywords of the project.</p>"},{"location":"reference/somesy/rust/writer/#somesy.rust.writer.Rust.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Path, pass_validation: Optional[bool] = False\n)\n</code></pre> <p>Rust config file handler parsed from Cargo.toml.</p> <p>See somesy.core.writer.ProjectMetadataWriter.init.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    pass_validation: Optional[bool] = False,\n):\n    \"\"\"Rust config file handler parsed from Cargo.toml.\n\n    See [somesy.core.writer.ProjectMetadataWriter.__init__][].\n    \"\"\"\n    self._section = [\"package\"]\n    mappings: FieldKeyMapping = {\n        \"maintainers\": IgnoreKey(),\n    }\n    super().__init__(\n        path,\n        create_if_not_exists=False,\n        direct_mappings=mappings,\n        pass_validation=pass_validation,\n    )\n</code></pre>"},{"location":"reference/somesy/rust/writer/#somesy.rust.writer.Rust.save","title":"save","text":"<pre><code>save(path: Optional[Path] = None) -&gt; None\n</code></pre> <p>Save the Cargo.toml file.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save the Cargo.toml file.\"\"\"\n    path = path or self.path\n    with open(path, \"w\") as f:\n        dump(self._data, f)\n</code></pre>"},{"location":"reference/somesy/rust/writer/#somesy.rust.writer.Rust.sync","title":"sync","text":"<pre><code>sync(metadata: ProjectMetadata) -&gt; None\n</code></pre> <p>Sync the rust config with the project metadata.</p> Source code in <code>src/somesy/rust/writer.py</code> <pre><code>def sync(self, metadata: ProjectMetadata) -&gt; None:\n    \"\"\"Sync the rust config with the project metadata.\"\"\"\n    super().sync(metadata)\n\n    # if there is a license file, remove the license field\n    if self._get_key(\"license_file\"):\n        self.license = None\n</code></pre>"}]}